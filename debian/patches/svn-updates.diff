# DP: updates from the 4.9 branch upto 20140824 (r214405).

last_update()
{
	cat > ${dir}LAST_UPDATED <EOF
Sun Aug 24 09:21:01 CEST 2014
Sun Aug 24 07:21:01 UTC 2014 (revision 214405)
EOF
}

LANG=C svn diff svn://gcc.gnu.org/svn/gcc/tags/gcc_4_9_1_release svn://gcc.gnu.org/svn/gcc/branches/gcc-4_9-branch \
	| sed -r 's,^--- (\S+)\t(\S+)(.*)$,--- a/src/\1\t\2,;s,^\+\+\+ (\S+)\t(\S+)(.*)$,+++ b/src/\1\t\2,' \
	| awk '/^Index:.*\.(class|texi)/ {skip=1; next} /^Index:/ { skip=0 } skip==0'

Index: libitm/configure.tgt
===================================================================
--- a/src/libitm/configure.tgt	(.../tags/gcc_4_9_1_release)
+++ b/src/libitm/configure.tgt	(.../branches/gcc-4_9-branch)
@@ -46,6 +46,7 @@
 # Map the target cpu to an ARCH sub-directory.  At the same time,
 # work out any special compilation flags as necessary.
 case "${target_cpu}" in
+  aarch64*)		ARCH=aarch64 ;;
   alpha*)		ARCH=alpha ;;
   rs6000 | powerpc*)
 	XCFLAGS="${XCFLAGS} -mhtm"
Index: libitm/ChangeLog
===================================================================
--- a/src/libitm/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/libitm/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,9 @@
+2014-07-24  Richard Henderson  <rth@redhat.com>
+
+	* config/aarch64/sjlj.S: New file.
+	* config/aarch64/target.h: New file.
+	* configure.tgt: Enable aarch64.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: libitm/config/aarch64/sjlj.S
===================================================================
--- a/src/libitm/config/aarch64/sjlj.S	(.../tags/gcc_4_9_1_release)
+++ b/src/libitm/config/aarch64/sjlj.S	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,92 @@
+/* Copyright (C) 2014 Free Software Foundation, Inc.
+   Contributed by Richard Henderson <rth@redhat.com>.
+
+   This file is part of the GNU Transactional Memory Library (libitm).
+
+   Libitm is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "asmcfi.h"
+
+	.text
+	.align	2
+	.global	_ITM_beginTransaction
+	.type	_ITM_beginTransaction, %function
+
+_ITM_beginTransaction:
+	cfi_startproc
+	mov	x1, sp
+	stp	x29, x30, [sp, -11*16]!
+	cfi_adjust_cfa_offset(11*16)
+	cfi_rel_offset(x29, 0)
+	cfi_rel_offset(x30, 8)
+	mov	x29, sp
+	stp	x19, x20, [sp, 1*16]
+	stp	x21, x22, [sp, 2*16]
+	stp	x23, x24, [sp, 3*16]
+	stp	x25, x26, [sp, 4*16]
+	stp	x27, x28, [sp, 5*16]
+	stp	d8, d9,   [sp, 6*16]
+	stp	d10, d11, [sp, 7*16]
+	stp	d12, d13, [sp, 8*16]
+	stp	d14, d15, [sp, 9*16]
+	str	x1, [sp, 10*16]
+
+	/* Invoke GTM_begin_transaction with the struct we just built.  */
+	mov	x1, sp
+	bl	GTM_begin_transaction
+
+	/* Return; we don't need to restore any of the call-saved regs.  */
+	ldp	x29, x30, [sp], 11*16
+	cfi_adjust_cfa_offset(-11*16)
+	cfi_restore(x29)
+	cfi_restore(x30)
+	ret
+	cfi_endproc
+	.size	_ITM_beginTransaction, . - _ITM_beginTransaction
+
+	.align	2
+	.global	GTM_longjmp
+	.hidden	GTM_longjmp
+	.type	GTM_longjmp, %function
+
+GTM_longjmp:
+	/* The first parameter becomes the return value (x0).
+	   The third parameter is ignored for now.  */
+	cfi_startproc
+	ldp	x19, x20, [x1, 1*16]
+	ldp	x21, x22, [x1, 2*16]
+	ldp	x23, x24, [x1, 3*16]
+	ldp	x25, x26, [x1, 4*16]
+	ldp	x27, x28, [x1, 5*16]
+	ldp	d8, d9,   [x1, 6*16]
+	ldp	d10, d11, [x1, 7*16]
+	ldp	d12, d13, [x1, 8*16]
+	ldp	d14, d15, [x1, 9*16]
+	ldr	x3, [x1, 10*16]
+	ldp	x29, x30, [x1]
+	cfi_def_cfa(x1, 0)
+	mov	sp, x3
+	br	x30
+	cfi_endproc
+	.size	GTM_longjmp, . - GTM_longjmp
+
+#ifdef __linux__
+.section .note.GNU-stack, "", %progbits
+#endif
Index: libitm/config/aarch64/target.h
===================================================================
--- a/src/libitm/config/aarch64/target.h	(.../tags/gcc_4_9_1_release)
+++ b/src/libitm/config/aarch64/target.h	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,45 @@
+/* Copyright (C) 2014 Free Software Foundation, Inc.
+   Contributed by Richard Henderson <rth@redhat.com>.
+
+   This file is part of the GNU Transactional Memory Library (libitm).
+
+   Libitm is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+namespace GTM HIDDEN {
+
+typedef struct gtm_jmpbuf
+{
+  unsigned long long fp;	/* x29 */
+  unsigned long long pc;	/* x30 */
+  unsigned long long gr[10];	/* x19-x28 */
+  unsigned long long vr[8];	/* d8-d15 */
+  void *cfa;
+} gtm_jmpbuf;
+
+/* ??? The size of one line in hardware caches (in bytes). */
+#define HW_CACHELINE_SIZE 128
+
+static inline void
+cpu_relax (void)
+{
+  __asm volatile ("" : : : "memory");
+}
+
+} // namespace GTM
Index: libgomp/libgomp.h
===================================================================
--- a/src/libgomp/libgomp.h	(.../tags/gcc_4_9_1_release)
+++ b/src/libgomp/libgomp.h	(.../branches/gcc-4_9-branch)
@@ -274,6 +274,7 @@
   struct gomp_task *task;
   bool is_in;
   bool redundant;
+  bool redundant_out;
 };
 
 struct gomp_dependers_vec
@@ -283,6 +284,17 @@
   struct gomp_task *elem[];
 };
 
+/* Used when in GOMP_taskwait or in gomp_task_maybe_wait_for_dependencies.  */
+
+struct gomp_taskwait
+{
+  bool in_taskwait;
+  bool in_depend_wait;
+  size_t n_depend;
+  struct gomp_task *last_parent_depends_on;
+  gomp_sem_t taskwait_sem;
+};
+
 /* This structure describes a "task" to be run by a thread.  */
 
 struct gomp_task
@@ -298,6 +310,7 @@
   struct gomp_taskgroup *taskgroup;
   struct gomp_dependers_vec *dependers;
   struct htab *depend_hash;
+  struct gomp_taskwait *taskwait;
   size_t depend_count;
   size_t num_dependees;
   struct gomp_task_icv icv;
@@ -304,11 +317,10 @@
   void (*fn) (void *);
   void *fn_data;
   enum gomp_task_kind kind;
-  bool in_taskwait;
   bool in_tied_task;
   bool final_task;
   bool copy_ctors_done;
-  gomp_sem_t taskwait_sem;
+  bool parent_depends_on;
   struct gomp_task_depend_entry depend[];
 };
 
@@ -582,7 +594,6 @@
 {
   if (__builtin_expect (task->depend_hash != NULL, 0))
     free (task->depend_hash);
-  gomp_sem_destroy (&task->taskwait_sem);
 }
 
 /* team.c */
Index: libgomp/task.c
===================================================================
--- a/src/libgomp/task.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgomp/task.c	(.../branches/gcc-4_9-branch)
@@ -66,16 +66,16 @@
   task->parent = parent_task;
   task->icv = *prev_icv;
   task->kind = GOMP_TASK_IMPLICIT;
-  task->in_taskwait = false;
+  task->taskwait = NULL;
   task->in_tied_task = false;
   task->final_task = false;
   task->copy_ctors_done = false;
+  task->parent_depends_on = false;
   task->children = NULL;
   task->taskgroup = NULL;
   task->dependers = NULL;
   task->depend_hash = NULL;
   task->depend_count = 0;
-  gomp_sem_init (&task->taskwait_sem, 0);
 }
 
 /* Clean up a task, after completing it.  */
@@ -104,6 +104,8 @@
     while (task != children);
 }
 
+static void gomp_task_maybe_wait_for_dependencies (void **depend);
+
 /* Called when encountering an explicit task directive.  If IF_CLAUSE is
    false, then we must not delay in executing the task.  If UNTIED is true,
    then the task may be executed by any member of the team.  */
@@ -141,35 +143,12 @@
 
       /* If there are depend clauses and earlier deferred sibling tasks
 	 with depend clauses, check if there isn't a dependency.  If there
-	 is, fall through to the deferred task handling, as we can't
-	 schedule such tasks right away.  There is no need to handle
+	 is, we need to wait for them.  There is no need to handle
 	 depend clauses for non-deferred tasks other than this, because
 	 the parent task is suspended until the child task finishes and thus
 	 it can't start further child tasks.  */
       if ((flags & 8) && thr->task && thr->task->depend_hash)
-	{
-	  struct gomp_task *parent = thr->task;
-	  struct gomp_task_depend_entry elem, *ent = NULL;
-	  size_t ndepend = (uintptr_t) depend[0];
-	  size_t nout = (uintptr_t) depend[1];
-	  size_t i;
-	  gomp_mutex_lock (&team->task_lock);
-	  for (i = 0; i < ndepend; i++)
-	    {
-	      elem.addr = depend[i + 2];
-	      ent = htab_find (parent->depend_hash, &elem);
-	      for (; ent; ent = ent->next)
-		if (i >= nout && ent->is_in)
-		  continue;
-		else
-		  break;
-	      if (ent)
-		break;
-	    }
-	  gomp_mutex_unlock (&team->task_lock);
-	  if (ent)
-	    goto defer;
-	}
+	gomp_task_maybe_wait_for_dependencies (depend);
 
       gomp_init_task (&task, thr->task, gomp_icv (false));
       task.kind = GOMP_TASK_IFFALSE;
@@ -209,7 +188,6 @@
     }
   else
     {
-     defer:;
       struct gomp_task *task;
       struct gomp_task *parent = thr->task;
       struct gomp_taskgroup *taskgroup = parent->taskgroup;
@@ -275,11 +253,12 @@
 	      task->depend[i].task = task;
 	      task->depend[i].is_in = i >= nout;
 	      task->depend[i].redundant = false;
+	      task->depend[i].redundant_out = false;
 
 	      hash_entry_type *slot
 		= htab_find_slot (&parent->depend_hash, &task->depend[i],
 				  INSERT);
-	      hash_entry_type out = NULL;
+	      hash_entry_type out = NULL, last = NULL;
 	      if (*slot)
 		{
 		  /* If multiple depends on the same task are the
@@ -294,6 +273,11 @@
 		    }
 		  for (ent = *slot; ent; ent = ent->next)
 		    {
+		      if (ent->redundant_out)
+			break;
+
+		      last = ent;
+
 		      /* depend(in:...) doesn't depend on earlier
 			 depend(in:...).  */
 		      if (i >= nout && ent->is_in)
@@ -341,7 +325,8 @@
 	      *slot = &task->depend[i];
 
 	      /* There is no need to store more than one depend({,in}out:)
-		 task per address in the hash table chain, because each out
+		 task per address in the hash table chain for the purpose
+		 of creation of deferred tasks, because each out
 		 depends on all earlier outs, thus it is enough to record
 		 just the last depend({,in}out:).  For depend(in:), we need
 		 to keep all of the previous ones not terminated yet, because
@@ -348,14 +333,23 @@
 		 a later depend({,in}out:) might need to depend on all of
 		 them.  So, if the new task's clause is depend({,in}out:),
 		 we know there is at most one other depend({,in}out:) clause
-		 in the list (out) and to maintain the invariant we now
-		 need to remove it from the list.  */
+		 in the list (out).  For non-deferred tasks we want to see
+		 all outs, so they are moved to the end of the chain,
+		 after first redundant_out entry all following entries
+		 should be redundant_out.  */
 	      if (!task->depend[i].is_in && out)
 		{
-		  if (out->next)
-		    out->next->prev = out->prev;
-		  out->prev->next = out->next;
-		  out->redundant = true;
+		  if (out != last)
+		    {
+		      out->next->prev = out->prev;
+		      out->prev->next = out->next;
+		      out->next = last->next;
+		      out->prev = last;
+		      last->next = out;
+		      if (out->next)
+			out->next->prev = out;
+		    }
+		  out->redundant_out = true;
 		}
 	    }
 	  if (task->num_dependees)
@@ -421,8 +415,20 @@
 gomp_task_run_pre (struct gomp_task *child_task, struct gomp_task *parent,
 		   struct gomp_taskgroup *taskgroup, struct gomp_team *team)
 {
-  if (parent && parent->children == child_task)
-    parent->children = child_task->next_child;
+  if (parent)
+    {
+      if (parent->children == child_task)
+	parent->children = child_task->next_child;
+      if (__builtin_expect (child_task->parent_depends_on, 0)
+	  && parent->taskwait->last_parent_depends_on == child_task)
+	{
+	  if (child_task->prev_child->kind == GOMP_TASK_WAITING
+	      && child_task->prev_child->parent_depends_on)
+	    parent->taskwait->last_parent_depends_on = child_task->prev_child;
+	  else
+	    parent->taskwait->last_parent_depends_on = NULL;
+	}
+    }
   if (taskgroup && taskgroup->children == child_task)
     taskgroup->children = child_task->next_taskgroup;
   child_task->prev_queue->next_queue = child_task->next_queue;
@@ -489,8 +495,23 @@
 	{
 	  if (parent->children)
 	    {
-	      task->next_child = parent->children;
-	      task->prev_child = parent->children->prev_child;
+	      /* If parent is in gomp_task_maybe_wait_for_dependencies
+		 and it doesn't need to wait for this task, put it after
+		 all ready to run tasks it needs to wait for.  */
+	      if (parent->taskwait && parent->taskwait->last_parent_depends_on
+		  && !task->parent_depends_on)
+		{
+		  struct gomp_task *last_parent_depends_on
+		    = parent->taskwait->last_parent_depends_on;
+		  task->next_child = last_parent_depends_on->next_child;
+		  task->prev_child = last_parent_depends_on;
+		}
+	      else
+		{
+		  task->next_child = parent->children;
+		  task->prev_child = parent->children->prev_child;
+		  parent->children = task;
+		}
 	      task->next_child->prev_child = task;
 	      task->prev_child->next_child = task;
 	    }
@@ -498,12 +519,23 @@
 	    {
 	      task->next_child = task;
 	      task->prev_child = task;
+	      parent->children = task;
 	    }
-	  parent->children = task;
-	  if (parent->in_taskwait)
+	  if (parent->taskwait)
 	    {
-	      parent->in_taskwait = false;
-	      gomp_sem_post (&parent->taskwait_sem);
+	      if (parent->taskwait->in_taskwait)
+		{
+		  parent->taskwait->in_taskwait = false;
+		  gomp_sem_post (&parent->taskwait->taskwait_sem);
+		}
+	      else if (parent->taskwait->in_depend_wait)
+		{
+		  parent->taskwait->in_depend_wait = false;
+		  gomp_sem_post (&parent->taskwait->taskwait_sem);
+		}
+	      if (parent->taskwait->last_parent_depends_on == NULL
+		  && task->parent_depends_on)
+		parent->taskwait->last_parent_depends_on = task;
 	    }
 	}
       if (taskgroup)
@@ -575,6 +607,13 @@
   struct gomp_task *parent = child_task->parent;
   if (parent == NULL)
     return;
+  if (__builtin_expect (child_task->parent_depends_on, 0)
+      && --parent->taskwait->n_depend == 0
+      && parent->taskwait->in_depend_wait)
+    {
+      parent->taskwait->in_depend_wait = false;
+      gomp_sem_post (&parent->taskwait->taskwait_sem);
+    }
   child_task->prev_child->next_child = child_task->next_child;
   child_task->next_child->prev_child = child_task->prev_child;
   if (parent->children != child_task)
@@ -589,10 +628,10 @@
 	 written by child_task->fn above is flushed
 	 before the NULL is written.  */
       __atomic_store_n (&parent->children, NULL, MEMMODEL_RELEASE);
-      if (parent->in_taskwait)
+      if (parent->taskwait && parent->taskwait->in_taskwait)
 	{
-	  parent->in_taskwait = false;
-	  gomp_sem_post (&parent->taskwait_sem);
+	  parent->taskwait->in_taskwait = false;
+	  gomp_sem_post (&parent->taskwait->taskwait_sem);
 	}
     }
 }
@@ -736,6 +775,7 @@
   struct gomp_task *task = thr->task;
   struct gomp_task *child_task = NULL;
   struct gomp_task *to_free = NULL;
+  struct gomp_taskwait taskwait;
   int do_wake = 0;
 
   /* The acquire barrier on load of task->children here synchronizes
@@ -748,6 +788,7 @@
       || __atomic_load_n (&task->children, MEMMODEL_ACQUIRE) == NULL)
     return;
 
+  memset (&taskwait, 0, sizeof (taskwait));
   gomp_mutex_lock (&team->task_lock);
   while (1)
     {
@@ -754,6 +795,8 @@
       bool cancelled = false;
       if (task->children == NULL)
 	{
+	  bool destroy_taskwait = task->taskwait != NULL;
+	  task->taskwait = NULL;
 	  gomp_mutex_unlock (&team->task_lock);
 	  if (to_free)
 	    {
@@ -760,6 +803,8 @@
 	      gomp_finish_task (to_free);
 	      free (to_free);
 	    }
+	  if (destroy_taskwait)
+	    gomp_sem_destroy (&taskwait.taskwait_sem);
 	  return;
 	}
       if (task->children->kind == GOMP_TASK_WAITING)
@@ -780,9 +825,180 @@
 	    }
 	}
       else
+	{
+	  /* All tasks we are waiting for are already running
+	     in other threads.  Wait for them.  */
+	  if (task->taskwait == NULL)
+	    {
+	      taskwait.in_depend_wait = false;
+	      gomp_sem_init (&taskwait.taskwait_sem, 0);
+	      task->taskwait = &taskwait;
+	    }
+	  taskwait.in_taskwait = true;
+	}
+      gomp_mutex_unlock (&team->task_lock);
+      if (do_wake)
+	{
+	  gomp_team_barrier_wake (&team->barrier, do_wake);
+	  do_wake = 0;
+	}
+      if (to_free)
+	{
+	  gomp_finish_task (to_free);
+	  free (to_free);
+	  to_free = NULL;
+	}
+      if (child_task)
+	{
+	  thr->task = child_task;
+	  child_task->fn (child_task->fn_data);
+	  thr->task = task;
+	}
+      else
+	gomp_sem_wait (&taskwait.taskwait_sem);
+      gomp_mutex_lock (&team->task_lock);
+      if (child_task)
+	{
+	 finish_cancelled:;
+	  size_t new_tasks
+	    = gomp_task_run_post_handle_depend (child_task, team);
+	  child_task->prev_child->next_child = child_task->next_child;
+	  child_task->next_child->prev_child = child_task->prev_child;
+	  if (task->children == child_task)
+	    {
+	      if (child_task->next_child != child_task)
+		task->children = child_task->next_child;
+	      else
+		task->children = NULL;
+	    }
+	  gomp_clear_parent (child_task->children);
+	  gomp_task_run_post_remove_taskgroup (child_task);
+	  to_free = child_task;
+	  child_task = NULL;
+	  team->task_count--;
+	  if (new_tasks > 1)
+	    {
+	      do_wake = team->nthreads - team->task_running_count
+			- !task->in_tied_task;
+	      if (do_wake > new_tasks)
+		do_wake = new_tasks;
+	    }
+	}
+    }
+}
+
+/* This is like GOMP_taskwait, but we only wait for tasks that the
+   upcoming task depends on.  */
+
+static void
+gomp_task_maybe_wait_for_dependencies (void **depend)
+{
+  struct gomp_thread *thr = gomp_thread ();
+  struct gomp_task *task = thr->task;
+  struct gomp_team *team = thr->ts.team;
+  struct gomp_task_depend_entry elem, *ent = NULL;
+  struct gomp_taskwait taskwait;
+  struct gomp_task *last_parent_depends_on = NULL;
+  size_t ndepend = (uintptr_t) depend[0];
+  size_t nout = (uintptr_t) depend[1];
+  size_t i;
+  size_t num_awaited = 0;
+  struct gomp_task *child_task = NULL;
+  struct gomp_task *to_free = NULL;
+  int do_wake = 0;
+
+  gomp_mutex_lock (&team->task_lock);
+  for (i = 0; i < ndepend; i++)
+    {
+      elem.addr = depend[i + 2];
+      ent = htab_find (task->depend_hash, &elem);
+      for (; ent; ent = ent->next)
+	if (i >= nout && ent->is_in)
+	  continue;
+	else
+	  {
+	    struct gomp_task *tsk = ent->task;
+	    if (!tsk->parent_depends_on)
+	      {
+		tsk->parent_depends_on = true;
+		++num_awaited;
+		if (tsk->num_dependees == 0 && tsk->kind == GOMP_TASK_WAITING)
+		  {
+		    /* If a task we need to wait for is not already
+		       running and is ready to be scheduled, move it
+		       to front, so that we run it as soon as possible.  */
+		    if (last_parent_depends_on)
+		      {
+			tsk->prev_child->next_child = tsk->next_child;
+			tsk->next_child->prev_child = tsk->prev_child;
+			tsk->prev_child = last_parent_depends_on;
+			tsk->next_child = last_parent_depends_on->next_child;
+			tsk->prev_child->next_child = tsk;
+			tsk->next_child->prev_child = tsk;
+		      }
+		    else if (tsk != task->children)
+		      {
+			tsk->prev_child->next_child = tsk->next_child;
+			tsk->next_child->prev_child = tsk->prev_child;
+			tsk->prev_child = task->children;
+			tsk->next_child = task->children->next_child;
+			task->children = tsk;
+			tsk->prev_child->next_child = tsk;
+			tsk->next_child->prev_child = tsk;
+		      }
+		    last_parent_depends_on = tsk;
+		  }
+	      }
+	  }
+    }
+  if (num_awaited == 0)
+    {
+      gomp_mutex_unlock (&team->task_lock);
+      return;
+    }
+
+  memset (&taskwait, 0, sizeof (taskwait));
+  taskwait.n_depend = num_awaited;
+  taskwait.last_parent_depends_on = last_parent_depends_on;
+  gomp_sem_init (&taskwait.taskwait_sem, 0);
+  task->taskwait = &taskwait;
+
+  while (1)
+    {
+      bool cancelled = false;
+      if (taskwait.n_depend == 0)
+	{
+	  task->taskwait = NULL;
+	  gomp_mutex_unlock (&team->task_lock);
+	  if (to_free)
+	    {
+	      gomp_finish_task (to_free);
+	      free (to_free);
+	    }
+	  gomp_sem_destroy (&taskwait.taskwait_sem);
+	  return;
+	}
+      if (task->children->kind == GOMP_TASK_WAITING)
+	{
+	  child_task = task->children;
+	  cancelled
+	    = gomp_task_run_pre (child_task, task, child_task->taskgroup,
+				 team);
+	  if (__builtin_expect (cancelled, 0))
+	    {
+	      if (to_free)
+		{
+		  gomp_finish_task (to_free);
+		  free (to_free);
+		  to_free = NULL;
+		}
+	      goto finish_cancelled;
+	    }
+	}
+      else
 	/* All tasks we are waiting for are already running
 	   in other threads.  Wait for them.  */
-	task->in_taskwait = true;
+	taskwait.in_depend_wait = true;
       gomp_mutex_unlock (&team->task_lock);
       if (do_wake)
 	{
@@ -802,7 +1018,7 @@
 	  thr->task = task;
 	}
       else
-	gomp_sem_wait (&task->taskwait_sem);
+	gomp_sem_wait (&taskwait.taskwait_sem);
       gomp_mutex_lock (&team->task_lock);
       if (child_task)
 	{
@@ -809,6 +1025,8 @@
 	 finish_cancelled:;
 	  size_t new_tasks
 	    = gomp_task_run_post_handle_depend (child_task, team);
+	  if (child_task->parent_depends_on)
+	    --taskwait.n_depend;
 	  child_task->prev_child->next_child = child_task->next_child;
 	  child_task->next_child->prev_child = child_task->prev_child;
 	  if (task->children == child_task)
@@ -897,18 +1115,26 @@
       if (taskgroup->children == NULL)
 	{
 	  if (taskgroup->num_children)
-	    goto do_wait;
-	  gomp_mutex_unlock (&team->task_lock);
-	  if (to_free)
 	    {
-	      gomp_finish_task (to_free);
-	      free (to_free);
+	      if (task->children == NULL)
+		goto do_wait;
+	      child_task = task->children;
+            }
+          else
+	    {
+	      gomp_mutex_unlock (&team->task_lock);
+	      if (to_free)
+		{
+		  gomp_finish_task (to_free);
+		  free (to_free);
+		}
+	      goto finish;
 	    }
-	  goto finish;
 	}
-      if (taskgroup->children->kind == GOMP_TASK_WAITING)
+      else
+	child_task = taskgroup->children;
+      if (child_task->kind == GOMP_TASK_WAITING)
 	{
-	  child_task = taskgroup->children;
 	  cancelled
 	    = gomp_task_run_pre (child_task, child_task->parent, taskgroup,
 				 team);
@@ -925,6 +1151,7 @@
 	}
       else
 	{
+	  child_task = NULL;
 	 do_wait:
 	  /* All tasks we are waiting for are already running
 	     in other threads.  Wait for them.  */
@@ -956,20 +1183,9 @@
 	 finish_cancelled:;
 	  size_t new_tasks
 	    = gomp_task_run_post_handle_depend (child_task, team);
-	  child_task->prev_taskgroup->next_taskgroup
-	    = child_task->next_taskgroup;
-	  child_task->next_taskgroup->prev_taskgroup
-	    = child_task->prev_taskgroup;
-	  --taskgroup->num_children;
-	  if (taskgroup->children == child_task)
-	    {
-	      if (child_task->next_taskgroup != child_task)
-		taskgroup->children = child_task->next_taskgroup;
-	      else
-		taskgroup->children = NULL;
-	    }
 	  gomp_task_run_post_remove_parent (child_task);
 	  gomp_clear_parent (child_task->children);
+	  gomp_task_run_post_remove_taskgroup (child_task);
 	  to_free = child_task;
 	  child_task = NULL;
 	  team->task_count--;
Index: libgomp/ChangeLog
===================================================================
--- a/src/libgomp/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/libgomp/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,44 @@
+2014-08-04  Jakub Jelinek  <jakub@redhat.com>
+
+	* task.c (GOMP_taskgroup_end): If taskgroup->num_children
+	is not zero, but taskgroup->children is NULL and there are
+	any task->children, schedule those instead of waiting.
+	* testsuite/libgomp.c/depend-6.c: New test.
+	* testsuite/libgomp.c/depend-7.c: New test.
+	* testsuite/libgomp.c/depend-8.c: New test.
+	* testsuite/libgomp.c/depend-9.c: New test.
+	* testsuite/libgomp.c/depend-10.c: New test.
+
+2014-08-01  Jakub Jelinek  <jakub@redhat.com>
+
+	* libgomp.h (struct gomp_task_depend_entry): Add redundant_out field.
+	(struct gomp_taskwait): New type.
+	(struct gomp_task): Add taskwait and parent_depends_on, remove
+	in_taskwait and taskwait_sem fields.
+	(gomp_finish_task): Don't destroy taskwait_sem.
+	* task.c (gomp_init_task): Don't init in_taskwait, instead init
+	taskwait and parent_depends_on.
+	(GOMP_task): For if (0) tasks with depend clause that depend on
+	earlier tasks don't defer them, instead call
+	gomp_task_maybe_wait_for_dependencies to wait for the dependencies.
+	Initialize redundant_out field, for redundant out entries just
+	move them at the end of linked list instead of removing them
+	completely, and set redundant_out flag instead of redundant.
+	(gomp_task_run_pre): Update last_parent_depends_on if scheduling
+	that task.
+	(gomp_task_run_post_handle_dependers): If parent is in
+	gomp_task_maybe_wait_for_dependencies and newly runnable task
+	is not parent_depends_on, queue it in parent->children linked
+	list after all runnable tasks with parent_depends_on set.
+	Adjust for addition of taskwait indirection.
+	(gomp_task_run_post_remove_parent): If parent is in
+	gomp_task_maybe_wait_for_dependencies and task to be removed
+	is parent_depends_on, decrement n_depend and if needed awake
+	parent.  Adjust for addition of taskwait indirection.
+	(GOMP_taskwait): Adjust for addition of taskwait indirection.
+	(gomp_task_maybe_wait_for_dependencies): New function.
+	* testsuite/libgomp.c/depend-5.c: New test.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: libgomp/testsuite/libgomp.c/depend-8.c
===================================================================
--- a/src/libgomp/testsuite/libgomp.c/depend-8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgomp/testsuite/libgomp.c/depend-8.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,3 @@
+/* { dg-set-target-env-var OMP_NUM_THREADS "1" } */
+
+#include "depend-3.c"
Index: libgomp/testsuite/libgomp.c/depend-10.c
===================================================================
--- a/src/libgomp/testsuite/libgomp.c/depend-10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgomp/testsuite/libgomp.c/depend-10.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,3 @@
+/* { dg-set-target-env-var OMP_NUM_THREADS "1" } */
+
+#include "depend-5.c"
Index: libgomp/testsuite/libgomp.c/depend-5.c
===================================================================
--- a/src/libgomp/testsuite/libgomp.c/depend-5.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgomp/testsuite/libgomp.c/depend-5.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,98 @@
+#include <stdlib.h>
+
+__attribute__((noinline, noclone)) void
+f1 (int ifval)
+{
+  int x = 1, y = 2, z = 3;
+  #pragma omp parallel
+  #pragma omp single
+  {
+    #pragma omp task shared (x) depend(out: x)
+    x = 2;
+    #pragma omp task shared (x) depend(inout: x)
+    {
+      if (x != 2)
+	abort ();
+      x = 3;
+    }
+    #pragma omp task shared (x) depend(inout: x)
+    {
+      if (x != 3)
+	abort ();
+      x = 4;
+    }
+    #pragma omp task shared (z) depend(in: z)
+    if (z != 3)
+      abort ();
+    #pragma omp task shared (z) depend(in: z)
+    if (z != 3)
+      abort ();
+    #pragma omp task shared (z) depend(in: z)
+    if (z != 3)
+      abort ();
+    #pragma omp task shared (z) depend(in: z)
+    if (z != 3)
+      abort ();
+    #pragma omp task shared (z) depend(in: z)
+    if (z != 3)
+      abort ();
+    #pragma omp task shared (z) depend(in: z)
+    if (z != 3)
+      abort ();
+    #pragma omp task shared (y) depend(in: y)
+    if (y != 2)
+      abort ();
+    #pragma omp task shared (y) depend(in: y)
+    if (y != 2)
+      abort ();
+    #pragma omp task shared (y) depend(in: y)
+    if (y != 2)
+      abort ();
+    #pragma omp task shared (y) depend(in: y)
+    if (y != 2)
+      abort ();
+    #pragma omp task if (ifval) shared (x, y) depend(in: x) depend(inout: y)
+    {
+      if (x != 4 || y != 2)
+	abort ();
+      y = 3;
+    }
+    if (ifval == 0)
+      {
+	/* The above if (0) task should have waited till all
+	   the tasks with x and y dependencies finish.  */
+	if (x != 4 || y != 3)
+	  abort ();
+	x = 5;
+	y = 4;
+      }
+    #pragma omp task shared (z) depend(inout: z)
+    {
+      if (z != 3)
+	abort ();
+      z = 4;
+    }
+    #pragma omp task shared (z) depend(inout: z)
+    {
+      if (z != 4)
+	abort ();
+      z = 5;
+    }
+    #pragma omp taskwait
+    if (x != (ifval ? 4 : 5) || y != (ifval ? 3 : 4) || z != 5)
+      abort ();
+    #pragma omp task if (ifval) shared (x, y) depend(in: x) depend(inout: y)
+    {
+      if (x != (ifval ? 4 : 5) || y != (ifval ? 3 : 4))
+	abort ();
+    }
+  }
+}
+
+int
+main ()
+{
+  f1 (0);
+  f1 (1);
+  return 0;
+}
Index: libgomp/testsuite/libgomp.c/depend-9.c
===================================================================
--- a/src/libgomp/testsuite/libgomp.c/depend-9.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgomp/testsuite/libgomp.c/depend-9.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,3 @@
+/* { dg-set-target-env-var OMP_NUM_THREADS "1" } */
+
+#include "depend-4.c"
Index: libgomp/testsuite/libgomp.c/depend-6.c
===================================================================
--- a/src/libgomp/testsuite/libgomp.c/depend-6.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgomp/testsuite/libgomp.c/depend-6.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,3 @@
+/* { dg-set-target-env-var OMP_NUM_THREADS "1" } */
+
+#include "depend-1.c"
Index: libgomp/testsuite/libgomp.c/depend-7.c
===================================================================
--- a/src/libgomp/testsuite/libgomp.c/depend-7.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgomp/testsuite/libgomp.c/depend-7.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,3 @@
+/* { dg-set-target-env-var OMP_NUM_THREADS "1" } */
+
+#include "depend-2.c"
Index: libstdc++-v3/python/libstdcxx/v6/printers.py
===================================================================
--- a/src/libstdc++-v3/python/libstdcxx/v6/printers.py	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/python/libstdcxx/v6/printers.py	(.../branches/gcc-4_9-branch)
@@ -1,4 +1,4 @@
-# Pretty-printers for libstc++.
+# Pretty-printers for libstdc++.
 
 # Copyright (C) 2008-2014 Free Software Foundation, Inc.
 
@@ -18,7 +18,51 @@
 import gdb
 import itertools
 import re
+import sys
 
+### Python 2 + Python 3 compatibility code
+
+# Resources about compatibility:
+#
+#  * <http://pythonhosted.org/six/>: Documentation of the "six" module
+
+# FIXME: The handling of e.g. std::basic_string (at least on char)
+# probably needs updating to work with Python 3's new string rules.
+#
+# In particular, Python 3 has a separate type (called byte) for
+# bytestrings, and a special b"" syntax for the byte literals; the old
+# str() type has been redefined to always store Unicode text.
+#
+# We probably can't do much about this until this GDB PR is addressed:
+# <https://sourceware.org/bugzilla/show_bug.cgi?id=17138>
+
+if sys.version_info[0] > 2:
+    ### Python 3 stuff
+    Iterator = object
+    # Python 3 folds these into the normal functions.
+    imap = map
+    izip = zip
+    # Also, int subsumes long
+    long = int
+else:
+    ### Python 2 stuff
+    class Iterator:
+        """Compatibility mixin for iterators
+
+        Instead of writing next() methods for iterators, write
+        __next__() methods and use this mixin to make them work in
+        Python 2 as well as Python 3.
+
+        Idea stolen from the "six" documentation:
+        <http://pythonhosted.org/six/#six.Iterator>
+        """
+
+        def next(self):
+            return self.__next__()
+
+    # In Python 2, we still need these from itertools
+    from itertools import imap, izip
+
 # Try to use the new-style pretty-printing if available.
 _use_gdb_pp = True
 try:
@@ -51,7 +95,7 @@
         # anything fancier here.
         field = typ.fields()[0]
         if not field.is_base_class:
-            raise ValueError, "Cannot find type %s::%s" % (str(orig), name)
+            raise ValueError("Cannot find type %s::%s" % (str(orig), name))
         typ = field.type
 
 class SharedPointerPrinter:
@@ -87,7 +131,7 @@
 class StdListPrinter:
     "Print a std::list"
 
-    class _iterator:
+    class _iterator(Iterator):
         def __init__(self, nodetype, head):
             self.nodetype = nodetype
             self.base = head['_M_next']
@@ -97,7 +141,7 @@
         def __iter__(self):
             return self
 
-        def next(self):
+        def __next__(self):
             if self.base == self.head:
                 raise StopIteration
             elt = self.base.cast(self.nodetype).dereference()
@@ -135,7 +179,7 @@
 class StdSlistPrinter:
     "Print a __gnu_cxx::slist"
 
-    class _iterator:
+    class _iterator(Iterator):
         def __init__(self, nodetype, head):
             self.nodetype = nodetype
             self.base = head['_M_head']['_M_next']
@@ -144,7 +188,7 @@
         def __iter__(self):
             return self
 
-        def next(self):
+        def __next__(self):
             if self.base == 0:
                 raise StopIteration
             elt = self.base.cast(self.nodetype).dereference()
@@ -180,7 +224,7 @@
 class StdVectorPrinter:
     "Print a std::vector"
 
-    class _iterator:
+    class _iterator(Iterator):
         def __init__ (self, start, finish, bitvec):
             self.bitvec = bitvec
             if bitvec:
@@ -198,7 +242,7 @@
         def __iter__(self):
             return self
 
-        def next(self):
+        def __next__(self):
             count = self.count
             self.count = self.count + 1
             if self.bitvec:
@@ -265,7 +309,7 @@
 class StdTuplePrinter:
     "Print a std::tuple"
 
-    class _iterator:
+    class _iterator(Iterator):
         def __init__ (self, head):
             self.head = head
 
@@ -276,13 +320,13 @@
                 # Set the actual head to the first pair.
                 self.head  = self.head.cast (nodes[0].type)
             elif len (nodes) != 0:
-                raise ValueError, "Top of tuple tree does not consist of a single node."
+                raise ValueError("Top of tuple tree does not consist of a single node.")
             self.count = 0
 
         def __iter__ (self):
             return self
 
-        def next (self):
+        def __next__ (self):
             nodes = self.head.type.fields ()
             # Check for further recursions in the inheritance tree.
             if len (nodes) == 0:
@@ -289,7 +333,7 @@
                 raise StopIteration
             # Check that this iteration has an expected structure.
             if len (nodes) != 2:
-                raise ValueError, "Cannot parse more than 2 nodes in a tuple tree."
+                raise ValueError("Cannot parse more than 2 nodes in a tuple tree.")
 
             # - Left node is the next recursion parent.
             # - Right node is the actual class contained in the tuple.
@@ -341,7 +385,7 @@
             return self.visualizer.display_hint ()
         return None
 
-class RbtreeIterator:
+class RbtreeIterator(Iterator):
     def __init__(self, rbtree):
         self.size = rbtree['_M_t']['_M_impl']['_M_node_count']
         self.node = rbtree['_M_t']['_M_impl']['_M_header']['_M_left']
@@ -353,7 +397,7 @@
     def __len__(self):
         return int (self.size)
 
-    def next(self):
+    def __next__(self):
         if self.count == self.size:
             raise StopIteration
         result = self.node
@@ -389,7 +433,7 @@
             return p.dereference()
     except:
         pass
-    raise ValueError, "Unsupported implementation for %s" % str(node.type)
+    raise ValueError("Unsupported implementation for %s" % str(node.type))
 
 # This is a pretty printer for std::_Rb_tree_iterator (which is
 # std::map::iterator), and has nothing to do with the RbtreeIterator
@@ -422,7 +466,7 @@
     "Print a std::map or std::multimap"
 
     # Turn an RbtreeIterator into a pretty-print iterator.
-    class _iter:
+    class _iter(Iterator):
         def __init__(self, rbiter, type):
             self.rbiter = rbiter
             self.count = 0
@@ -431,9 +475,9 @@
         def __iter__(self):
             return self
 
-        def next(self):
+        def __next__(self):
             if self.count % 2 == 0:
-                n = self.rbiter.next()
+                n = next(self.rbiter)
                 n = n.cast(self.type).dereference()
                 n = get_value_from_Rb_tree_node(n)
                 self.pair = n
@@ -465,7 +509,7 @@
     "Print a std::set or std::multiset"
 
     # Turn an RbtreeIterator into a pretty-print iterator.
-    class _iter:
+    class _iter(Iterator):
         def __init__(self, rbiter, type):
             self.rbiter = rbiter
             self.count = 0
@@ -474,8 +518,8 @@
         def __iter__(self):
             return self
 
-        def next(self):
-            item = self.rbiter.next()
+        def __next__(self):
+            item = next(self.rbiter)
             item = item.cast(self.type).dereference()
             item = get_value_from_Rb_tree_node(item)
             # FIXME: this is weird ... what to do?
@@ -541,7 +585,7 @@
 class StdDequePrinter:
     "Print a std::deque"
 
-    class _iter:
+    class _iter(Iterator):
         def __init__(self, node, start, end, last, buffer_size):
             self.node = node
             self.p = start
@@ -553,7 +597,7 @@
         def __iter__(self):
             return self
 
-        def next(self):
+        def __next__(self):
             if self.p == self.last:
                 raise StopIteration
 
@@ -638,7 +682,7 @@
     def display_hint (self):
         return 'string'
 
-class Tr1HashtableIterator:
+class Tr1HashtableIterator(Iterator):
     def __init__ (self, hash):
         self.buckets = hash['_M_buckets']
         self.bucket = 0
@@ -654,7 +698,7 @@
     def __iter__ (self):
         return self
 
-    def next (self):
+    def __next__ (self):
         if self.node == 0:
             raise StopIteration
         node = self.node.cast(self.node_type)
@@ -669,7 +713,7 @@
                 self.bucket = self.bucket + 1
         return result
 
-class StdHashtableIterator:
+class StdHashtableIterator(Iterator):
     def __init__(self, hash):
         self.node = hash['_M_before_begin']['_M_nxt']
         self.node_type = find_type(hash.type, '__node_type').pointer()
@@ -677,7 +721,7 @@
     def __iter__(self):
         return self
 
-    def next(self):
+    def __next__(self):
         if self.node == 0:
             raise StopIteration
         elt = self.node.cast(self.node_type).dereference()
@@ -706,10 +750,10 @@
         return '[%d]' % i
 
     def children (self):
-        counter = itertools.imap (self.format_count, itertools.count())
+        counter = imap (self.format_count, itertools.count())
         if self.typename.startswith('std::tr1'):
-            return itertools.izip (counter, Tr1HashtableIterator (self.hashtable()))
-        return itertools.izip (counter, StdHashtableIterator (self.hashtable()))
+            return izip (counter, Tr1HashtableIterator (self.hashtable()))
+        return izip (counter, StdHashtableIterator (self.hashtable()))
 
 class Tr1UnorderedMapPrinter:
     "Print a tr1::unordered_map"
@@ -741,15 +785,15 @@
         return '[%d]' % i
 
     def children (self):
-        counter = itertools.imap (self.format_count, itertools.count())
+        counter = imap (self.format_count, itertools.count())
         # Map over the hash table and flatten the result.
         if self.typename.startswith('std::tr1'):
-            data = self.flatten (itertools.imap (self.format_one, Tr1HashtableIterator (self.hashtable())))
+            data = self.flatten (imap (self.format_one, Tr1HashtableIterator (self.hashtable())))
             # Zip the two iterators together.
-            return itertools.izip (counter, data)
-        data = self.flatten (itertools.imap (self.format_one, StdHashtableIterator (self.hashtable())))
+            return izip (counter, data)
+        data = self.flatten (imap (self.format_one, StdHashtableIterator (self.hashtable())))
         # Zip the two iterators together.
-        return itertools.izip (counter, data)
+        return izip (counter, data)
         
 
     def display_hint (self):
@@ -758,7 +802,7 @@
 class StdForwardListPrinter:
     "Print a std::forward_list"
 
-    class _iterator:
+    class _iterator(Iterator):
         def __init__(self, nodetype, head):
             self.nodetype = nodetype
             self.base = head['_M_next']
@@ -767,7 +811,7 @@
         def __iter__(self):
             return self
 
-        def next(self):
+        def __next__(self):
             if self.base == 0:
                 raise StopIteration
             elt = self.base.cast(self.nodetype).dereference()
@@ -827,7 +871,7 @@
         # A small sanity check.
         # FIXME
         if not self.compiled_rx.match(name + '<>'):
-            raise ValueError, 'libstdc++ programming error: "%s" does not match' % name
+            raise ValueError('libstdc++ programming error: "%s" does not match' % name)
         printer = RxPrinter(name, function)
         self.subprinters.append(printer)
         self.lookup[name] = printer
Index: libstdc++-v3/include/std/future
===================================================================
--- a/src/libstdc++-v3/include/std/future	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/std/future	(.../branches/gcc-4_9-branch)
@@ -1240,6 +1240,10 @@
 	  {
 	    _M_result->_M_set(_M_fn());
 	  }
+	__catch(const __cxxabiv1::__forced_unwind&)
+	  {
+	    __throw_exception_again; // will cause broken_promise
+	  }
 	__catch(...)
 	  {
 	    _M_result->_M_error = current_exception();
@@ -1259,6 +1263,10 @@
 	  {
 	    _M_fn();
 	  }
+	__catch(const __cxxabiv1::__forced_unwind&)
+	  {
+	    __throw_exception_again; // will cause broken_promise
+	  }
 	__catch(...)
 	  {
 	    _M_result->_M_error = current_exception();
@@ -1519,7 +1527,17 @@
       : _M_result(new _Result<_Res>()), _M_fn(std::move(__fn))
       {
 	_M_thread = std::thread{ [this] {
-	  _M_set_result(_S_task_setter(_M_result, _M_fn));
+	    __try
+	      {
+		_M_set_result(_S_task_setter(_M_result, _M_fn));
+	      }
+	    __catch (const __cxxabiv1::__forced_unwind&)
+	      {
+		// make the shared state ready on thread cancellation
+		if (static_cast<bool>(_M_result))
+		  this->_M_break_promise(std::move(_M_result));
+		__throw_exception_again;
+	      }
         } };
       }
 
Index: libstdc++-v3/include/std/condition_variable
===================================================================
--- a/src/libstdc++-v3/include/std/condition_variable	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/std/condition_variable	(.../branches/gcc-4_9-branch)
@@ -189,7 +189,14 @@
 	~_Unlock() noexcept(false)
 	{
 	  if (uncaught_exception())
-	    __try { _M_lock.lock(); } __catch(...) { }
+	    {
+	      __try
+	      { _M_lock.lock(); }
+	      __catch(const __cxxabiv1::__forced_unwind&)
+	      { __throw_exception_again; }
+	      __catch(...)
+	      { }
+	    }
 	  else
 	    _M_lock.lock();
 	}
Index: libstdc++-v3/include/std/mutex
===================================================================
--- a/src/libstdc++-v3/include/std/mutex	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/std/mutex	(.../branches/gcc-4_9-branch)
@@ -44,6 +44,7 @@
 #include <bits/functexcept.h>
 #include <bits/gthr.h>
 #include <bits/move.h> // for std::swap
+#include <bits/cxxabi_forced.h>
 
 #ifdef _GLIBCXX_USE_C99_STDINT_TR1
 
@@ -649,6 +650,8 @@
       auto __locks = std::tie(__l1, __l2, __l3...);
       __try
       { __try_lock_impl<0>::__do_try_lock(__locks, __idx); }
+      __catch(const __cxxabiv1::__forced_unwind&)
+      { __throw_exception_again; }
       __catch(...)
       { }
       return __idx;
Index: libstdc++-v3/include/experimental/string_view
===================================================================
--- a/src/libstdc++-v3/include/experimental/string_view	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/experimental/string_view	(.../branches/gcc-4_9-branch)
@@ -39,7 +39,6 @@
 # include <bits/c++14_warning.h>
 #else
 
-#include <debug/debug.h>
 #include <string>
 #include <limits>
 
@@ -66,18 +65,10 @@
    *    _CharT*    _M_str
    *    size_t     _M_len
    *  @endcode
-   *
-   *  A basic_string_view represents an empty string with a static constexpr
-   *  length one string:
-   *
-   *  @code
-   *    static constexpr value_type _S_empty_str[1]{0};
-   *  @endcode
    */
-  template<typename _CharT, typename _Traits = char_traits<_CharT>>
+  template<typename _CharT, typename _Traits = std::char_traits<_CharT>>
     class basic_string_view
     {
-
     public:
 
       // types
@@ -99,7 +90,7 @@
 
       constexpr
       basic_string_view() noexcept
-      : _M_len{0}, _M_str{_S_empty_str}
+      : _M_len{0}, _M_str{nullptr}
       { }
 
       constexpr basic_string_view(const basic_string_view&) noexcept = default;
@@ -112,12 +103,12 @@
 
       constexpr basic_string_view(const _CharT* __str)
       : _M_len{__str == nullptr ? 0 : traits_type::length(__str)},
-	_M_str{__str == nullptr ? _S_empty_str : __str}
+	_M_str{__str}
       { }
 
       constexpr basic_string_view(const _CharT* __str, size_type __len)
-      : _M_len{__str == nullptr ? 0 :__len},
-        _M_str{__str == nullptr ? _S_empty_str : __str}
+      : _M_len{__len},
+        _M_str{__str}
       { }
 
       basic_string_view&
@@ -143,19 +134,19 @@
 
       const_reverse_iterator
       rbegin() const noexcept
-      { return std::reverse_iterator<const_iterator>(this->end()); }
+      { return const_reverse_iterator(this->end()); }
 
       const_reverse_iterator
       rend() const noexcept
-      { return std::reverse_iterator<const_iterator>(this->begin()); }
+      { return const_reverse_iterator(this->begin()); }
 
       const_reverse_iterator
       crbegin() const noexcept
-      { return std::reverse_iterator<const_iterator>(this->end()); }
+      { return const_reverse_iterator(this->end()); }
 
       const_reverse_iterator
       crend() const noexcept
-      { return std::reverse_iterator<const_iterator>(this->begin()); }
+      { return const_reverse_iterator(this->begin()); }
 
       // [string.view.capacity], capacity
 
@@ -169,8 +160,10 @@
 
       constexpr size_type
       max_size() const noexcept
-      { return ((npos - sizeof(size_type) - sizeof(void*))
-		/ sizeof(value_type) / 4); }
+      {
+	return (npos - sizeof(size_type) - sizeof(void*))
+		/ sizeof(value_type) / 4;
+      }
 
       constexpr bool
       empty() const noexcept
@@ -195,7 +188,7 @@
 					     "(which is %zu) >= this->size() "
 					     "(which is %zu)"),
 					 __pos, this->size()),
-		_S_empty_str[0]);
+		*this->_M_str);
       }
 
       constexpr const _CharT&
@@ -219,11 +212,12 @@
       { return this->_M_str; }
 
       // [string.view.modifiers], modifiers:
+
       void
       clear() noexcept
       {
 	this->_M_len = 0;
-	this->_M_str = _S_empty_str;
+	this->_M_str = nullptr;
       }
 
       void
@@ -251,10 +245,16 @@
       template<typename _Allocator>
         explicit operator basic_string<_CharT, _Traits, _Allocator>() const
         {
-	  return basic_string<_CharT, _Traits, _Allocator>
-					(this->_M_len, this->_M_str);
+	  return { this->_M_str, this->_M_len };
 	}
 
+      template<typename _Allocator = std::allocator<_CharT>>
+	basic_string<_CharT, _Traits, _Allocator>
+	to_string(const _Allocator& __alloc = _Allocator()) const
+	{
+	  return { this->_M_str, this->_M_len, __alloc };
+	}
+
       size_type
       copy(_CharT* __str, size_type __n, size_type __pos = 0) const
       {
@@ -431,8 +431,6 @@
 	     : static_cast<int>(difference_type{__n1 - __n2});
       }
 
-      static constexpr value_type _S_empty_str[1]{};
-
       size_t	    _M_len;
       const _CharT* _M_str;
     };
@@ -456,131 +454,119 @@
   }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator==(basic_string_view<_CharT, _Traits> __x,
                basic_string_view<_CharT, _Traits> __y) noexcept
     { return __x.compare(__y) == 0; }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator==(basic_string_view<_CharT, _Traits> __x,
                __detail::__idt<basic_string_view<_CharT, _Traits>> __y) noexcept
     { return __x.compare(__y) == 0; }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator==(__detail::__idt<basic_string_view<_CharT, _Traits>> __x,
                basic_string_view<_CharT, _Traits> __y) noexcept
     { return __x.compare(__y) == 0; }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator!=(basic_string_view<_CharT, _Traits> __x,
                basic_string_view<_CharT, _Traits> __y) noexcept
     { return !(__x == __y); }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator!=(basic_string_view<_CharT, _Traits> __x,
                __detail::__idt<basic_string_view<_CharT, _Traits>> __y) noexcept
     { return !(__x == __y); }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator!=(__detail::__idt<basic_string_view<_CharT, _Traits>> __x,
                basic_string_view<_CharT, _Traits> __y) noexcept
     { return !(__x == __y); }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator< (basic_string_view<_CharT, _Traits> __x,
                basic_string_view<_CharT, _Traits> __y) noexcept
     { return __x.compare(__y) < 0; }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator< (basic_string_view<_CharT, _Traits> __x,
                __detail::__idt<basic_string_view<_CharT, _Traits>> __y) noexcept
     { return __x.compare(__y) < 0; }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator< (__detail::__idt<basic_string_view<_CharT, _Traits>> __x,
                basic_string_view<_CharT, _Traits> __y) noexcept
     { return __x.compare(__y) < 0; }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator> (basic_string_view<_CharT, _Traits> __x,
                basic_string_view<_CharT, _Traits> __y) noexcept
     { return __x.compare(__y) > 0; }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator> (basic_string_view<_CharT, _Traits> __x,
                __detail::__idt<basic_string_view<_CharT, _Traits>> __y) noexcept
     { return __x.compare(__y) > 0; }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator> (__detail::__idt<basic_string_view<_CharT, _Traits>> __x,
                basic_string_view<_CharT, _Traits> __y) noexcept
     { return __x.compare(__y) > 0; }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator<=(basic_string_view<_CharT, _Traits> __x,
                basic_string_view<_CharT, _Traits> __y) noexcept
     { return __x.compare(__y) <= 0; }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator<=(basic_string_view<_CharT, _Traits> __x,
                __detail::__idt<basic_string_view<_CharT, _Traits>> __y) noexcept
     { return __x.compare(__y) <= 0; }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator<=(__detail::__idt<basic_string_view<_CharT, _Traits>> __x,
                basic_string_view<_CharT, _Traits> __y) noexcept
     { return __x.compare(__y) <= 0; }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator>=(basic_string_view<_CharT, _Traits> __x,
                basic_string_view<_CharT, _Traits> __y) noexcept
     { return __x.compare(__y) >= 0; }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator>=(basic_string_view<_CharT, _Traits> __x,
                __detail::__idt<basic_string_view<_CharT, _Traits>> __y) noexcept
     { return __x.compare(__y) >= 0; }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator>=(__detail::__idt<basic_string_view<_CharT, _Traits>> __x,
                basic_string_view<_CharT, _Traits> __y) noexcept
     { return __x.compare(__y) >= 0; }
 
-  // [string.view.comparison], sufficient additional overloads of comparison functions
-
-  // [string.view.nonmem], other non-member basic_string_view functions
-  template<typename _CharT, typename _Traits = char_traits<_CharT>,
-           typename _Allocator = allocator<_CharT>>
-    basic_string<_CharT, _Traits, _Allocator>
-    to_string(basic_string_view<_CharT, _Traits> __str,
-	      const _Allocator& __alloc = _Allocator())
-    {
-      return basic_string<_CharT, _Traits, _Allocator>
-			(__str.begin(), __str.end(), __alloc);
-    }
-
+  // [string.view.io], Inserters and extractors
   template<typename _CharT, typename _Traits>
-    basic_ostream<_CharT, _Traits>&
-      operator<<(basic_ostream<_CharT, _Traits>& __os,
-                 basic_string_view<_CharT,_Traits> __str)
-      { return __ostream_insert(__os, __str.data(), __str.size()); }
+    inline basic_ostream<_CharT, _Traits>&
+    operator<<(basic_ostream<_CharT, _Traits>& __os,
+	       basic_string_view<_CharT,_Traits> __str)
+    { return __ostream_insert(__os, __str.data(), __str.size()); }
 
 
   // basic_string_view typedef names
Index: libstdc++-v3/include/experimental/string_view.tcc
===================================================================
--- a/src/libstdc++-v3/include/experimental/string_view.tcc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/experimental/string_view.tcc	(.../branches/gcc-4_9-branch)
@@ -47,10 +47,6 @@
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   template<typename _CharT, typename _Traits>
-    constexpr _CharT
-    basic_string_view<_CharT, _Traits>::_S_empty_str[1];
-
-  template<typename _CharT, typename _Traits>
     typename basic_string_view<_CharT, _Traits>::size_type
     basic_string_view<_CharT, _Traits>::
     find(const _CharT* __str, size_type __pos, size_type __n) const noexcept
Index: libstdc++-v3/include/ext/pb_ds/detail/bin_search_tree_/traits.hpp
===================================================================
--- a/src/libstdc++-v3/include/ext/pb_ds/detail/bin_search_tree_/traits.hpp	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/ext/pb_ds/detail/bin_search_tree_/traits.hpp	(.../branches/gcc-4_9-branch)
@@ -55,7 +55,7 @@
 	     class Cmp_Fn,
 	     template<typename Node_CItr,
 		      class Node_Itr,
-		      class Cmp_Fn,
+		      class _Cmp_Fn,
 		      typename _Alloc>
 	     class Node_Update,
 	     class Node,
@@ -161,7 +161,7 @@
 	     class Cmp_Fn,
 	     template<typename Node_CItr,
 		      class Node_Itr,
-		      class Cmp_Fn,
+		      class _Cmp_Fn,
 		      typename _Alloc>
 	     class Node_Update,
 	     class Node,
Index: libstdc++-v3/include/ext/random.tcc
===================================================================
--- a/src/libstdc++-v3/include/ext/random.tcc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/ext/random.tcc	(.../branches/gcc-4_9-branch)
@@ -1314,7 +1314,7 @@
       operator()(_UniformRandomNumberGenerator& __urng,
 		 const param_type& __param)
       {
-	std::__detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
+	std::__detail::_Adaptor<_UniformRandomNumberGenerator, double>
 	  __aurng(__urng);
 
 	result_type __a = __param.successful_size();
Index: libstdc++-v3/include/ext/rope
===================================================================
--- a/src/libstdc++-v3/include/ext/rope	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/ext/rope	(.../branches/gcc-4_9-branch)
@@ -1544,7 +1544,7 @@
       typedef typename _Base::allocator_type allocator_type;
       using _Base::_M_tree_ptr;
       using _Base::get_allocator;
-      using _Base::_M_get_allocator;      
+      using _Base::_M_get_allocator;
       typedef __GC_CONST _CharT* _Cstrptr;
       
       static _CharT _S_empty_c_str[1];
@@ -1876,8 +1876,9 @@
 	   const allocator_type& __a = allocator_type())
       : _Base(__a)
       {
-	this->_M_tree_ptr = (0 == __len) ?
-	  0 : _S_new_RopeFunction(__fn, __len, __delete_fn, __a);
+	this->_M_tree_ptr = (0 == __len)
+	  ? 0
+	  : _S_new_RopeFunction(__fn, __len, __delete_fn, _M_get_allocator());
       }
 
       rope(const rope& __x, const allocator_type& __a = allocator_type())
Index: libstdc++-v3/include/bits/hashtable.h
===================================================================
--- a/src/libstdc++-v3/include/bits/hashtable.h	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/bits/hashtable.h	(.../branches/gcc-4_9-branch)
@@ -1281,10 +1281,10 @@
 	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
     __rehash_policy(const _RehashPolicy& __pol)
     {
-      size_type __n_bkt = __pol._M_bkt_for_elements(_M_element_count);
-      __n_bkt = __pol._M_next_bkt(__n_bkt);
-      if (__n_bkt != _M_bucket_count)
-	_M_rehash(__n_bkt, _M_rehash_policy._M_state());
+      auto __do_rehash =
+	__pol._M_need_rehash(_M_bucket_count, _M_element_count, 0);
+      if (__do_rehash.first)
+	_M_rehash(__do_rehash.second, _M_rehash_policy._M_state());
       _M_rehash_policy = __pol;
     }
 
Index: libstdc++-v3/include/bits/atomic_base.h
===================================================================
--- a/src/libstdc++-v3/include/bits/atomic_base.h	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/bits/atomic_base.h	(.../branches/gcc-4_9-branch)
@@ -675,10 +675,10 @@
 
       // Factored out to facilitate explicit specialization.
       constexpr ptrdiff_t
-      _M_type_size(ptrdiff_t __d) { return __d * sizeof(_PTp); }
+      _M_type_size(ptrdiff_t __d) const { return __d * sizeof(_PTp); }
 
       constexpr ptrdiff_t
-      _M_type_size(ptrdiff_t __d) volatile { return __d * sizeof(_PTp); }
+      _M_type_size(ptrdiff_t __d) const volatile { return __d * sizeof(_PTp); }
 
     public:
       __atomic_base() noexcept = default;
Index: libstdc++-v3/include/bits/random.tcc
===================================================================
--- a/src/libstdc++-v3/include/bits/random.tcc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/bits/random.tcc	(.../branches/gcc-4_9-branch)
@@ -3463,6 +3463,9 @@
     _RealType
     generate_canonical(_UniformRandomNumberGenerator& __urng)
     {
+      static_assert(std::is_floating_point<_RealType>::value,
+		    "template argument not a floating point type");
+
       const size_t __b
 	= std::min(static_cast<size_t>(std::numeric_limits<_RealType>::digits),
                    __bits);
Index: libstdc++-v3/include/bits/random.h
===================================================================
--- a/src/libstdc++-v3/include/bits/random.h	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/bits/random.h	(.../branches/gcc-4_9-branch)
@@ -164,6 +164,8 @@
     template<typename _Engine, typename _DInputType>
       struct _Adaptor
       {
+	static_assert(std::is_floating_point<_DInputType>::value,
+		      "template argument not a floating point type");
 
       public:
 	_Adaptor(_Engine& __g)
Index: libstdc++-v3/ChangeLog
===================================================================
--- a/src/libstdc++-v3/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,108 @@
+2014-08-09  Franois Dumont  <fdumont@gcc.gnu.org>
+
+	PR libstdc++/61667
+	* include/bits/hashtable.h (_Hashtable<>::__rehash_policy): Use
+	_M_need_rehash to initialize the rehash policy and check if a rehash is
+	needed.
+	* testsuite/23_containers/unordered_map/modifiers/61667.cc: New.
+
+2014-08-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from mainline
+	2014-07-29  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/61946
+	* include/ext/rope (rope::rope(char_producer<_CharT>*, size_t, bool,
+	const allocator_type&)): Pass non-const allocator to
+	_S_new_RopeFunction.
+	* testsuite/ext/rope/61946.cc: New.
+
+2014-08-04  Zifei Tong  <zifeitong@gmail.com>
+
+	* libsupc++/atexit_thread.cc (HAVE___CXA_THREAD_ATEXIT_IMPL): Add
+	_GLIBCXX_ prefix to macro.
+
+2014-08-04  Samuel Bronson  <naesten@gmail.com>
+
+	Backport r212453 from trunk
+	2014-07-11  Samuel Bronson  <naesten@gmail.com>
+		    Matthias Klose  <doko@ubuntu.com>
+
+	PR libstdc++/58962
+	* python/libstdcxx/v6/printers.py: Port to Python 2+3
+	(imap): New compat function.
+	(izip): Likewise.
+	(Iterator): New mixin to allow writing iterators in Python 3 style
+	regardless of which version we're running on.
+	[Python3] (long) New compat alias for "int".
+	* testsuite/lib/gdb-test.exp: Port to Python 2+3 (print syntax)
+
+	Backport r210625 from trunk
+	2014-05-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	* python/libstdcxx/v6/printers.py: Use Python3 raise syntax.
+
+2014-08-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from mainline
+	2014-06-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/61390
+	* include/ext/pb_ds/detail/bin_search_tree_/traits.hpp
+	(bin_search_tree_traits): Do not redeclare template-parameters.
+	* testsuite/util/testsuite_iterators.h (test_container): Likewise.
+
+	Backported from mainline
+	2014-06-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/condition_variable (condition_variable_any::_Unlock): Do
+	not swallow __forced_unwind.
+	* include/std/future (__future_base::_Task_setter): Likewise.
+	(__future_base::_Async_state_impl): Turn __forced_unwind into broken
+	promise and rethrow.
+	* include/std/mutex (try_lock): Likewise.
+	* testsuite/30_threads/async/forced_unwind.cc: New.
+	* testsuite/30_threads/packaged_task/forced_unwind.cc: New.
+
+	Backported from mainline
+	2014-06-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/61374
+	* include/experimental/string_view (operator basic_string): Correct
+	order of arguments.
+	(to_string): Replace with member function.
+	Add inline specifiers. Remove unused header. Remove _S_empty_rep and
+	allow _M_str to be null.
+	* testsuite/experimental/string_view/cons/char/1.cc: Adjust to new
+	default constructor semantics.
+	* testsuite/experimental/string_view/cons/wchar_t/1.cc: Likewise.
+	* testsuite/experimental/string_view/operations/copy/char/1.cc: Fix
+	copyright dates. Remove unused header.
+	* testsuite/experimental/string_view/operations/copy/wchar_t/1.cc:
+	Likewise.
+	* testsuite/experimental/string_view/operations/data/char/1.cc:
+	Fix copyright dates. Adjust to new default constructor semantics.
+	* testsuite/experimental/string_view/operations/data/wchar_t/1.cc:
+	Likewise.
+	* testsuite/experimental/string_view/operations/to_string/1.cc: New.
+
+	Backported from mainline
+	2014-04-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/atomic_base.h (__atomic_base<_PTp*>::_M_type_size): Add
+	const to constexpr member functions.
+
+2014-07-29  Ed Smith-Rowland  <3dw4rd@verizon.net>
+
+	PR libstdc++/60037 - SIGFPE in std::generate_canonical<unsigned int...>
+	* include/bits/random.h (_Adaptor): static_assert for non floating-point
+	result type.
+	* include/bits/random.tcc (generate_canonical): Ditto.
+	* include/ext/random.tcc (hypergeometric_distribution::operator()):
+	Use double as a rng result type.
+	* testsuite/26_numerics/random/pr60037-neg.cc: New.
+	* testsuite/ext/random/hypergeometric_distribution/pr60037.cc: New.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: libstdc++-v3/libsupc++/atexit_thread.cc
===================================================================
--- a/src/libstdc++-v3/libsupc++/atexit_thread.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/libsupc++/atexit_thread.cc	(.../branches/gcc-4_9-branch)
@@ -26,7 +26,7 @@
 #include <new>
 #include "bits/gthr.h"
 
-#if HAVE___CXA_THREAD_ATEXIT_IMPL
+#if _GLIBCXX_HAVE___CXA_THREAD_ATEXIT_IMPL
 
 extern "C" int __cxa_thread_atexit_impl (void (*func) (void *),
 					 void *arg, void *d);
@@ -38,7 +38,7 @@
   return __cxa_thread_atexit_impl (dtor, obj, dso_handle);
 }
 
-#else /* HAVE___CXA_THREAD_ATEXIT_IMPL */
+#else /* _GLIBCXX_HAVE___CXA_THREAD_ATEXIT_IMPL */
 
 namespace {
   // One element in a singly-linked stack of cleanups.
@@ -142,4 +142,4 @@
   return 0;
 }
 
-#endif /* HAVE___CXA_THREAD_ATEXIT_IMPL */
+#endif /* _GLIBCXX_HAVE___CXA_THREAD_ATEXIT_IMPL */
Index: libstdc++-v3/testsuite/26_numerics/random/pr60037-neg.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/26_numerics/random/pr60037-neg.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/26_numerics/random/pr60037-neg.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,15 @@
+// { dg-do compile }
+// { dg-options "-std=gnu++11" }
+
+#include <random>
+
+std::mt19937 urng;
+
+std::__detail::_Adaptor<std::mt19937, unsigned long> aurng(urng);
+
+auto x = std::generate_canonical<std::size_t,
+			std::numeric_limits<std::size_t>::digits>(urng);
+
+// { dg-error "static assertion failed: template argument not a floating point type" "" { target *-*-* } 167 }
+
+// { dg-error "static assertion failed: template argument not a floating point type" "" { target *-*-* } 3466 }
Index: libstdc++-v3/testsuite/30_threads/packaged_task/forced_unwind.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/30_threads/packaged_task/forced_unwind.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/30_threads/packaged_task/forced_unwind.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,48 @@
+// { dg-do run { target *-*-linux* *-*-gnu* } }
+// { dg-options " -std=gnu++11 -pthread" { target *-*-linux* *-*-gnu* } }
+// { dg-require-cstdint "" }
+// { dg-require-gthreads "" }
+// { dg-require-atomic-builtins "" }
+
+// Copyright (C) 2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// Test (non-standard) handling of __forced_unwind exception.
+
+#include <future>
+#include <stdexcept>
+#include <pthread.h>
+#include <testsuite_hooks.h>
+
+void f() { pthread_exit(nullptr); }
+
+int main()
+{
+  std::packaged_task<void()> p(f);
+  auto fut = p.get_future();
+  std::thread t(std::move(p));
+  try
+  {
+    fut.get();
+    throw std::logic_error("Unreachable");
+  }
+  catch (const std::future_error& e)
+  {
+    VERIFY( e.code() == std::future_errc::broken_promise );
+  }
+  t.join();
+}
Index: libstdc++-v3/testsuite/30_threads/async/forced_unwind.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/30_threads/async/forced_unwind.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/30_threads/async/forced_unwind.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,45 @@
+// { dg-do run { target *-*-linux* *-*-gnu* } }
+// { dg-options " -std=gnu++11 -pthread" { target *-*-linux* *-*-gnu* } }
+// { dg-require-cstdint "" }
+// { dg-require-gthreads "" }
+// { dg-require-atomic-builtins "" }
+
+// Copyright (C) 2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// Test (non-standard) handling of __forced_unwind exception.
+
+#include <future>
+#include <stdexcept>
+#include <pthread.h>
+#include <testsuite_hooks.h>
+
+void f() { pthread_exit(nullptr); }
+
+int main()
+{
+  auto fut = std::async(std::launch::async, f);
+  try
+  {
+    fut.get();
+    throw std::logic_error("Unreachable");
+  }
+  catch (const std::future_error& e)
+  {
+    VERIFY( e.code() == std::future_errc::broken_promise );
+  }
+}
Index: libstdc++-v3/testsuite/experimental/string_view/cons/wchar_t/1.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/experimental/string_view/cons/wchar_t/1.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/experimental/string_view/cons/wchar_t/1.cc	(.../branches/gcc-4_9-branch)
@@ -33,7 +33,7 @@
   // basic_string_view()
   const std::experimental::wstring_view str00{};
   VERIFY( str00.length() == 0 );
-  VERIFY( str00.data() != nullptr );
+  VERIFY( str00.data() == nullptr );
 
   // basic_string_view(const char*)
   const wchar_t str_lit01[] = L"rodeo beach, marin";
@@ -54,11 +54,6 @@
   VERIFY( str05.length() == len_lit01 );
   VERIFY( str05.data() == str_lit01 );
 
-  //  basic_string_view(const wchar_t* s, std::size_t l)
-  std::experimental::wstring_view str06{nullptr, len_lit01};
-  VERIFY( str06.length() == 0 );
-  VERIFY( str06.data() != nullptr );
-
   // basic_string_view(basic_string& s)
   std::wstring istr07(10, L'z');
   std::experimental::wstring_view str07{istr07};
Index: libstdc++-v3/testsuite/experimental/string_view/cons/char/1.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/experimental/string_view/cons/char/1.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/experimental/string_view/cons/char/1.cc	(.../branches/gcc-4_9-branch)
@@ -33,7 +33,7 @@
   // basic_string_view()
   const std::experimental::string_view str00{};
   VERIFY( str00.length() == 0 );
-  VERIFY( str00.data() != nullptr );
+  VERIFY( str00.data() == nullptr );
 
   // basic_string_view(const char*)
   const char str_lit01[] = "rodeo beach, marin";
@@ -54,11 +54,6 @@
   VERIFY( str05.length() == len_lit01 );
   VERIFY( str05.data() == str_lit01 );
 
-  //  basic_string_view(const char* s, std::size_t l)
-  std::experimental::string_view str06{nullptr, len_lit01};
-  VERIFY( str06.length() == 0 );
-  VERIFY( str06.data() != nullptr );
-
   // basic_string_view(basic_string& s)
   std::string istr07(10, 'z');
   std::experimental::string_view str07{istr07};
Index: libstdc++-v3/testsuite/experimental/string_view/operations/to_string/1.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/experimental/string_view/operations/to_string/1.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/experimental/string_view/operations/to_string/1.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,53 @@
+// { dg-options "-std=gnu++1y" }
+
+// Copyright (C) 2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// basic_string_view::to_string
+
+#include <experimental/string_view>
+#include <algorithm>
+#include <testsuite_hooks.h>
+#include <testsuite_allocator.h>
+
+bool
+test01()
+{
+  bool test [[gnu::unused]] = true;
+
+  const char str_lit[] = "123456789A";
+  const std::experimental::string_view sv(str_lit);
+  char buffer[4] = { 0 };
+
+  auto s1 = sv.to_string();
+  VERIFY( s1 == str_lit );
+  using test_alloc = __gnu_test::tracker_allocator<char>;
+  auto s2 = sv.to_string( test_alloc{} );
+  static_assert( std::is_same<decltype(s2)::allocator_type, test_alloc>::value,
+                 "to_string() uses custom allocator" );
+  VERIFY( std::equal(s1.begin(), s1.end(), s2.begin(), s2.end()) );
+  auto s3 = static_cast<std::string>(sv);
+  VERIFY( s3 == s1 );
+
+  return test;
+}
+
+int
+main()
+{
+  test01();
+}
Index: libstdc++-v3/testsuite/experimental/string_view/operations/data/wchar_t/1.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/experimental/string_view/operations/data/wchar_t/1.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/experimental/string_view/operations/data/wchar_t/1.cc	(.../branches/gcc-4_9-branch)
@@ -1,6 +1,6 @@
 // { dg-options "-std=gnu++1y" }
 
-// Copyright (C) 2013 Free Software Foundation, Inc.
+// Copyright (C) 2013-2014 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -29,10 +29,9 @@
 
   std::experimental::wstring_view empty;
 
-  // data() for size == 0 is non-NULL.
   VERIFY( empty.size() == 0 );
   const std::experimental::wstring_view::value_type* p = empty.data();
-  VERIFY( p );
+  VERIFY( p == nullptr );
 
   return 0;
 }
Index: libstdc++-v3/testsuite/experimental/string_view/operations/data/char/1.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/experimental/string_view/operations/data/char/1.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/experimental/string_view/operations/data/char/1.cc	(.../branches/gcc-4_9-branch)
@@ -1,6 +1,6 @@
 // { dg-options "-std=gnu++1y" }
 
-// Copyright (C) 2013 Free Software Foundation, Inc.
+// Copyright (C) 2013-2014 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -29,10 +29,9 @@
 
   std::experimental::string_view empty;
 
-  // data() for size == 0 is non-NULL.
   VERIFY( empty.size() == 0 );
   const std::experimental::string_view::value_type* p = empty.data();
-  VERIFY( p );
+  VERIFY( p == nullptr );
 
   return 0;
 }
Index: libstdc++-v3/testsuite/experimental/string_view/operations/copy/wchar_t/1.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/experimental/string_view/operations/copy/wchar_t/1.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/experimental/string_view/operations/copy/wchar_t/1.cc	(.../branches/gcc-4_9-branch)
@@ -1,6 +1,6 @@
 // { dg-options "-std=gnu++1y" }
 
-// Copyright (C) 2013 Free Software Foundation, Inc.
+// Copyright (C) 2013-2014 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -20,7 +20,6 @@
 // basic_string_view::copy
 
 #include <experimental/string_view>
-#include <stdexcept>
 #include <testsuite_hooks.h>
 
 bool
Index: libstdc++-v3/testsuite/experimental/string_view/operations/copy/char/1.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/experimental/string_view/operations/copy/char/1.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/experimental/string_view/operations/copy/char/1.cc	(.../branches/gcc-4_9-branch)
@@ -1,6 +1,6 @@
 // { dg-options "-std=gnu++1y" }
 
-// Copyright (C) 2013 Free Software Foundation, Inc.
+// Copyright (C) 2013-2014 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -20,7 +20,6 @@
 // basic_string_view::copy
 
 #include <experimental/string_view>
-#include <stdexcept>
 #include <testsuite_hooks.h>
 
 bool
Index: libstdc++-v3/testsuite/ext/random/hypergeometric_distribution/pr60037.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/ext/random/hypergeometric_distribution/pr60037.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/ext/random/hypergeometric_distribution/pr60037.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,23 @@
+// { dg-options "-std=gnu++11 -O0" }
+// { dg-require-cstdint "" }
+// { dg-require-cmath "" }
+
+#include <ext/random>
+#include <functional>
+
+void
+hyperplot(unsigned int N, unsigned int K, unsigned int n)
+{
+  std::mt19937 re; // the default engine
+  __gnu_cxx::hypergeometric_distribution<> hd(N, K, n);
+  auto gen = std::bind(hd, re);
+  gen();
+}
+
+int
+main()
+{
+  hyperplot(15, 3, 2);
+  hyperplot(500, 50, 30);
+  hyperplot(100, 20, 5);
+}
Index: libstdc++-v3/testsuite/ext/rope/61946.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/ext/rope/61946.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/ext/rope/61946.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,31 @@
+// Copyright (C) 2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile }
+
+#include <ext/rope>
+
+struct empty_char_prod : __gnu_cxx::char_producer<char>
+{
+  virtual void operator()(size_t, size_t, char*) {}
+};
+
+int main ()
+{
+  empty_char_prod* ecp = new empty_char_prod;
+  __gnu_cxx::crope excrope( ecp, 10L, true );
+}
Index: libstdc++-v3/testsuite/lib/gdb-test.exp
===================================================================
--- a/src/libstdc++-v3/testsuite/lib/gdb-test.exp	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/lib/gdb-test.exp	(.../branches/gcc-4_9-branch)
@@ -91,7 +91,7 @@
 	}
     }
 
-    set do_whatis_tests [gdb_batch_check "python print gdb.type_printers" \
+    set do_whatis_tests [gdb_batch_check "python print(gdb.type_printers)" \
 			   "\\\[\\\]"]
     if {!$do_whatis_tests} {
 	send_log "skipping 'whatis' tests - gdb too old"
@@ -252,6 +252,6 @@
 # but not earlier versions.
 # Return 1 if the version is ok, 0 otherwise.
 proc gdb_version_check {} {
-    return [gdb_batch_check "python print gdb.lookup_global_symbol" \
+    return [gdb_batch_check "python print(gdb.lookup_global_symbol)" \
 	      "<built-in function lookup_global_symbol>"]
 }
Index: libstdc++-v3/testsuite/23_containers/unordered_map/modifiers/61667.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/23_containers/unordered_map/modifiers/61667.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/23_containers/unordered_map/modifiers/61667.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,44 @@
+// { dg-options "-std=gnu++11" }
+
+// Copyright (C) 2011-2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <unordered_map>
+#include <testsuite_hooks.h>
+
+bool test __attribute__((unused)) = true;
+
+void test01()
+{
+  std::unordered_map<int, int> um(20);
+
+  std::size_t bkt_count = um.bucket_count();
+
+  um.max_load_factor(um.max_load_factor());
+
+  VERIFY( um.bucket_count() >= bkt_count );
+
+  um.max_load_factor(um.max_load_factor() * 2.f);
+
+  VERIFY( um.bucket_count() >= bkt_count );
+}
+
+int main()
+{
+  test01();
+  return 0;
+}
Index: libstdc++-v3/testsuite/util/testsuite_iterators.h
===================================================================
--- a/src/libstdc++-v3/testsuite/util/testsuite_iterators.h	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/util/testsuite_iterators.h	(.../branches/gcc-4_9-branch)
@@ -518,7 +518,7 @@
    * It takes two pointers representing a range and presents them as 
    * a container of iterators.
    */
-  template <class T, template<class T> class ItType>
+  template <class T, template<class TT> class ItType>
   struct test_container
   {
     typename ItType<T>::ContainerType bounds;
Index: configure.ac
===================================================================
--- a/src/configure.ac	(.../tags/gcc_4_9_1_release)
+++ b/src/configure.ac	(.../branches/gcc-4_9-branch)
@@ -1177,6 +1177,9 @@
   *-mingw*)
     host_makefile_frag="config/mh-mingw"
     ;;
+  alpha*-*-linux*)
+    host_makefile_frag="config/mh-alpha-linux"
+    ;;
   hppa*-hp-hpux10*)
     host_makefile_frag="config/mh-pa-hpux10"
     ;;
Index: ChangeLog
===================================================================
--- a/src/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,9 @@
+2014-07-26  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/47230
+	* configure.ac (alpha*-*-linux*): Use mh-alpha-linux.
+	* configure: Regenerate.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
@@ -9,7 +15,7 @@
 2014-04-04  Eric Botcazou  <ebotcazou@adacore.com>
 
 	PR bootstrap/60620
-	* Makefile.def (dependencies): Make gnattools depend on libstdc++-v3. 
+	* Makefile.def (dependencies): Make gnattools depend on libstdc++-v3.
 	* Makefile.in: Regenerate.
 
 2014-03-28  Yaakov Selkowitz  <yselkowitz@users.sourceforge.net>
@@ -47,7 +53,8 @@
 
 2014-03-07  Denis Chertykov  <chertykov@gmail.com>
 
-	* MAINTAINERS: Remove avr maintainers: Anatoly Sokolov and Eric Weddington
+	* MAINTAINERS: Remove avr maintainers: Anatoly Sokolov
+	and Eric Weddington
 
 2014-03-07  Jakub Jelinek  <jakub@redhat.com>
 
Index: config/mh-alpha-linux
===================================================================
--- a/src/config/mh-alpha-linux	(.../tags/gcc_4_9_1_release)
+++ b/src/config/mh-alpha-linux	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,3 @@
+# Prevent GPREL16 relocation truncation
+LDFLAGS += -Wl,--no-relax
+BOOT_LDFLAGS += -Wl,--no-relax
Index: config/ChangeLog
===================================================================
--- a/src/config/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/config/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,8 @@
+2014-07-26  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/47230
+	* mh-alpha-linux: New file.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: configure
===================================================================
--- a/src/configure	(.../tags/gcc_4_9_1_release)
+++ b/src/configure	(.../branches/gcc-4_9-branch)
@@ -3868,6 +3868,9 @@
   *-mingw*)
     host_makefile_frag="config/mh-mingw"
     ;;
+  alpha*-*-linux*)
+    host_makefile_frag="config/mh-alpha-linux"
+    ;;
   hppa*-hp-hpux10*)
     host_makefile_frag="config/mh-pa-hpux10"
     ;;
Index: libgcc/ChangeLog
===================================================================
--- a/src/libgcc/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/libgcc/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,9 @@
+2014-08-04  Rohit  <rohitarulraj@freescale.com>
+
+	PR target/60102
+	* config/rs6000/linux-unwind.h (ppc_fallback_frame_state): Update
+	based on change in SPE high register numbers and 3 HTM registers.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: libgcc/config/rs6000/linux-unwind.h
===================================================================
--- a/src/libgcc/config/rs6000/linux-unwind.h	(.../tags/gcc_4_9_1_release)
+++ b/src/libgcc/config/rs6000/linux-unwind.h	(.../branches/gcc-4_9-branch)
@@ -274,8 +274,8 @@
 #ifdef __SPE__
   for (i = 14; i < 32; i++)
     {
-      fs->regs.reg[i + FIRST_PSEUDO_REGISTER - 1].how = REG_SAVED_OFFSET;
-      fs->regs.reg[i + FIRST_PSEUDO_REGISTER - 1].loc.offset
+      fs->regs.reg[i + FIRST_SPE_HIGH_REGNO - 4].how = REG_SAVED_OFFSET;
+      fs->regs.reg[i + FIRST_SPE_HIGH_REGNO - 4].loc.offset
 	= (long) &regs->vregs - new_cfa + 4 * i;
     }
 #endif
Index: gcc/tree-ssa-tail-merge.c
===================================================================
--- a/src/gcc/tree-ssa-tail-merge.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/tree-ssa-tail-merge.c	(.../branches/gcc-4_9-branch)
@@ -1159,17 +1159,9 @@
       lhs2 = gimple_get_lhs (s2);
       if (TREE_CODE (lhs1) != SSA_NAME
 	  && TREE_CODE (lhs2) != SSA_NAME)
-	{
-	  /* If the vdef is the same, it's the same statement.  */
-	  if (vn_valueize (gimple_vdef (s1))
-	      == vn_valueize (gimple_vdef (s2)))
-	    return true;
-
-	  /* Test for structural equality.  */
-	  return (operand_equal_p (lhs1, lhs2, 0)
-		  && gimple_operand_equal_value_p (gimple_assign_rhs1 (s1),
-						   gimple_assign_rhs1 (s2)));
-	}
+	return (operand_equal_p (lhs1, lhs2, 0)
+		&& gimple_operand_equal_value_p (gimple_assign_rhs1 (s1),
+						 gimple_assign_rhs1 (s2)));
       else if (TREE_CODE (lhs1) == SSA_NAME
 	       && TREE_CODE (lhs2) == SSA_NAME)
 	return vn_valueize (lhs1) == vn_valueize (lhs2);
Index: gcc/c-family/c-gimplify.c
===================================================================
--- a/src/gcc/c-family/c-gimplify.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/c-family/c-gimplify.c	(.../branches/gcc-4_9-branch)
@@ -199,9 +199,7 @@
 	tree type = TREE_TYPE (TREE_OPERAND (*expr_p, 0));
 	if (INTEGRAL_TYPE_P (type) && c_promoting_integer_type_p (type))
 	  {
-	    if (TYPE_OVERFLOW_UNDEFINED (type)
-		|| ((flag_sanitize & SANITIZE_SI_OVERFLOW)
-		    && !TYPE_OVERFLOW_WRAPS (type)))
+	    if (!TYPE_OVERFLOW_WRAPS (type))
 	      type = unsigned_type_for (type);
 	    return gimplify_self_mod_expr (expr_p, pre_p, post_p, 1, type);
 	  }
Index: gcc/c-family/ChangeLog
===================================================================
--- a/src/gcc/c-family/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/c-family/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,25 @@
+2014-08-12  Igor Zamyatin  <igor.zamyatin@intel.com>
+
+	PR other/61962
+	* array-notation-common.c (find_rank): Added handling for other
+	types of references.
+
+2014-08-01  Igor Zamyatin  <igor.zamyatin@intel.com>
+
+	PR middle-end/61455
+	* array-notation-common.c (extract_array_notation_exprs): Handling
+	of DECL_EXPR added.
+
+2014-07-17  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2014-07-09  Richard Biener  <rguenther@suse.de>
+
+	PR c-family/61741
+	* c-gimplify.c (c_gimplify_expr): Gimplify self-modify expressions
+	using unsigned arithmetic if overflow does not wrap instead of
+	if overflow is undefined.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: gcc/c-family/array-notation-common.c
===================================================================
--- a/src/gcc/c-family/array-notation-common.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/c-family/array-notation-common.c	(.../branches/gcc-4_9-branch)
@@ -221,11 +221,14 @@
 	      current_rank++;
 	      ii_tree = ARRAY_NOTATION_ARRAY (ii_tree);
 	    }
-	  else if (TREE_CODE (ii_tree) == ARRAY_REF)
+	  else if (handled_component_p (ii_tree)
+		   || TREE_CODE (ii_tree) == INDIRECT_REF)
 	    ii_tree = TREE_OPERAND (ii_tree, 0);
 	  else if (TREE_CODE (ii_tree) == PARM_DECL
 		   || TREE_CODE (ii_tree) == VAR_DECL)
 	    break;
+	  else
+	    gcc_unreachable ();
 	}
       if (*rank == 0)
 	/* In this case, all the expressions this function has encountered thus
@@ -329,6 +332,14 @@
       vec_safe_push (*array_list, node);
       return;
     }
+  if (TREE_CODE (node) == DECL_EXPR)
+    {
+      tree x = DECL_EXPR_DECL (node);
+      if (DECL_INITIAL (x))
+	extract_array_notation_exprs (DECL_INITIAL (x),
+				      ignore_builtin_fn,
+				      array_list);
+    }
   else if (TREE_CODE (node) == STATEMENT_LIST)
     {
       tree_stmt_iterator ii_tsi;
Index: gcc/c/ChangeLog
===================================================================
--- a/src/gcc/c/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/c/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,15 @@
+2014-08-22  Igor Zamyatin  <igor.zamyatin@intel.com>
+
+	PR other/62008
+	* c-parser.c (c_parser_array_notation): Check for correct
+	type of an array added.
+
+2014-08-01  Igor Zamyatin  <igor.zamyatin@intel.com>
+
+	PR middle-end/61455
+	* c-array-notation.c (expand_array_notations): Handling
+	of DECL_EXPR added.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: gcc/c/c-parser.c
===================================================================
--- a/src/gcc/c/c-parser.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/c/c-parser.c	(.../branches/gcc-4_9-branch)
@@ -14074,6 +14074,13 @@
   
   array_type = TREE_TYPE (array_value);
   gcc_assert (array_type);
+  if (TREE_CODE (array_type) != ARRAY_TYPE
+      && TREE_CODE (array_type) != POINTER_TYPE)
+    {
+      error_at (loc, "base of array section must be pointer or array type");
+      c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, NULL);
+      return error_mark_node;
+    }
   type = TREE_TYPE (array_type);
   token = c_parser_peek_token (parser);
    
Index: gcc/c/c-array-notation.c
===================================================================
--- a/src/gcc/c/c-array-notation.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/c/c-array-notation.c	(.../branches/gcc-4_9-branch)
@@ -1265,6 +1265,25 @@
 					 rhs_loc, rhs, TREE_TYPE (rhs));
       }
       break;
+    case DECL_EXPR:
+      {
+	tree x = DECL_EXPR_DECL (*tp);
+	if (DECL_INITIAL (x))
+	  {
+	    location_t loc = DECL_SOURCE_LOCATION (x);
+	    tree lhs = x;
+	    tree rhs = DECL_INITIAL (x);
+	    DECL_INITIAL (x) = NULL;
+	    tree new_modify_expr = build_modify_expr (loc, lhs,
+						      TREE_TYPE (lhs),
+						      NOP_EXPR,
+						      loc, rhs,
+						      TREE_TYPE(rhs));
+	    expand_array_notations (&new_modify_expr, walk_subtrees, NULL);
+	    *tp = new_modify_expr;
+	  }
+      }
+      break;
     case CALL_EXPR:
       *tp = fix_array_notation_call_expr (*tp);
       break;
Index: gcc/optabs.c
===================================================================
--- a/src/gcc/optabs.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/optabs.c	(.../branches/gcc-4_9-branch)
@@ -7334,7 +7334,10 @@
      perform the operation.  */
   if (!ret)
     {
-      emit_move_insn (subtarget, mem);
+      /* If the result is ignored skip the move to target.  */
+      if (subtarget != const0_rtx)
+        emit_move_insn (subtarget, mem);
+
       emit_move_insn (mem, trueval);
       ret = subtarget;
     }
Index: gcc/DATESTAMP
===================================================================
--- a/src/gcc/DATESTAMP	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/DATESTAMP	(.../branches/gcc-4_9-branch)
@@ -1 +1 @@
-20140716
+20140824
Index: gcc/omp-low.c
===================================================================
--- a/src/gcc/omp-low.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/omp-low.c	(.../branches/gcc-4_9-branch)
@@ -1872,7 +1872,6 @@
   TREE_STATIC (decl) = 1;
   TREE_USED (decl) = 1;
   DECL_ARTIFICIAL (decl) = 1;
-  DECL_NAMELESS (decl) = 1;
   DECL_IGNORED_P (decl) = 0;
   TREE_PUBLIC (decl) = 0;
   DECL_UNINLINABLE (decl) = 1;
Index: gcc/toplev.c
===================================================================
--- a/src/gcc/toplev.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/toplev.c	(.../branches/gcc-4_9-branch)
@@ -1052,16 +1052,19 @@
 
   if (warn_stack_usage >= 0)
     {
+      const location_t loc = DECL_SOURCE_LOCATION (current_function_decl);
+
       if (stack_usage_kind == DYNAMIC)
-	warning (OPT_Wstack_usage_, "stack usage might be unbounded");
+	warning_at (loc, OPT_Wstack_usage_, "stack usage might be unbounded");
       else if (stack_usage > warn_stack_usage)
 	{
 	  if (stack_usage_kind == DYNAMIC_BOUNDED)
-	    warning (OPT_Wstack_usage_, "stack usage might be %wd bytes",
-		     stack_usage);
+	    warning_at (loc,
+			OPT_Wstack_usage_, "stack usage might be %wd bytes",
+			stack_usage);
 	  else
-	    warning (OPT_Wstack_usage_, "stack usage is %wd bytes",
-		     stack_usage);
+	    warning_at (loc, OPT_Wstack_usage_, "stack usage is %wd bytes",
+			stack_usage);
 	}
     }
 }
Index: gcc/ChangeLog
===================================================================
--- a/src/gcc/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,578 @@
+2014-08-23  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR target/62038
+	* config/pa/pa.c (pa_output_function_epilogue): Don't set
+	last_address when the current function is a thunk.
+	(pa_asm_output_mi_thunk): When we don't have named sections or they
+	are not being used, check that thunk can reach the stub table with a
+	short branch.
+
+2014-08-22  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Backport fro mainline
+	2014-08-22  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/62195
+	* doc/md.texi (Machine Constraints): Update PowerPC wi constraint
+	documentation to state it is only for VSX operations.
+
+	* config/rs6000/rs6000.c (rs6000_init_hard_regno_mode_ok): Make wi
+	constraint only active if VSX.
+
+	* config/rs6000/rs6000.md (lfiwax): Use wj constraint instead of
+	wi cosntraint for ISA 2.07 lxsiwax/lxsiwzx instructions.
+	(lfiwzx): Likewise.
+
+2014-08-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2014-08-19  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* config/i386/i386.md (*ctz<mode>2_falsedep_1): Don't clear
+	destination if it is used in source.
+	(*clz<mode>2_lzcnt_falsedep_1): Likewise.
+	(*popcount<mode>2_falsedep_1): Likewise.
+
+	Backport from mainline
+	2014-08-18  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/62011
+	* config/i386/x86-tune.def (X86_TUNE_AVOID_FALSE_DEP_FOR_BMI):
+	New tune flag.
+	* config/i386/i386.h (TARGET_AVOID_FALSE_DEP_FOR_BMI): New define.
+	* config/i386/i386.md (unspec) <UNSPEC_INSN_FALSE_DEP>: New unspec.
+	(ffs<mode>2): Do not expand with tzcnt for
+	TARGET_AVOID_FALSE_DEP_FOR_BMI.
+	(ffssi2_no_cmove): Ditto.
+	(*tzcnt<mode>_1): Disable for TARGET_AVOID_FALSE_DEP_FOR_BMI.
+	(ctz<mode>2): New expander.
+	(*ctz<mode>2_falsedep_1): New insn_and_split pattern.
+	(*ctz<mode>2_falsedep): New insn.
+	(*ctz<mode>2): Rename from ctz<mode>2.
+	(clz<mode>2_lzcnt): New expander.
+	(*clz<mode>2_lzcnt_falsedep_1): New insn_and_split pattern.
+	(*clz<mode>2_lzcnt_falsedep): New insn.
+	(*clz<mode>2): Rename from ctz<mode>2.
+	(popcount<mode>2): New expander.
+	(*popcount<mode>2_falsedep_1): New insn_and_split pattern.
+	(*popcount<mode>2_falsedep): New insn.
+	(*popcount<mode>2): Rename from ctz<mode>2.
+	(*popcount<mode>2_cmp): Remove.
+	(*popcountsi2_cmp_zext): Ditto.
+
+2014-08-20  Martin Jambor  <mjambor@suse.cz>
+	    Wei Mi  <wmi@google.com>
+
+	PR ipa/60449
+	PR middle-end/61776
+	* tree-ssa-operands.c (update_stmt_operands): Remove
+	MODIFIED_NORETURN_CALLS.
+	* tree-cfgcleanup.c (cleanup_call_ctrl_altering_flag): New func.
+	(cleanup_control_flow_bb): Use cleanup_call_ctrl_altering_flag.
+	(split_bb_on_noreturn_calls): Renamed from split_bbs_on_noreturn_calls.
+	(cleanup_tree_cfg_1): Use split_bb_on_noreturn_calls.
+	* tree-ssanames.h: Remove MODIFIED_NORETURN_CALLS.
+	* gimple.h (enum gf_mask): Add GF_CALL_CTRL_ALTERING.
+	(gimple_call_set_ctrl_altering): New func.
+	(gimple_call_ctrl_altering_p): Ditto.
+	* tree-cfg.c (gimple_call_initialize_ctrl_altering): Ditto.
+	(make_blocks): Use gimple_call_initialize_ctrl_altering.
+	(is_ctrl_altering_stmt): Use gimple_call_ctrl_altering_p.
+	(execute_fixup_cfg): Use gimple_call_ctrl_altering_p and
+	remove MODIFIED_NORETURN_CALLS.
+
+2014-08-20  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	Backport from mainline.
+	2014-08-12  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+	PR target/62098
+	* config/arm/vfp.md (*combine_vcvtf2i): Fix constraint.
+	Remove unnecessary attributes.
+
+2014-08-16  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR target/61641
+	* config/pa/pa-protos.h (pa_output_addr_vec, pa_output_addr_diff_vec):
+	Declare.
+	* config/pa/pa.c (pa_reorg): Remove code to insert brtab marker insns.
+	(pa_output_addr_vec, pa_output_addr_diff_vec): New.
+	* config/pa/pa.h (ASM_OUTPUT_ADDR_VEC, ASM_OUTPUT_ADDR_DIFF_VEC):
+	Define.
+	* config/pa/pa.md (begin_brtab): Delete insn.
+	(end_brtab): Likewise.
+
+2014-08-15  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline:
+	2014-08-15  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	* doc/invoke.texi (SH options): Document missing processor variant
+	options.  Remove references to Hitachi.  Undocument deprecated mspace
+	option.
+
+2014-08-15  Tom de Vries  <tom@codesourcery.com>
+
+	Backport from mainline:
+	2014-08-14  Tom de Vries  <tom@codesourcery.com>
+
+	PR rtl-optimization/62004
+	PR rtl-optimization/62030
+	* ifcvt.c (rtx_interchangeable_p): New function.
+	(noce_try_move, noce_process_if_block): Use rtx_interchangeable_p.
+
+	2014-08-05  Richard Biener  <rguenther@suse.de>
+
+	* emit-rtl.h (mem_attrs_eq_p): Declare.
+	* emit-rtl.c (mem_attrs_eq_p): Export.
+
+2014-08-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/62092
+	* gimplify.c (gimplify_adjust_omp_clauses_1): Don't remove
+	OMP_CLAUSE_SHARED for global vars if the global var is mentioned
+	in OMP_CLAUSE_MAP in some outer target region.
+
+>>>>>>> .r214216
+2014-08-14  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2014-08-04  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/61713
+	* gcc/optabs.c (expand_atomic_test_and_set): Do not try to emit
+	move to subtarget in serial version if result is ignored.
+
+2014-08-14  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2014-08-12  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	PR middle-end/62103
+	* gimple-fold.c (fold_ctor_reference): Don't fold in presence of
+	bitfields, that is when size doesn't match the size of type or the
+	size of the constructor.
+
+2014-08-12  Felix Yang  <fei.yang0953@gmail.com>
+
+	PR tree-optimization/62073
+	* tree-vect-loop.c (vect_is_simple_reduction_1): Check that DEF1 has
+	a basic block.
+
+2014-08-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/62025
+	* sched-deps.c (find_inc): Check if inc_insn doesn't clobber
+	any registers that are used in mem_insn.
+
+2014-08-12  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Backport patch from mainline
+	2014-08-11  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	* config/rs6000/constraints.md (wh constraint): New constraint,
+	for FP registers if direct move is available.
+	(wi constraint): New constraint, for VSX/FP registers that can
+	handle 64-bit integers.
+	(wj constraint): New constraint for VSX/FP registers that can
+	handle 64-bit integers for direct moves.
+	(wk constraint): New constraint for VSX/FP registers that can
+	handle 64-bit doubles for direct moves.
+	(wy constraint): Make documentation match implementation.
+
+	* config/rs6000/rs6000.c (struct rs6000_reg_addr): Add
+	scalar_in_vmx_p field to simplify tests of whether SFmode or
+	DFmode can go in the Altivec registers.
+	(rs6000_hard_regno_mode_ok): Use scalar_in_vmx_p field.
+	(rs6000_setup_reg_addr_masks): Likewise.
+	(rs6000_debug_print_mode): Add debug support for scalar_in_vmx_p
+	field, and wh/wi/wj/wk constraints.
+	(rs6000_init_hard_regno_mode_ok): Setup scalar_in_vmx_p field, and
+	the wh/wi/wj/wk constraints.
+	(rs6000_preferred_reload_class): If SFmode/DFmode can go in the
+	upper registers, prefer VSX registers unless the operation is a
+	memory operation with REG+OFFSET addressing.
+
+	* config/rs6000/vsx.md (VSr mode attribute): Add support for
+	DImode.  Change SFmode to use ww constraint instead of d to allow
+	SF registers in the upper registers.
+	(VSr2): Likewise.
+	(VSr3): Likewise.
+	(VSr5): Fix thinko in comment.
+	(VSa): New mode attribute that is an alternative to wa, that
+	returns the VSX register class that a mode can go in, but may not
+	be the preferred register class.
+	(VS_64dm): New mode attribute for appropriate register classes for
+	referencing 64-bit elements of vectors for direct moves and normal
+	moves.
+	(VS_64reg): Likewise.
+	(vsx_mov<mode>): Change wa constraint to <VSa> to limit the
+	register allocator to only registers the data type can handle.
+	(vsx_le_perm_load_<mode>): Likewise.
+	(vsx_le_perm_store_<mode>): Likewise.
+	(vsx_xxpermdi2_le_<mode>): Likewise.
+	(vsx_xxpermdi4_le_<mode>): Likewise.
+	(vsx_lxvd2x2_le_<mode>): Likewise.
+	(vsx_lxvd2x4_le_<mode>): Likewise.
+	(vsx_stxvd2x2_le_<mode>): Likewise.
+	(vsx_add<mode>3): Likewise.
+	(vsx_sub<mode>3): Likewise.
+	(vsx_mul<mode>3): Likewise.
+	(vsx_div<mode>3): Likewise.
+	(vsx_tdiv<mode>3_internal): Likewise.
+	(vsx_fre<mode>2): Likewise.
+	(vsx_neg<mode>2): Likewise.
+	(vsx_abs<mode>2): Likewise.
+	(vsx_nabs<mode>2): Likewise.
+	(vsx_smax<mode>3): Likewise.
+	(vsx_smin<mode>3): Likewise.
+	(vsx_sqrt<mode>2): Likewise.
+	(vsx_rsqrte<mode>2): Likewise.
+	(vsx_tsqrt<mode>2_internal): Likewise.
+	(vsx_fms<mode>4): Likewise.
+	(vsx_nfma<mode>4): Likewise.
+	(vsx_eq<mode>): Likewise.
+	(vsx_gt<mode>): Likewise.
+	(vsx_ge<mode>): Likewise.
+	(vsx_eq<mode>_p): Likewise.
+	(vsx_gt<mode>_p): Likewise.
+	(vsx_ge<mode>_p): Likewise.
+	(vsx_xxsel<mode>): Likewise.
+	(vsx_xxsel<mode>_uns): Likewise.
+	(vsx_copysign<mode>3): Likewise.
+	(vsx_float<VSi><mode>2): Likewise.
+	(vsx_floatuns<VSi><mode>2): Likewise.
+	(vsx_fix_trunc<mode><VSi>2): Likewise.
+	(vsx_fixuns_trunc<mode><VSi>2): Likewise.
+	(vsx_x<VSv>r<VSs>i): Likewise.
+	(vsx_x<VSv>r<VSs>ic): Likewise.
+	(vsx_btrunc<mode>2): Likewise.
+	(vsx_b2trunc<mode>2): Likewise.
+	(vsx_floor<mode>2): Likewise.
+	(vsx_ceil<mode>2): Likewise.
+	(vsx_<VS_spdp_insn>): Likewise.
+	(vsx_xscvspdp): Likewise.
+	(vsx_xvcvspuxds): Likewise.
+	(vsx_float_fix_<mode>2): Likewise.
+	(vsx_set_<mode>): Likewise.
+	(vsx_extract_<mode>_internal1): Likewise.
+	(vsx_extract_<mode>_internal2): Likewise.
+	(vsx_extract_<mode>_load): Likewise.
+	(vsx_extract_<mode>_store): Likewise.
+	(vsx_splat_<mode>): Likewise.
+	(vsx_xxspltw_<mode>): Likewise.
+	(vsx_xxspltw_<mode>_direct): Likewise.
+	(vsx_xxmrghw_<mode>): Likewise.
+	(vsx_xxmrglw_<mode>): Likewise.
+	(vsx_xxsldwi_<mode>): Likewise.
+	(vsx_xscvdpspn): Tighten constraints to only use register classes
+	the types use.
+	(vsx_xscvspdpn): Likewise.
+	(vsx_xscvdpspn_scalar): Likewise.
+
+	* config/rs6000/rs6000.h (enum rs6000_reg_class_enum): Add wh, wi,
+	wj, and wk constraints.
+	(GPR_REG_CLASS_P): New helper macro for register classes targeting
+	general purpose registers.
+
+	* config/rs6000/rs6000.md (f32_dm): Use wh constraint for SDmode
+	direct moves.
+	(zero_extendsidi2_lfiwz): Use wj constraint for direct move of
+	DImode instead of wm.  Use wk constraint for direct move of DFmode
+	instead of wm.
+	(extendsidi2_lfiwax): Likewise.
+	(lfiwax): Likewise.
+	(lfiwzx): Likewise.
+	(movdi_internal64): Likewise.
+
+	* doc/md.texi (PowerPC and IBM RS6000): Document wh, wi, wj, and
+	wk constraints. Make the wy constraint documentation match them
+	implementation.
+
+2014-08-12  Ganesh Gopalasubramanian <Ganesh.Gopalasubramanian@amd.com>
+
+	Backport from mainline
+	2014-08-04 Ganesh Gopalasubramanian
+		   <Ganesh.Gopalasubramanian@amd.com>
+
+	* config/i386/i386.c (ix86_option_override_internal): Add
+	PTA_RDRND and PTA_MOVBE for bdver4.
+
+2014-08-12  Ganesh Gopalasubramanian <Ganesh.Gopalasubramanian@amd.com>
+
+	Backport from mainline
+	2014-08-04  Ganesh Gopalasubramanian 
+		    <Ganesh.Gopalasubramanian@amd.com>
+
+	* config/i386/driver-i386.c (host_detect_local_cpu): Handle AMD's extended
+	family information. Handle BTVER2 cpu with cpuid family value.
+
+2014-08-12  Ganesh Gopalasubramanian <Ganesh.Gopalasubramanian@amd.com>
+
+	Backport from mainline
+	2014-06-16  Ganesh Gopalasubramanian 
+		    <Ganesh.Gopalasubramanian@amd.com>
+
+	* config/i386/i386.c (ix86_expand_sse2_mulvxdi3): Issue
+	instructions "vpmuludq" and "vpaddq" instead of "vpmacsdql" for
+	handling 32-bit multiplication.
+
+2014-08-08  Guozhi Wei  <carrot@google.com>
+
+	* config/rs6000/rs6000.md (*movdi_internal64): Add a new constraint.
+
+2014-08-07  Ilya Tocar  <ilya.tocar@intel.com>
+
+	* config/i386/sse.md (vec_extract_lo_<mode><mask_name>): Fix
+	constraint.
+
+2014-08-06  Vladimir Makarov  <vmakarov@redhat.com>
+
+	PR debug/61923
+	* haifa-sched.c (advance_one_cycle): Fix dump.
+	(schedule_block): Don't advance cycle if we are already at the
+	beginning of the cycle.
+
+2014-08-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/61320
+	* tree-ssa-loop-ivopts.c (may_be_unaligned_p): Properly
+	handle misaligned loads.
+
+2014-08-04  Rohit  <rohitarulraj@freescale.com>
+
+	PR target/60102
+	* config/rs6000/rs6000.c
+	(rs6000_reg_names): Add SPE high register names.
+	(alt_reg_names): Likewise.
+	(rs6000_dwarf_register_span): For SPE high registers, replace
+	dwarf register numbers with GCC hard register numbers.
+	(rs6000_init_dwarf_reg_sizes_extra): Likewise.
+	(rs6000_dbx_register_number): For SPE high registers, return dwarf
+	register number for the corresponding GCC hard register number.
+	* config/rs6000/rs6000.h
+	(FIRST_PSEUDO_REGISTER): Update based on 32 newly added GCC hard
+	register numbers for SPE high registers.
+	(DWARF_FRAME_REGISTERS):  Likewise.
+	(DWARF_REG_TO_UNWIND_COLUMN): Likewise.
+	(DWARF_FRAME_REGNUM): Likewise.
+	(FIXED_REGISTERS): Likewise.
+	(CALL_USED_REGISTERS): Likewise.
+	(CALL_REALLY_USED_REGISTERS): Likewise.
+	(REG_ALLOC_ORDER): Likewise.
+	(enum reg_class): Likewise.
+	(REG_CLASS_NAMES): Likewise.
+	(REG_CLASS_CONTENTS): Likewise.
+	(SPE_HIGH_REGNO_P): New macro to identify SPE high registers.
+
+2014-08-01  Vladimir Makarov  <vmakarov@redhat.com>
+
+	* lra-constraints.c (remove_inheritance_pseudos): Process
+	destination pseudo too.
+
+2014-08-01  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2014-06-13  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	PR tree-optimization/61375
+	* tree-ssa-math-opts.c (find_bswap_or_nop_1): Cancel optimization if
+	symbolic number cannot be represented in an unsigned HOST_WIDE_INT.
+	(execute_optimize_bswap): Cancel optimization if CHAR_BIT != 8.
+
+2014-08-01  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/61964
+	* tree-ssa-tail-merge.c (gimple_equal_p): Handle non-SSA LHS solely
+	by structural equality.
+
+2014-07-31  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2014-07-31  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/61844
+	* config/sh/sh.c (sh_legitimate_address_p,
+	sh_legitimize_reload_address): Handle reg+reg address modes when
+	ALLOW_INDEXED_ADDRESS is false.
+	* config/sh/predicates.md (general_movsrc_operand,
+	general_movdst_operand): Likewise.
+
+2014-07-25  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2014-07-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/61656
+	* config/i386/i386.c (classify_argument): Don't merge classes above
+	number of words.
+
+2014-07-25  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/alpha/elf.h: Define TARGET_UNWIND_TABLES_DEFAULT.
+
+2014-07-24  Kyle McMartin  <kyle@redhat.com>
+
+        * config/aarch64/aarch64-linux.h (TARGET_ASM_FILE_END): Define.
+
+2014-07-24  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	* config/rs6000/rs6000-protos.h (rs6000_special_adjust_field_align_p):
+	Add prototype.
+	* config/rs6000/rs6000.c (rs6000_special_adjust_field_align_p): New
+	function.  Issue -Wpsabi warning if future GCC releases will use
+	different field alignment rules for this type.
+	* config/rs6000/sysv4.h (ADJUST_FIELD_ALIGN): Call it.
+	* config/rs6000/linux64.h (ADJUST_FIELD_ALIGN): Likewise.
+	* config/rs6000/freebsd64.h (ADJUST_FIELD_ALIGN): Likewise.
+
+2014-07-24  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	* config/rs6000/rs6000.c (rs6000_function_arg_boundary): Issue
+	-Wpsabi note when encountering a type where future GCC releases
+	will apply different alignment requirements.
+
+2014-07-24  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	* config/rs6000/rs6000.c (rs6000_function_arg): If a float argument
+	does not fit fully into floating-point registers, and there is still
+	space in the register parameter area, issue -Wpsabi note that the ABI
+	will change in a future GCC release.
+
+2014-07-23  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* config/arm/t-rtems-eabi: Add
+	mthumb/march=armv7-r/mfpu=vfpv3-d16/mfloat-abi=hard,
+	mthumb/march=armv7-m/mfpu=fpv4-sp-d16/mfloat-abi=hard,
+	mbig-endian/mthumb/march=armv7-r, and
+	mbig-endian/mthumb/march=armv7-r/mfpu=vfpv3-d16/mfloat-abi=hard
+	multilibs.
+
+2014-07-23  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+	    Chris Johns <chrisj@rtems.org>
+	    Joel Sherrill <joel.sherrill@oarcorp.com>
+
+	* config.gcc: Add nios2-*-rtems*.
+	* config/nios2/rtems.h: New file.
+	* gcc/config/nios2/t-rtems: New file.
+
+2014-07-21  Peter Bergner  <bergner@vnet.ibm.com>
+
+	* config/rs6000/sysv4.h (LIBASAN_EARLY_SPEC): Define.
+	(LIBTSAN_EARLY_SPEC): Likewise.
+
+2014-07-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2014-07-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/61855
+	* config/i386/avx512fintrin.h: Move constants for mantissa extraction
+	out of #ifdef __OPTIMIZE__.
+
+2014-07-20  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* expr.c (store_field): Handle VOIDmode for calls that return values
+	in multiple locations.
+
+2014-07-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* toplev.c (output_stack_usage): Adjust the location of the warning.
+
+2014-07-19  Daniel Cederman  <cederman@gaisler.com>
+
+	* config/sparc/sync.md (*membar_storeload_leon3): New insn.
+	(*membar_storeload): Disable for LEON3.
+
+2014-07-18  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2014-07-16  David Wohlferd  <dw@LimeGreenSocks.com>
+
+	PR target/61662
+	* config/i386/ia32intrin.h: Use __LP64__ to determine size of long.
+
+2014-07-18  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2014-07-18  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/61794
+	* config/i386/sse.md (avx512f_vextract<shuffletype>32x4_1_maskm):
+	Fix instruction constraint.
+	(<mask_codefor>avx512f_vextract<shuffletype>32x4_1<mask_name>): Ditto.
+
+2014-07-17  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2014-07-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/61779
+	* tree-ssa-copy.c (copy_prop_visit_cond_stmt): Always try
+	simplifying a condition.
+
+2014-07-17  Richard Biener  <rguenther@suse.de>
+
+	PR rtl-optimization/61801
+	* sched-deps.c (sched_analyze_2): For ASM_OPERANDS and ASM_INPUT
+	don't set reg_pending_barrier if it appears in a debug-insn.
+
+2014-07-17  Hans-Peter Nilsson  <hp@axis.com>
+
+	Backport from trunk.
+	PR target/61737.
+	* config/cris/cris.c (TARGET_LEGITIMATE_CONSTANT_P)
+	(TARGET_CANNOT_FORCE_CONST_MEM): Define.
+	(cris_cannot_force_const_mem, cris_legitimate_constant_p): New
+	functions.
+	(cris_print_index, cris_print_operand, cris_constant_index_p)
+	(cris_side_effect_mode_ok): Replace CONSTANT_P with CRIS_CONSTANT_P.
+	(cris_address_cost): Ditto last CONSTANT_P.
+	(cris_symbol_type_of): Rename from cris_pic_symbol_type_of.  All
+	callers changed.  Yield cris_offsettable_symbol for non-PIC
+	constant symbolic expressions including labels.  Yield cris_unspec
+	for all unspecs.
+	(cris_expand_pic_call_address): New parameter MARKERP.  Set its
+	target to pic_offset_table_rtx for calls that will likely go
+	through PLT, const0_rtx when they can't.  All callers changed.
+	Assert flag_pic.  Use CONSTANT_P, not CONSTANT_ADDRESS_P, for
+	symbolic expressions to be PICified.  Remove second, redundant,
+	assert on can_create_pseudo_p returning non-zero.  Use
+	replace_equiv_address_nv, not replace_equiv_address, for final
+	operand update.
+	* config/cris/cris.md ("movsi"): Move variable t to pattern
+	toplevel. Adjust assert for new cris_symbol_type member.  Use
+	CONSTANT_P instead of CONSTANT_ADDRESS_P.
+	("*movsi_internal") <case 9>: Make check for valid unspec operands
+	for lapc stricter.
+	<case CRIS_UNSPEC_PCREL, CRIS_UNSPEC_PLT_PCREL>: Clear condition codes.
+	("call", "call_value"): Use second incoming operand as a marker
+	for pic-offset-table-register being used.
+	("*expanded_call_non_v32", "*expanded_call_v32")
+	("*expanded_call_value_non_v32", "*expanded_call_value_v32"): For
+	second incoming operand to CALL, match cris_call_type_marker.
+	("*expanded_call_value_side"): Ditto.  Disable before reload_completed.
+	("*expanded_call_side"): Ditto.  Fix typo in comment.
+	(moverside, movemside peepholes): Check for CRIS_CONSTANT_P, not
+	CONSTANT_P.
+	* config/cris/predicates.md ("cris_call_type_marker"): New predicate.
+	* config/cris/cris.h (CRIS_CONSTANT_P): New macro.
+	(enum cris_symbol_type): Rename from cris_pic_symbol_type.  All
+	users changed.  Add members cris_offsettable_symbol and cris_unspec.
+	(cris_symbol_type): Rename from cris_pic_symbol_type.
+	* config/cris/constraints.md ("T"): Use CRIS_CONSTANT_P, not
+	just CONSTANT_P.
+	* config/cris/cris-protos.h (cris_symbol_type_of,
+	cris_expand_pic_call_address): Adjust prototypes.
+	(cris_legitimate_constant_p): New prototype.
+
+	* config.gcc (crisv32-*-linux* | cris-*-linux*): Do not override
+	an existing tmake_file.  Don't add t-slibgcc and t-linux.
+
+2014-07-16  Jakub Jelinek  <jakub@redhat.com>
+
+	* omp-low.c (create_omp_child_function): Don't set DECL_NAMELESS
+	on the FUNCTION_DECL.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
@@ -4,14 +582,14 @@
 
 2014-07-10  Cary Coutant  <ccoutant@google.com>
 
-        Backport from trunk at r212211.
+	Backport from trunk at r212211.
 
 	* dwarf2out.c (remove_addr_table_entry): Remove unnecessary hash table
-        lookup.
+	lookup.
 	(resolve_addr_in_expr): When replacing the rtx in a location list
-        entry, get a new address table entry.
+	entry, get a new address table entry.
 	(dwarf2out_finish): Call index_location_lists even if there are no
-        addr_index_table entries yet.
+	addr_index_table entries yet.
 
 2014-07-10  Tom G. Christensen  <tgc@jupiterrise.com>
 
@@ -33,13 +611,13 @@
 	PR target/61062
 	* config/arm/arm_neon.h (vtrn_s8, vtrn_s16, vtrn_u8, vtrn_u16, vtrn_p8,
 	vtrn_p16, vtrn_s32, vtrn_f32, vtrn_u32, vtrnq_s8, vtrnq_s16, vtrnq_s32,
-	vtrnq_f32, vtrnq_u8, vtrnq_u16, vtrnq_u32, vtrnq_p8, vtrnq_p16, vzip_s8,
-	vzip_s16, vzip_u8, vzip_u16, vzip_p8, vzip_p16, vzip_s32, vzip_f32,
-	vzip_u32, vzipq_s8, vzipq_s16, vzipq_s32, vzipq_f32, vzipq_u8,
-	vzipq_u16, vzipq_u32, vzipq_p8, vzipq_p16, vuzp_s8, vuzp_s16, vuzp_s32,
-	vuzp_f32, vuzp_u8, vuzp_u16, vuzp_u32, vuzp_p8, vuzp_p16, vuzpq_s8,
-	vuzpq_s16, vuzpq_s32, vuzpq_f32, vuzpq_u8, vuzpq_u16, vuzpq_u32,
-	vuzpq_p8, vuzpq_p16): Correct mask for bigendian.
+	vtrnq_f32, vtrnq_u8, vtrnq_u16, vtrnq_u32, vtrnq_p8, vtrnq_p16,
+	vzip_s8, vzip_s16, vzip_u8, vzip_u16, vzip_p8, vzip_p16, vzip_s32,
+	vzip_f32, vzip_u32, vzipq_s8, vzipq_s16, vzipq_s32, vzipq_f32,
+	vzipq_u8, vzipq_u16, vzipq_u32, vzipq_p8, vzipq_p16, vuzp_s8, vuzp_s16,
+	vuzp_s32, vuzp_f32, vuzp_u8, vuzp_u16, vuzp_u32, vuzp_p8, vuzp_p16,
+	vuzpq_s8, vuzpq_s16, vuzpq_s32, vuzpq_f32, vuzpq_u8, vuzpq_u16,
+	vuzpq_u32, vuzpq_p8, vuzpq_p16): Correct mask for bigendian.
 
 
 2014-07-09  Alan Lawrence  <alan.lawrence@arm.com>
@@ -157,11 +735,9 @@
 	2014-06-24  Jakub Jelinek  <jakub@redhat.com>
 
 	* gimplify.c (gimplify_scan_omp_clauses) <case OMP_CLAUSE_MAP,
-	OMP_CLAUSE_TO, OMP_CLAUSE_FROM): Make sure OMP_CLAUSE_SIZE is
-	non-NULL.
+	OMP_CLAUSE_TO, OMP_CLAUSE_FROM): Make sure OMP_CLAUSE_SIZE is non-NULL.
 	<case OMP_CLAUSE_ALIGNED>: Gimplify OMP_CLAUSE_ALIGNED_ALIGNMENT.
-	(gimplify_adjust_omp_clauses_1): Make sure OMP_CLAUSE_SIZE is
-	non-NULL.
+	(gimplify_adjust_omp_clauses_1): Make sure OMP_CLAUSE_SIZE is non-NULL.
 	(gimplify_adjust_omp_clauses): Likewise.
 	* omp-low.c (lower_rec_simd_input_clauses,
 	lower_rec_input_clauses, expand_omp_simd): Handle non-constant
@@ -176,9 +752,8 @@
 
 	2014-06-18  Jakub Jelinek  <jakub@redhat.com>
 
-	* gimplify.c (omp_notice_variable): If n is non-NULL
-	and no flags change in ORT_TARGET region, don't jump to
-	do_outer.
+	* gimplify.c (omp_notice_variable): If n is non-NULL and no flags
+	change in ORT_TARGET region, don't jump to do_outer.
 	(struct gimplify_adjust_omp_clauses_data): New type.
 	(gimplify_adjust_omp_clauses_1): Adjust for data being
 	a struct gimplify_adjust_omp_clauses_data pointer instead
@@ -196,14 +771,12 @@
 	gimple_seq * argument to omp_finish_clause hook.
 	* omp-low.c (scan_sharing_clauses): Call scan_omp_op on
 	non-DECL_P OMP_CLAUSE_DECL if ctx->outer.
-	(scan_omp_parallel, lower_omp_for): When adding
-	_LOOPTEMP_ clause var, add it to outer ctx's decl_map
-	as identity.
+	(scan_omp_parallel, lower_omp_for): When adding _LOOPTEMP_ clause var,
+	add it to outer ctx's decl_map as identity.
 	* tree-core.h (OMP_CLAUSE_MAP_TO_PSET): New map kind.
 	* tree-nested.c (convert_nonlocal_omp_clauses,
 	convert_local_omp_clauses): Handle various OpenMP 4.0 clauses.
-	* tree-pretty-print.c (dump_omp_clause): Handle
-	OMP_CLAUSE_MAP_TO_PSET.
+	* tree-pretty-print.c (dump_omp_clause): Handle OMP_CLAUSE_MAP_TO_PSET.
 
 	2014-06-10  Jakub Jelinek  <jakub@redhat.com>
 
@@ -227,8 +800,7 @@
 	OMP_CLAUSE_LINEAR_STMT.
 	* omp-low.c (lower_rec_input_clauses): Fix typo.
 	(maybe_add_implicit_barrier_cancel, lower_omp_1): Add
-	cast between Fortran boolean_type_node and C _Bool if
-	needed.
+	cast between Fortran boolean_type_node and C _Bool if needed.
 
 2014-06-30  Jason Merrill  <jason@redhat.com>
 
@@ -279,8 +851,7 @@
 	(aarch64_sqdmlsl_lane<mode>): Likewise.
 	(aarch64_sqdmull_lane<mode>): Likewise.
 	(aarch64_sqdmull2_lane<mode>): Likewise.
-	(aarch64_sqdmlal_laneq<mode>):
-	Replace VCON usage with VCONQ.
+	(aarch64_sqdmlal_laneq<mode>): Replace VCON usage with VCONQ.
 	Emit aarch64_sqdmlal_laneq<mode>_internal insn.
 	(aarch64_sqdmlal2_laneq<mode>): Emit
 	aarch64_sqdmlal2_laneq<mode>_internal insn.
Index: gcc/testsuite/gcc.target/powerpc/ppc64-abi-warn-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/ppc64-abi-warn-1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/ppc64-abi-warn-1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,12 @@
+/* { dg-do compile { target { powerpc*-*-linux* && lp64 } } } */
+/* { dg-options "-mabi=elfv2" } */
+
+struct f8
+  {
+    float x[8];
+  };
+
+void test (struct f8 a, struct f8 b) /* { dg-message "note: the ABI of passing homogeneous float aggregates will change" } */
+{
+}
+
Index: gcc/testsuite/gcc.target/powerpc/ppc64-abi-warn-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/ppc64-abi-warn-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/ppc64-abi-warn-2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,11 @@
+/* { dg-do compile { target { powerpc*-*-linux* && lp64 } } } */
+
+struct test
+  {
+    long a __attribute__((aligned (16)));
+  };
+
+void test (struct test a) /* { dg-message "note: the ABI of passing aggregates with 16-byte alignment will change" } */
+{
+}
+
Index: gcc/testsuite/gcc.target/powerpc/pr60102.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr60102.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr60102.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-skip-if "not an SPE target" { ! powerpc_spe_nocache } { "*" } { "" } } */
+/* { dg-options "-mcpu=8548 -mspe -mabi=spe -g -mfloat-gprs=double" } */
+
+double
+pr60102 (double x, int m)
+{
+  double y;
+  y =  m % 2 ? x : 1;
+  return y;
+}
Index: gcc/testsuite/gcc.target/powerpc/ppc64-abi-warn-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/ppc64-abi-warn-3.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/ppc64-abi-warn-3.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,9 @@
+/* { dg-do compile { target { powerpc*-*-linux* && lp64 } } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-maltivec" } */
+
+struct test
+  {
+    int a __attribute__((vector_size (8)));
+  }; /* { dg-message "note: the layout of aggregates containing vectors with 8-byte alignment will change" } */
+
Index: gcc/testsuite/gcc.target/arm/pr59985.C
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/pr59985.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/arm/pr59985.C	(.../branches/gcc-4_9-branch)
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-skip-if "incompatible options" { arm_thumb1 } { "*" } { "" } } */
 /* { dg-options "-g -fcompare-debug -O2 -march=armv7-a -mtune=cortex-a9 -mfpu=vfpv3-d16 -mfloat-abi=hard" } */
 
 extern void *f1 (unsigned long, unsigned long);
Index: gcc/testsuite/gcc.target/arm/thumb-find-work-register.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/thumb-find-work-register.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/arm/thumb-find-work-register.c	(.../branches/gcc-4_9-branch)
@@ -1,5 +1,6 @@
 /* Wrong method to get number of arg reg will cause argument corruption.  */
 /* { dg-do run } */
+/* { dg-skip-if "incompatible options" { ! { arm_thumb1_ok || arm_thumb2_ok } } { "*" } { "" } } */
 /* { dg-require-effective-target arm_eabi } */
 /* { dg-options "-mthumb -O1" } */
 
Index: gcc/testsuite/gcc.target/arm/pr58784.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/pr58784.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/arm/pr58784.c	(.../branches/gcc-4_9-branch)
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-skip-if "incompatible options" { arm_thumb1 } { "*" } { "" } } */
 /* { dg-options "-march=armv7-a -mfloat-abi=hard -mfpu=neon -marm -O2" } */
 
 typedef struct __attribute__ ((__packed__))
Index: gcc/testsuite/gcc.target/arm/pr59896.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/pr59896.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/arm/pr59896.c	(.../branches/gcc-4_9-branch)
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-skip-if "incompatible options" { ! { arm_thumb1_ok || arm_thumb2_ok } } { "*" } { "" } } */
 /* { dg-options "-mthumb -O2" } */
 
 typedef unsigned int size_t;
Index: gcc/testsuite/gcc.target/arm/frame-pointer-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/frame-pointer-1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/arm/frame-pointer-1.c	(.../branches/gcc-4_9-branch)
@@ -1,6 +1,7 @@
 /* Check local register variables using a register conventionally 
    used as the frame pointer aren't clobbered under high register pressure.  */
 /* { dg-do run } */
+/* { dg-skip-if "incompatible options" { ! { arm_thumb1_ok || arm_thumb2_ok } } { "*" } { "" } } */
 /* { dg-options "-Os -mthumb -fomit-frame-pointer" } */
 
 #include <stdlib.h>
Index: gcc/testsuite/gcc.target/arm/stack-red-zone.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/stack-red-zone.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/arm/stack-red-zone.c	(.../branches/gcc-4_9-branch)
@@ -1,4 +1,5 @@
 /* No stack red zone.  PR38644.  */
+/* { dg-skip-if "incompatible options" { ! { arm_thumb1_ok || arm_thumb2_ok } } { "*" } { "" } } */
 /* { dg-options "-mthumb -O2" } */
 /* { dg-final { scan-assembler "ldrb\[^\n\]*\\n\[\t \]*add\[\t \]*sp" } } */
 
Index: gcc/testsuite/gcc.target/arm/neon-vext-execute.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/neon-vext-execute.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/arm/neon-vext-execute.c	(.../branches/gcc-4_9-branch)
@@ -1,5 +1,6 @@
 /* { dg-do run } */
 /* { dg-require-effective-target arm_neon_ok } */
+/* { dg-require-effective-target arm_neon_hw } */
 /* { dg-require-effective-target arm_little_endian } */
 /* { dg-options "-O2" } */
 /* { dg-add-options arm_neon } */
Index: gcc/testsuite/gcc.target/arm/pr56184.C
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/pr56184.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/arm/pr56184.C	(.../branches/gcc-4_9-branch)
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-skip-if "incompatible options" { ! { arm_thumb1_ok || arm_thumb2_ok } } { "*" } { "" } } */
 /* { dg-options "-fno-short-enums -O2 -mthumb -march=armv7-a -mfpu=neon -mfloat-abi=softfp -mtune=cortex-a9 -fno-section-anchors" } */
 
 typedef unsigned int size_t;
Index: gcc/testsuite/gcc.target/i386/avx512f-vpermt2pd-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx512f-vpermt2pd-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx512f-vpermt2pd-2.c	(.../branches/gcc-4_9-branch)
@@ -9,7 +9,6 @@
 #define SIZE (AVX512F_LEN / 64)
 #include "avx512f-mask-type.h"
 #include "math.h"
-#include "values.h"
 
 static void
 CALC (double *dst, double *src1, long long *ind, double *src2)
Index: gcc/testsuite/gcc.target/i386/avx512f-vpermt2d-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx512f-vpermt2d-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx512f-vpermt2d-2.c	(.../branches/gcc-4_9-branch)
@@ -9,7 +9,6 @@
 #define SIZE (AVX512F_LEN / 32)
 #include "avx512f-mask-type.h"
 #include "math.h"
-#include "values.h"
 
 static void
 CALC (int *dst, int *src1, int *ind, int *src2)
Index: gcc/testsuite/gcc.target/i386/avx512f-vpermi2q-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx512f-vpermi2q-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx512f-vpermi2q-2.c	(.../branches/gcc-4_9-branch)
@@ -9,7 +9,6 @@
 #define SIZE (AVX512F_LEN / 64)
 #include "avx512f-mask-type.h"
 #include "math.h"
-#include "values.h"
 
 static void
 CALC (long long *dst, long long *src1, long long *ind, long long *src2)
Index: gcc/testsuite/gcc.target/i386/pr61923.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr61923.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr61923.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,36 @@
+/* PR debug/61923 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fcompare-debug" } */
+
+typedef struct
+{
+  struct
+  {
+    struct
+    {
+      char head;
+    } tickets;
+  };
+} arch_spinlock_t;
+struct ext4_map_blocks
+{
+  int m_lblk;
+  int m_len;
+  int m_flags;
+};
+int ext4_da_map_blocks_ei_0;
+void fn1 (int p1, struct ext4_map_blocks *p2)
+{
+  int ret;
+  if (p2->m_flags)
+    {
+      ext4_da_map_blocks_ei_0++;
+      arch_spinlock_t *lock;
+      switch (sizeof *&lock->tickets.head)
+      case 1:
+      asm("" : "+m"(*&lock->tickets.head) : ""(0));
+      __asm__("");
+      ret = 0;
+    }
+  fn2 (p2->m_lblk, p2->m_len);
+}
Index: gcc/testsuite/gcc.target/i386/xop-imul64-vector.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/xop-imul64-vector.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/xop-imul64-vector.c	(.../branches/gcc-4_9-branch)
@@ -33,4 +33,3 @@
 
 /* { dg-final { scan-assembler "vpmulld" } } */
 /* { dg-final { scan-assembler "vphadddq" } } */
-/* { dg-final { scan-assembler "vpmacsdql" } } */
Index: gcc/testsuite/gcc.target/i386/avx512f-vpermi2d-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx512f-vpermi2d-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx512f-vpermi2d-2.c	(.../branches/gcc-4_9-branch)
@@ -9,7 +9,6 @@
 #define SIZE (AVX512F_LEN / 32)
 #include "avx512f-mask-type.h"
 #include "math.h"
-#include "values.h"
 
 static void
 CALC (int *dst, int *src1, int *ind, int *src2)
Index: gcc/testsuite/gcc.target/i386/pr61855.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr61855.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr61855.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-mavx512f" } */
+
+#include <x86intrin.h>
+
+__m512 test (__m512 x)
+{
+  return _mm512_getmant_ps(x, _MM_MANT_NORM_1_2, _MM_MANT_SIGN_zero);
+}
+
Index: gcc/testsuite/gcc.target/i386/avx512f-vfixupimmss-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx512f-vfixupimmss-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx512f-vfixupimmss-2.c	(.../branches/gcc-4_9-branch)
@@ -6,7 +6,7 @@
 #include "avx512f-check.h"
 #include "avx512f-helper.h"
 #include <math.h>
-#include <values.h>
+#include <float.h>
 #include "avx512f-mask-type.h"
 
 void
@@ -57,10 +57,10 @@
       *r = M_PI_2;
       break;
     case 14:
-      *r = MAXFLOAT;
+      *r = FLT_MAX;
       break;
     case 15:
-      *r = -MAXFLOAT;
+      *r = -FLT_MAX;
       break;
     default:
       abort ();
Index: gcc/testsuite/gcc.target/i386/pr61801.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr61801.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr61801.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,21 @@
+/* PR rtl-optimization/61801 */
+/* { dg-do compile } */
+/* { dg-options "-Os -fcompare-debug" } */
+
+int a, c;
+int bar (void);
+void baz (void);
+
+void
+foo (void)
+{
+  int d;
+  if (bar ())
+    {
+      int e;
+      baz ();
+      asm volatile ("" : "=a" (e) : "0" (a), "i" (0));
+      d = e;
+    }
+  c = d;
+}
Index: gcc/testsuite/gcc.target/i386/avx512f-vfixupimmsd-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx512f-vfixupimmsd-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx512f-vfixupimmsd-2.c	(.../branches/gcc-4_9-branch)
@@ -6,7 +6,7 @@
 #include "avx512f-check.h"
 #include "avx512f-helper.h"
 #include <math.h>
-#include <values.h>
+#include <float.h>
 #include "avx512f-mask-type.h"
 
 void
@@ -57,10 +57,10 @@
       *r = M_PI_2;
       break;
     case 14:
-      *r = MAXDOUBLE;
+      *r = DBL_MAX;
       break;
     case 15:
-      *r = -MAXDOUBLE;
+      *r = -DBL_MAX;
       break;
     default:
       abort ();
Index: gcc/testsuite/gcc.target/i386/avx512f-vpermi2ps-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx512f-vpermi2ps-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx512f-vpermi2ps-2.c	(.../branches/gcc-4_9-branch)
@@ -9,7 +9,6 @@
 #define SIZE (AVX512F_LEN / 32)
 #include "avx512f-mask-type.h"
 #include "math.h"
-#include "values.h"
 
 static void
 CALC (float *dst, float *src1, int *ind, float *src2)
Index: gcc/testsuite/gcc.target/i386/avx512f-vpermi2pd-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx512f-vpermi2pd-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx512f-vpermi2pd-2.c	(.../branches/gcc-4_9-branch)
@@ -9,7 +9,6 @@
 #define SIZE (AVX512F_LEN / 64)
 #include "avx512f-mask-type.h"
 #include "math.h"
-#include "values.h"
 
 static void
 CALC (double *dst, double *src1, long long *ind, double *src2)
Index: gcc/testsuite/gcc.target/i386/pr61794.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr61794.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr61794.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-mavx512f" } */
+
+#include <x86intrin.h>
+
+__m512i zmm;
+__m128i xmm;
+
+void test (void)
+{
+  xmm = _mm512_extracti32x4_epi32 (zmm, 0);
+}
Index: gcc/testsuite/gcc.target/i386/avx512f-vfixupimmps-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx512f-vfixupimmps-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx512f-vfixupimmps-2.c	(.../branches/gcc-4_9-branch)
@@ -10,7 +10,7 @@
 #define SIZE (AVX512F_LEN / 32)
 #include "avx512f-mask-type.h"
 #include "math.h"
-#include "values.h"
+#include "float.h"
 
 static void
 CALC (float *r, float src, int tbl)
@@ -60,10 +60,10 @@
       *r = M_PI_2;
       break;
     case 14:
-      *r = MAXFLOAT;
+      *r = FLT_MAX;
       break;
     case 15:
-      *r = -MAXFLOAT;
+      *r = -FLT_MAX;
       break;
     default:
       abort ();
Index: gcc/testsuite/gcc.target/i386/avx512f-vpermt2q-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx512f-vpermt2q-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx512f-vpermt2q-2.c	(.../branches/gcc-4_9-branch)
@@ -9,7 +9,6 @@
 #define SIZE (AVX512F_LEN / 64)
 #include "avx512f-mask-type.h"
 #include "math.h"
-#include "values.h"
 
 static void
 CALC (long long *dst, long long *src1, long long *ind, long long *src2)
Index: gcc/testsuite/gcc.target/i386/avx512f-vfixupimmpd-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx512f-vfixupimmpd-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx512f-vfixupimmpd-2.c	(.../branches/gcc-4_9-branch)
@@ -10,8 +10,9 @@
 #define SIZE (AVX512F_LEN / 64)
 #include "avx512f-mask-type.h"
 #include "math.h"
-#include "values.h"
+#include "float.h"
 
+
 static void
 CALC (double *r, double src, long long tbl)
 {
@@ -60,10 +61,10 @@
       *r = M_PI_2;
       break;
     case 14:
-      *r = MAXDOUBLE;
+      *r = DBL_MAX;
       break;
     case 15:
-      *r = -MAXDOUBLE;
+      *r = -DBL_MAX;
       break;
     default:
       abort ();
Index: gcc/testsuite/gcc.target/i386/avx512f-vpermt2ps-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx512f-vpermt2ps-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx512f-vpermt2ps-2.c	(.../branches/gcc-4_9-branch)
@@ -9,7 +9,6 @@
 #define SIZE (AVX512F_LEN / 32)
 #include "avx512f-mask-type.h"
 #include "math.h"
-#include "values.h"
 
 static void
 CALC (float *dst, float *src1, int *ind, float *src2)
Index: gcc/testsuite/gcc.target/mips/pr62030-octeon.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/mips/pr62030-octeon.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/mips/pr62030-octeon.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,50 @@
+/* { dg-do run } */
+/* { dg-options "-march=octeon" } */
+
+extern void abort (void);
+
+struct node
+{
+  struct node *next;
+  struct node *prev;
+};
+
+struct node node;
+
+struct head
+{
+  struct node *first;
+};
+
+struct head heads[5];
+
+int k = 2;
+
+struct head *head = &heads[2];
+
+static int __attribute__((noinline))
+foo (void)
+{
+  node.prev = (void *)head;
+  head->first = &node;
+
+  struct node *n = head->first;
+  struct head *h = &heads[k];
+  struct node *next = n->next;
+
+  if (n->prev == (void *)h)
+    h->first = next;
+  else
+    n->prev->next = next;
+
+  n->next = h->first;
+  return n->next == &node;
+}
+
+int
+main (void)
+{
+  if (foo ())
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/lib/target-supports.exp
===================================================================
--- a/src/gcc/testsuite/lib/target-supports.exp	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/lib/target-supports.exp	(.../branches/gcc-4_9-branch)
@@ -2564,6 +2564,9 @@
     if { [check_effective_target_arm32] } {
 	foreach flags {"" "-mfloat-abi=softfp" "-mfpu=neon-fp-armv8" "-mfpu=neon-fp-armv8 -mfloat-abi=softfp"} {
 	    if { [check_no_compiler_messages_nocache arm_v8_neon_ok object {
+		#if __ARM_ARCH < 8
+		#error not armv8 or later
+		#endif
 		#include "arm_neon.h"
 		void
 		foo ()
@@ -2570,7 +2573,7 @@
 		{
 	          __asm__ volatile ("vrintn.f32 q0, q0");
 		}
-	    } "$flags"] } {
+	    } "$flags -march=armv8-a"] } {
 		set et_arm_v8_neon_flags $flags
 		return 1
 	    }
@@ -2747,6 +2750,7 @@
 	#if !defined(__arm__) || !defined(__thumb__) || defined(__thumb2__)
 	#error FOO
 	#endif
+	int foo (int i) { return i; }
     } "-mthumb"]
 }
 
@@ -2758,6 +2762,7 @@
 	#if !defined(__thumb2__)
 	#error FOO
 	#endif
+	int foo (int i) { return i; }
     } "-mthumb"]
 }
 
Index: gcc/testsuite/gfortran.dg/dot_product_3.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/dot_product_3.f90	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gfortran.dg/dot_product_3.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,15 @@
+! { dg-do compile }
+! { dg-options "-fdump-tree-original" }
+! PR 61999 - this used to ICE.
+! Original test case by A. Kasahara
+program main
+   use, intrinsic:: iso_fortran_env, only: output_unit
+
+   implicit none
+
+   write(output_unit, *) dot_product([1, 2], [2.0, 3.0])
+
+   stop
+end program main
+! { dg-final { scan-tree-dump-times "8\\.0e\\+0" 1 "original" } }
+! { dg-final { cleanup-tree-dump "original" } }
Index: gcc/testsuite/gfortran.dg/gomp/pr62131.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/gomp/pr62131.f90	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gfortran.dg/gomp/pr62131.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,19 @@
+! PR fortran/62131
+! { dg-do compile }
+! { dg-options "-fopenmp" }
+
+program pr62131
+  integer,allocatable :: nerrs(:,:)
+  allocate(nerrs(10,10))
+  nerrs(:,:) = 0
+!$omp parallel do
+  do k=1,10
+    call uperrs(k,1)
+  end do
+contains
+  subroutine uperrs(i,io)
+    integer,intent(in) :: i,io
+!$omp atomic
+    nerrs(i,io)=nerrs(i,io)+1
+  end subroutine
+end
Index: gcc/testsuite/gfortran.dg/dependency_44.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/dependency_44.f90	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gfortran.dg/dependency_44.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,36 @@
+! { dg-do run }
+! Tests fix for PR61780 in which the loop reversal mechanism was
+! not accounting for the first index being an element so that no
+! loop in this dimension is created.
+!
+! Contributed by Manfred Tietze on clf.
+!
+program prgm3
+    implicit none
+    integer, parameter :: n = 10, k = 3
+    integer :: i, j
+    integer, dimension(n,n) :: y
+    integer :: res1(n), res2(n)
+
+1   format(10i5)
+
+!initialize
+    do i=1,n
+        do j=1,n
+            y(i,j) = n*i + j
+        end do
+    end do
+    res2 = y(k,:)
+
+!shift right
+    y(k,4:n) = y(k,3:n-1)
+    y(k,3) = 0
+    res1 = y(k,:)
+    y(k,:) = res2
+    y(k,n:4:-1) = y(k,n-1:3:-1)
+    y(k,3) = 0
+    res2 = y(k,:)
+!    print *, res1
+!    print *, res2
+    if (any(res1 /= res2)) call abort ()
+end program prgm3
Index: gcc/testsuite/gfortran.dg/array_constructor_49.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/array_constructor_49.f90	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gfortran.dg/array_constructor_49.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,13 @@
+! { dg-do run }
+! { dg-options "-ffrontend-optimize -fdump-tree-original" }
+! PR 62106 - this used to give wrong results because
+! of a bogus extra temporary variable.
+! Original test case by Martien Hulsen
+program t
+  integer :: ndim=2, ndfp=4, i
+  character (len=8) :: line
+  write (unit=line,fmt='(4I2)'), (/ ( i, i = 1, ndfp ) /) + ndim
+  if (line /= ' 3 4 5 6') call abort
+end program t
+! { dg-final { scan-tree-dump-times "__var" 3 "original" } }
+! { dg-final { cleanup-tree-dump "original" } }
Index: gcc/testsuite/gfortran.dg/array_assignment_5.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/array_assignment_5.f90	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gfortran.dg/array_assignment_5.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,16 @@
+! { dg-do run }
+! { dg-options "-ffrontend-optimize" }
+! PR 62214 - this used to give the wrong result.
+! Original test case by Oliver Fuhrer
+PROGRAM test
+  IMPLICIT NONE
+  CHARACTER(LEN=20)   :: fullNames(2)
+  CHARACTER(LEN=255)  :: pathName
+  CHARACTER(LEN=5)    :: fileNames(2)
+  
+  pathName = "/dir1/dir2/"
+  fileNames = (/ "file1", "file2" /)
+  fullNames = SPREAD(TRIM(pathName),1,2) // fileNames
+  if (fullNames(1) /= '/dir1/dir2/file1' .or. &
+       & fullnames(2) /= '/dir1/dir2/file2') call abort
+END PROGRAM test
Index: gcc/testsuite/gfortran.dg/pr45636.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr45636.f90	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr45636.f90	(.../branches/gcc-4_9-branch)
@@ -10,5 +10,5 @@
   b = y
   call sub(a, b)
 end program main
-! { dg-final { scan-tree-dump-times "memset" 0 "forwprop2" { xfail { mips*-*-* && { ! nomips16 } } } } }
+! { dg-final { scan-tree-dump-times "memset" 0 "forwprop2" { xfail { { hppa*-*-* && { ! lp64 } } || { mips*-*-* && { ! nomips16 } } } } } }
 ! { dg-final { cleanup-tree-dump "forwprop2" } }
Index: gcc/testsuite/gfortran.dg/realloc_on_assign_24.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/realloc_on_assign_24.f90	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gfortran.dg/realloc_on_assign_24.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,10 @@
+! { dg-do compile }
+! PR 62142 - this used to segfault
+! Original test case by Ondej ertk .
+program test_segfault
+  implicit none
+  real, allocatable :: X(:)
+  allocate (x(1))
+  x = 1.
+  X = floor(X)
+end program
Index: gcc/testsuite/gcc.c-torture/execute/pr23135.x
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr23135.x	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr23135.x	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,2 @@
+set additional_flags "-Wno-psabi"
+return 0
Index: gcc/testsuite/gcc.c-torture/execute/bitfld-6.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/bitfld-6.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/bitfld-6.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,23 @@
+union U
+{
+  const int a;
+  unsigned b : 20;
+};
+
+static union U u = { 0x12345678 };
+
+/* Constant folding used to fail to account for endianness when folding a
+   union.  */
+
+int
+main (void)
+{
+#ifdef __BYTE_ORDER__
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+  return u.b - 0x45678;
+#else
+  return u.b - 0x12345;
+#endif
+#endif
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/20050604-1.x
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/20050604-1.x	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/20050604-1.x	(.../branches/gcc-4_9-branch)
@@ -6,4 +6,5 @@
 	set additional_flags "-mno-mmx"
 }
 
+set additional_flags "-Wno-psabi"
 return 0
Index: gcc/testsuite/gcc.c-torture/execute/pr61375.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr61375.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr61375.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,35 @@
+#ifdef __UINT64_TYPE__
+typedef __UINT64_TYPE__ uint64_t;
+#else
+typedef unsigned long long uint64_t;
+#endif
+
+#ifndef __SIZEOF_INT128__
+#define __int128 long long
+#endif
+
+/* Some version of bswap optimization would ICE when analyzing a mask constant
+   too big for an HOST_WIDE_INT (PR61375).  */
+
+__attribute__ ((noinline, noclone)) uint64_t
+uint128_central_bitsi_ior (unsigned __int128 in1, uint64_t in2)
+{
+  __int128 mask = (__int128)0xffff << 56;
+  return ((in1 & mask) >> 56) | in2;
+}
+
+int
+main (int argc)
+{
+  __int128 in = 1;
+#ifdef __SIZEOF_INT128__
+  in <<= 64;
+#endif
+  if (sizeof (uint64_t) * __CHAR_BIT__ != 64)
+    return 0;
+  if (sizeof (unsigned __int128) * __CHAR_BIT__ != 128)
+    return 0;
+  if (uint128_central_bitsi_ior (in, 2) != 0x102)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/20050316-1.x
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/20050316-1.x	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/20050316-1.x	(.../branches/gcc-4_9-branch)
@@ -4,4 +4,5 @@
 	return 1
 }
 
+set additional_flags "-Wno-psabi"
 return 0;
Index: gcc/testsuite/gcc.c-torture/execute/20050316-3.x
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/20050316-3.x	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/20050316-3.x	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,2 @@
+set additional_flags "-Wno-psabi"
+return 0
Index: gcc/testsuite/gcc.c-torture/compile/pr60655-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr60655-1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr60655-1.c	(.../branches/gcc-4_9-branch)
@@ -1,4 +1,4 @@
-/* { dg-options "-fdata-sections" } */
+/* { dg-options "-fdata-sections" { target { ! { { hppa*-*-hpux* } && { ! lp64 } } } } } */
 
 typedef unsigned char unit;
 typedef unit *unitptr;
Index: gcc/testsuite/gnat.dg/pack20.adb
===================================================================
--- a/src/gcc/testsuite/gnat.dg/pack20.adb	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gnat.dg/pack20.adb	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,9 @@
+package body Pack20 is
+
+   procedure Proc (A : Rec) is
+      Local : Rec := A;
+   begin
+      Modify (Local.Fixed);
+   end;
+
+end Pack20;
Index: gcc/testsuite/gnat.dg/pack20.ads
===================================================================
--- a/src/gcc/testsuite/gnat.dg/pack20.ads	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gnat.dg/pack20.ads	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,15 @@
+-- { dg-do compile }
+
+with Pack20_Pkg; use Pack20_Pkg;
+
+package Pack20 is
+
+   type Rec is record
+      Simple_Type  : Integer;
+      Fixed        : String_Ptr;
+   end record;
+   pragma Pack (Rec);
+
+   procedure Proc (A : Rec);
+
+end Pack20;
Index: gcc/testsuite/gnat.dg/pack20_pkg.ads
===================================================================
--- a/src/gcc/testsuite/gnat.dg/pack20_pkg.ads	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gnat.dg/pack20_pkg.ads	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,7 @@
+package Pack20_Pkg is
+
+   type String_Ptr is access all String;
+
+   procedure Modify (Fixed : in out String_Ptr);
+
+end Pack20_Pkg;
Index: gcc/testsuite/gcc.dg/pr61756.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr61756.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/pr61756.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,14 @@
+/* PR target/61756  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+#include <stdatomic.h>
+
+static volatile atomic_flag guard = ATOMIC_FLAG_INIT;
+
+void
+try_atomic_flag_test_and_set (void)
+{
+  atomic_flag_test_and_set (&guard);
+}
Index: gcc/testsuite/gcc.dg/pr59418.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr59418.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/pr59418.c	(.../branches/gcc-4_9-branch)
@@ -3,7 +3,7 @@
 
 /* { dg-do compile } */
 /* { dg-options "-Os -g" } */
-/* { dg-options "-march=armv7-a -mfloat-abi=hard -Os -g" { target arm*-*-* } } */
+/* { dg-options "-march=armv7-a -mfloat-abi=hard -Os -g" { target { arm*-*-* && { ! arm_thumb1 } } } } */
 
 extern int printf (const char *__format, ...);
 
Index: gcc/testsuite/gcc.dg/pr62004.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr62004.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/pr62004.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,47 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -fno-tree-tail-merge" } */
+
+struct node
+{
+  struct node *next;
+  struct node *prev;
+};
+
+struct node node;
+
+struct head
+{
+  struct node *first;
+};
+
+struct head heads[5];
+
+int k = 2;
+
+struct head *head = &heads[2];
+
+int
+main ()
+{
+  struct node *p;
+
+  node.next = (void*)0;
+
+  node.prev = (void *)head;
+
+  head->first = &node;
+
+  struct node *n = head->first;
+
+  struct head *h = &heads[k];
+
+  heads[2].first = n->next;
+
+  if ((void*)n->prev == (void *)h)
+    p = h->first;
+  else
+    /* Dead tbaa-unsafe load from ((struct node *)&heads[2])->next.  */
+    p = n->prev->next;
+
+  return !(p == (void*)0);
+}
Index: gcc/testsuite/gcc.dg/pr51879-18.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr51879-18.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/pr51879-18.c	(.../branches/gcc-4_9-branch)
@@ -13,5 +13,5 @@
     *q = foo ();
 }
 
-/* { dg-final { scan-tree-dump-times "foo \\(" 1 "pre"} } */
+/* { dg-final { scan-tree-dump-times "foo \\(" 1 "pre" { xfail *-*-* } } } */
 /* { dg-final { cleanup-tree-dump "pre" } } */
Index: gcc/testsuite/gcc.dg/lto/pr60449_0.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/lto/pr60449_0.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/lto/pr60449_0.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,30 @@
+/* { dg-lto-do link } */
+
+extern int printf (const char *__restrict __format, ...);
+typedef long int __time_t;
+typedef long int __suseconds_t;
+
+struct timeval
+  {
+    __time_t tv_sec;
+    __suseconds_t tv_usec;
+  };
+
+struct timezone
+  {
+    int tz_minuteswest;
+    int tz_dsttime;
+  };
+typedef struct timezone *__restrict __timezone_ptr_t;
+
+extern int gettimeofday (struct timeval *__restrict __tv, __timezone_ptr_t __tz);
+
+int bar (void)
+{
+  struct timeval tv;
+  struct timezone tz;
+
+  gettimeofday (&tv, &tz);
+  printf ("This is from bar %i\n", tz.tz_dsttime);
+  return 5;
+}
Index: gcc/testsuite/gcc.dg/lto/pr60449_1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/lto/pr60449_1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/lto/pr60449_1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,76 @@
+extern int printf (const char *__restrict __format, ...);
+typedef long int __time_t;
+typedef long int __suseconds_t;
+struct timeval
+  {
+    __time_t tv_sec;
+    __suseconds_t tv_usec;
+  };
+struct timezone
+  {
+    int tz_minuteswest;
+    int tz_dsttime;
+  };
+typedef struct timezone *__restrict __timezone_ptr_t;
+extern int gettimeofday (struct timeval *__restrict __tv,
+    __timezone_ptr_t __tz) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
+
+typedef long int __jmp_buf[8];
+typedef struct
+  {
+    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
+  } __sigset_t;
+struct __jmp_buf_tag
+  {
+    __jmp_buf __jmpbuf;
+    int __mask_was_saved;
+    __sigset_t __saved_mask;
+  };
+typedef struct __jmp_buf_tag jmp_buf[1];
+
+extern int setjmp (jmp_buf __env) __attribute__ ((__nothrow__));
+extern void longjmp (struct __jmp_buf_tag __env[1], int __val)
+     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
+
+extern int bar (void);
+
+int __attribute__ ((noinline, noclone))
+get_input (void)
+{
+  return 0;
+}
+
+static jmp_buf buf;
+
+int foo (void)
+{
+  if (get_input ())
+    longjmp(buf, 1);
+  return 0;
+}
+
+volatile int z;
+
+
+int main (void)
+{
+  struct timeval tv;
+  struct timezone tz;
+
+  bar();
+  if (setjmp (buf))
+    return 1;
+
+  if (!get_input ())
+    {
+      gettimeofday (&tv, &tz);
+      z = 0;
+      printf ("This is from main %i\n", tz.tz_dsttime);
+    }
+
+  foo ();
+  bar ();
+  bar ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr57233.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr57233.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/pr57233.c	(.../branches/gcc-4_9-branch)
@@ -1,6 +1,7 @@
 /* PR tree-optimization/57233 */
 /* { dg-do run { target { ilp32 || lp64 } } } */
 /* { dg-options "-O2" } */
+/* { dg-additional-options "-fno-common" { target hppa*-*-hpux* } } */
 
 typedef unsigned V4 __attribute__((vector_size(4 * sizeof (int))));
 typedef unsigned V8 __attribute__((vector_size(8 * sizeof (int))));
Index: gcc/testsuite/gcc.dg/atomic/c11-atomic-exec-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/atomic/c11-atomic-exec-4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/atomic/c11-atomic-exec-4.c	(.../branches/gcc-4_9-branch)
@@ -2,7 +2,7 @@
    operating properly when operations on the same variable are carried
    out in two threads.  */
 /* { dg-do run } */
-/* { dg-options "-std=c11 -pedantic-errors -pthread -D_POSIX_C_SOURCE=200809L" } */
+/* { dg-options "-std=c11 -pedantic-errors -pthread -U_POSIX_C_SOURCE -D_POSIX_C_SOURCE=200809L" } */
 /* { dg-additional-options "-D_XOPEN_SOURCE=600" { target *-*-solaris2.1[0-9]* } }
 /* { dg-require-effective-target pthread } */
 
Index: gcc/testsuite/gcc.dg/atomic/c11-atomic-exec-5.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/atomic/c11-atomic-exec-5.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/atomic/c11-atomic-exec-5.c	(.../branches/gcc-4_9-branch)
@@ -3,7 +3,7 @@
    iterations of the compare-and-exchange loop are needed, exceptions
    get properly cleared).  */
 /* { dg-do run } */
-/* { dg-options "-std=c11 -pedantic-errors -pthread -D_POSIX_C_SOURCE=200809L" } */
+/* { dg-options "-std=c11 -pedantic-errors -pthread -U_POSIX_C_SOURCE -D_POSIX_C_SOURCE=200809L" } */
 /* { dg-additional-options "-D_XOPEN_SOURCE=600" { target *-*-solaris2.1[0-9]* } }
 /* { dg-require-effective-target fenv_exceptions } */
 /* { dg-require-effective-target pthread } */
Index: gcc/testsuite/gcc.dg/atomic/stdatomic-flag.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/atomic/stdatomic-flag.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/atomic/stdatomic-flag.c	(.../branches/gcc-4_9-branch)
@@ -1,4 +1,5 @@
 /* Test atomic_flag routines for existence and execution.  */
+/* The test needs a lockless atomic implementation.  */
 /* { dg-do run { xfail hppa*-*-hpux* } } */
 /* { dg-options "-std=c11 -pedantic-errors" } */
 
Index: gcc/testsuite/gcc.dg/torture/pr61964.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr61964.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr61964.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,33 @@
+/* { dg-do run } */
+
+extern void abort (void);
+
+struct node { struct node *next, *prev; } node;
+struct head { struct node *first; } heads[5];
+int k = 2;
+struct head *head = &heads[2];
+
+static int __attribute__((noinline))
+foo()
+{
+  node.prev = (void *)head;
+  head->first = &node;
+
+  struct node *n = head->first;
+  struct head *h = &heads[k];
+
+  if (n->prev == (void *)h)
+    h->first = n->next;
+  else
+    n->prev->next = n->next;
+
+  n->next = h->first;
+  return n->next == &node;
+}
+
+int main()
+{
+  if (foo ())
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/tree-ssa/ssa-copyprop-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-copyprop-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-copyprop-2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-Og -fdump-tree-optimized" } */
+
+extern long long __sdt_unsp;
+void
+f(void)
+{
+  for (;;)
+    __asm__ ("%0" :: "i" (((!__extension__ (__builtin_constant_p ((((unsigned long long) (__typeof (__builtin_choose_expr (((__builtin_classify_type (0) + 3) & -4) == 4, (0), 0U))) __sdt_unsp) ) == 0) )) ? 1 : -1) ));
+}
+
+/* { dg-final { scan-tree-dump-not "PHI" "optimized" } } */
+/* { dg-final { cleanup-tree-dump "optimized" } } */
Index: gcc/testsuite/gcc.dg/pr61776.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr61776.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/pr61776.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,27 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fprofile-generate" } */
+
+#include <setjmp.h>
+
+int cond1, cond2;
+
+int goo() __attribute__((noinline));
+
+int goo() {
+ if (cond1)
+   return 1;
+ else
+   return 2;
+}
+
+jmp_buf env;
+int foo() {
+ int a;
+
+ setjmp(env);
+ if (cond2)
+   a = goo();
+ else
+   a = 3;
+ return a;
+}
Index: gcc/testsuite/gcc.dg/stack-usage-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/stack-usage-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/stack-usage-2.c	(.../branches/gcc-4_9-branch)
@@ -1,21 +1,21 @@
 /* { dg-do compile } */
 /* { dg-options "-Wstack-usage=512" } */
 
-int foo1 (void)
+int foo1 (void)  /* { dg-bogus "stack usage" } */
 {
   char arr[16];
   arr[0] = 1;
   return 0;
-} /* { dg-bogus "stack usage" } */
+}
 
-int foo2 (void)
+int foo2 (void)  /* { dg-warning "stack usage is \[0-9\]* bytes" } */
 {
   char arr[1024];
   arr[0] = 1;
   return 0;
-} /* { dg-warning "stack usage is \[0-9\]* bytes" } */
+}
 
-int foo3 (void)
+int foo3 (void) /* { dg-warning "stack usage might be \[0-9\]* bytes" } */
 {
   char arr[1024] __attribute__((aligned (512)));
   arr[0] = 1;
@@ -22,12 +22,11 @@
   /* Force dynamic realignment of argument pointer.  */
   __builtin_apply ((void (*)()) foo2, 0, 0);
   return 0;
+}
 
-} /* { dg-warning "stack usage might be \[0-9\]* bytes" } */
-
-int foo4 (int n)
+int foo4 (int n) /* { dg-warning "stack usage might be unbounded" } */
 {
   char arr[n];
   arr[0] = 1;
   return 0;
-} /* { dg-warning "stack usage might be unbounded" } */
+}
Index: gcc/testsuite/gcc.dg/pr62030.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr62030.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/pr62030.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,50 @@
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+extern void abort (void);
+
+struct node
+{
+  struct node *next;
+  struct node *prev;
+};
+
+struct node node;
+
+struct head
+{
+  struct node *first;
+};
+
+struct head heads[5];
+
+int k = 2;
+
+struct head *head = &heads[2];
+
+static int __attribute__((noinline))
+foo (void)
+{
+  node.prev = (void *)head;
+  head->first = &node;
+
+  struct node *n = head->first;
+  struct head *h = &heads[k];
+  struct node *next = n->next;
+
+  if (n->prev == (void *)h)
+    h->first = next;
+  else
+    n->prev->next = next;
+
+  n->next = h->first;
+  return n->next == &node;
+}
+
+int
+main (void)
+{
+  if (foo ())
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/vect/pr62073.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/pr62073.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/pr62073.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,40 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-O1" } */
+
+struct S0
+{
+  int f7;
+};
+struct S0 g_50;
+int g_70;
+int g_76;
+
+int foo (long long p_56, int * p_57)
+{
+  int *l_77;
+  int l_101;
+
+  for (; g_70;)
+    {
+      int **l_78 = &l_77;
+      if (g_50.f7)
+	continue;
+      *l_78 = 0;
+    }
+  for (g_76 = 1; g_76 >= 0; g_76--)
+    {
+      int *l_90;
+      for (l_101 = 4; l_101 >= 0; l_101--)
+	if (l_101)
+	  *l_90 = 0;
+	else
+	  {
+	    int **l_113 = &l_77;
+	    *l_113 = p_57;
+	  }
+    }
+
+  return *l_77;
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/ChangeLog
===================================================================
--- a/src/gcc/testsuite/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,308 @@
+2014-08-22  Igor Zamyatin  <igor.zamyatin@intel.com>
+
+	PR other/62008
+	* c-c++-common/cilk-plus/AN/pr62008.c: New test.
+
+2014-08-21  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/62214
+	* gfortran.dg/array_assignment_5.f90:  New test.
+
+2014-08-20  Martin Jambor  <mjambor@suse.cz>
+	    Wei Mi  <wmi@google.com>
+
+	PR ipa/60449
+	PR middle-end/61776
+	* testsuite/gcc.dg/lto/pr60449_1.c: New test.
+	* testsuite/gcc.dg/lto/pr60449_0.c: New test.
+	* testsuite/gcc.dg/pr61776.c: New test.
+
+2014-08-19  Janis Johnson  <janisjo@codesourcery.com>
+
+	Backport from mainline:
+	2014-08-19  Janis Johnson  <janisjo@codesourcery.com>
+
+	* lib/target-supports.exp
+	(check_effective_target_arm_v8_neon_ok_nocache): Add
+	"-march-armv8-a" to compile flags.
+
+2014-08-15  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/62142
+	* gfortran.dg/realloc_on_assign_24.f90:  New test.
+
+2014-08-15  Tom de Vries  <tom@codesourcery.com>
+
+	Backport from mainline:
+	2014-08-14  Tom de Vries  <tom@codesourcery.com>
+
+	PR rtl-optimization/62004
+	PR rtl-optimization/62030
+	* gcc.dg/pr62004.c: New test.
+	* gcc.dg/pr62030.c: Same.
+	* gcc.target/mips/pr62030-octeon.c: Same.
+
+2014-08-15  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/62106
+	* gfortran.dg/array_constructor_49.f90:  New test.
+
+2014-08-15  Jakub Jelinek  <jakub@redhat.com>
+	    Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/62131
+	* gfortran.dg/gomp/pr62131.f90: New test.
+
+2014-08-14  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2014-08-04  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/61713
+	* gcc.dg/pr61756.c: New test.
+
+2014-08-14  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2014-08-12  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	PR middle-end/62103
+	* gcc.c-torture/execute/bitfld-6.c: New test.
+
+2014-08-12  Felix Yang  <fei.yang0953@gmail.com>
+
+	PR tree-optimization/62073
+	* gcc.dg/vect/pr62073.c: New test.
+
+2014-08-12  Janis Johnson  <janisjo@codesourcery.com>
+
+	Backport from mainline
+	2014-08-12  Janis Johnson  <janisjo@codesourcery.com>
+
+	* lib/target/supports.exp
+	(check_effective_target_arm_v8_neon_ok_nocache): Check for armv8
+	or later.
+
+	* gcc.dg/pr59418.c: Don't add ARM options for a Thumb1 multilib.
+
+	* gcc.target/arm/neon-vext-execute.c: Skip if the test won't run
+	on Neon hardware.
+
+	* gcc.target/arm/pr48784.c: Skip for thumb1 multilib.
+	* gcc.target/arm/pr59985.c: Likewise.
+
+2014-08-12  Igor Zamyatin  <igor.zamyatin@intel.com>
+
+	PR other/61962
+	* c-c++-common/cilk-plus/AN/pr61962.c: New test.
+
+2014-08-12  Ganesh Gopalasubramanian <Ganesh.Gopalasubramanian@amd.com>
+
+	Backport from mainline
+	2014-06-16  Ganesh Gopalasubramanian
+		    <Ganesh.Gopalasubramanian@amd.com>
+
+	* gcc.target/i386/xop-imul64-vector.c: Remove the check for
+	vpmacsdql instruction.
+
+2014-08-11  Janis Johnson  <janisjo@codesourcery.com>
+
+	Backport from mainline
+	2014-08-11  Janis Johnson  <janisjo@codesourcery.com>
+
+	* lib/target-supports.exp (check_effective_target_arm_thumb1_ok,
+	check_effective_target_arm_thumb2_ok): Test with code that passes
+	an argument and returns a result.
+
+	* gcc.target/arm/frame-pointer-1.c: Skip if Thumb is not supported.
+	* gcc.target/arm/pr56184.C: Likewise.
+	* gcc.target/arm/pr59896.c: Likewise.
+	* gcc.target/arm/stack-red-zone.c: Likewise.
+	* gcc.target/arm/thumb-find-work-register.c: Likewise.
+
+2014-08-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/61999
+	* gfortran.dg/dot_product_3.f90:  New test case.
+
+2014-08-07  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR tree-optimization/60707
+	* gfortran.dg/pr45636.f90: xfail on 32-bit hppa*-*-*.
+
+	* gcc.dg/atomic/c11-atomic-exec-4.c: Undefine _POSIX_C_SOURCE before
+	defining in dg-options.
+	* gcc.dg/atomic/c11-atomic-exec-5.c: Likewise.
+
+	* gcc.dg/atomic/stdatomic-flag.c: Add xfail comment.
+
+	* gcc.c-torture/compile/pr60655-1.c: Don't add -fdata-sections option
+	on 32-bit hppa-hpux.
+
+	* gcc.dg/pr57233.c: Add -fno-common option on hppa*-*-hpux*.
+
+2014-08-07  Petr Murzin  <petr.murzin@intel.com>
+
+	* gcc.target/i386/avx512f-vfixupimmpd-2.c: Include float.h instead of
+	values.h, change MAXDOUBLE for DBL_MAX.
+	* gcc.target/i386/avx512f-vfixupimmsd-2.c: Ditto.
+	* gcc.target/i386/avx512f-vfixupimmps-2.c: Include float.h instead of
+	values.h, change MAXFLOAT for FLT_MAX.
+	* gcc.target/i386/avx512f-vfixupimmss-2.c: Ditto.
+	* gcc.target/i386/avx512f-vpermi2d-2.c: Do not include values.h.
+	* gcc.target/i386/avx512f-vpermi2pd-2.c: Ditto.
+	* gcc.target/i386/avx512f-vpermi2ps-2.c: Ditto.
+	* gcc.target/i386/avx512f-vpermi2q-2.c: Ditto.
+	* gcc.target/i386/avx512f-vpermt2d-2.c: Ditto.
+	* gcc.target/i386/avx512f-vpermt2pd-2.c: Ditto.
+	* gcc.target/i386/avx512f-vpermt2ps-2.c: Ditto.
+	* gcc.target/i386/avx512f-vpermt2q-2.c: Ditto.
+
+2014-08-06  Vladimir Makarov  <vmakarov@redhat.com>
+
+	PR debug/61923
+	* gcc.target/i386/pr61923.c: New test.
+
+2014-08-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/61801
+	* gcc.target/i386/pr61801.c: Rewritten.
+
+2014-08-04  Rohit  <rohitarulraj@freescale.com>
+
+	PR target/60102
+	* gcc.target/powerpc/pr60102.c: New testcase.
+
+2014-08-01  Igor Zamyatin  <igor.zamyatin@intel.com>
+
+	PR other/61963
+	* c-c++-common/cilk-plus/AN/pr61963.c: New test.
+
+2014-08-01  Igor Zamyatin  <igor.zamyatin@intel.com>
+
+	PR middle-end/61455
+	* c-c++-common/cilk-plus/AN/pr61455.c: New test.
+	* c-c++-common/cilk-plus/AN/pr61455-2.c: Likewise.
+
+2014-08-01  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2014-06-13  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	PR tree-optimization/61375
+	* gcc.c-torture/execute/pr61375-1.c: New test.
+
+2014-08-01  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/61964
+	* gcc.dg/torture/pr61964.c: New testcase.
+	* gcc.dg/pr51879-18.c: XFAIL.
+
+2014-07-28  Richard Biener  <rguenther@suse.de>
+
+	PR rtl-optimization/61801
+	* gcc.target/i386/pr61801.c: Fix testcase.
+
+2014-07-28  Richard Biener  <rguenther@suse.de>
+
+	PR rtl-optimization/61801
+	* gcc.target/i386/pr61801.c: New testcase.
+
+2014-07-24  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	Backport from mainline
+	2014-07-24  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	* gcc.target/powerpc/ppc64-abi-warn-3.c: New test.
+
+	* gcc.c-torture/execute/20050316-1.x: Add -Wno-psabi.
+	* gcc.c-torture/execute/20050604-1.x: Add -Wno-psabi.
+	* gcc.c-torture/execute/20050316-3.x: New file.  Add -Wno-psabi.
+	* gcc.c-torture/execute/pr23135.x: Likewise.
+
+2014-07-24  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	Backport from mainline
+	2014-07-24  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	* gcc.target/powerpc/ppc64-abi-warn-2.c: New test.
+
+2014-07-24  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	Backport from mainline
+	2014-07-24  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	* gcc.target/powerpc/ppc64-abi-warn-1.c: New test.
+
+2014-07-24  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	Backport from mainline
+	2014-07-24  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	* g++.dg/compat/struct-layout-1.exp: Load g++-dg.exp.
+
+2014-07-24  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/61160
+	* g++.dg/ipa/pr61160-2.C (main): Return zero.
+	* g++.dg/ipa/pr61160-3.C (main): Likewise.
+
+2014-07-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2014-07-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/61855
+	* gcc.target/i386/pr61855.c: New test.
+
+2014-07-20  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/pack20.ad[sb]: New test.
+	* gnat.dg/pack20_pkg.ads: New helper.
+
+2014-07-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.dg/stack-usage-2.c: Adjust.
+
+2014-07-19  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/61780
+	* gfortran.dg/dependency_44.f90 : New test
+
+2014-07-18  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2014-07-18  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/61794
+	* gcc.target/i386/pr61794.c: New test.
+
+2014-07-17  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2014-07-10  Richard Biener  <rguenther@suse.de>
+
+	PR c-family/61741
+	* c-c++-common/torture/pr61741.c: Use signed char.
+
+	2014-07-09  Richard Biener  <rguenther@suse.de>
+
+	PR c-family/61741
+	* c-c++-common/torture/pr61741.c: New testcase.
+
+2014-07-17  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2014-07-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/61779
+	* gcc.dg/tree-ssa/ssa-copyprop-2.c: New testcase.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
@@ -17,7 +322,8 @@
 	2014-06-09  Alan Lawrence  <alan.lawrence@arm.com>
 
 	PR target/61062
-	* gcc.target/arm/pr48252.c (main): Expect same result as endian-neutral.
+	* gcc.target/arm/pr48252.c (main): Expect same result as
+	endian-neutral.
 
 2014-07-08  Jakub Jelinek  <jakub@redhat.com>
 
@@ -34,8 +340,8 @@
 
 2014-07-08  Alan Lawrence  <alan.lawrence@arm.com>
 
-        Backport r211502 from mainline.
-        2014-06-10  Alan Lawrence  <alan.lawrence@arm.com>
+	Backport r211502 from mainline.
+	2014-06-10  Alan Lawrence  <alan.lawrence@arm.com>
 
 	PR target/59843
 	* gcc.dg/vect/vect-singleton_1.c: New file.
Index: gcc/testsuite/g++.dg/ext/restrict2.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ext/restrict2.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/ext/restrict2.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,8 @@
+// PR c++/60872
+// { dg-options "" }
+
+typedef double *__restrict T;
+void f(T* p)
+{
+  void *p2 = p;
+}
Index: gcc/testsuite/g++.dg/expr/cond12.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/expr/cond12.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/expr/cond12.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,12 @@
+// PR c++/58714
+// { dg-do run }
+
+struct X {
+    X& operator=(const X&){}
+    X& operator=(X&){__builtin_abort();}
+};
+
+int main(int argv,char**) {
+  X a, b;
+  ((argv > 2) ? a : b) = X();
+}
Index: gcc/testsuite/g++.dg/init/explicit2.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/init/explicit2.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/init/explicit2.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,8 @@
+// PR c++/60417
+
+struct A { explicit A(int = 0); };
+
+int main()
+{
+  A a[1] = { };
+}
Index: gcc/testsuite/g++.dg/compat/struct-layout-1.exp
===================================================================
--- a/src/gcc/testsuite/g++.dg/compat/struct-layout-1.exp	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/compat/struct-layout-1.exp	(.../branches/gcc-4_9-branch)
@@ -89,6 +89,9 @@
 # This must be done after the compat-use-*-compiler definitions.
 load_lib compat.exp
 
+# Provide the g++-dg-prune routine (gcc-dp.exp is loaded by compat.exp)
+load_lib g++-dg.exp
+
 g++_init
 
 # Save variables for the C++ compiler under test, which each test will
Index: gcc/testsuite/g++.dg/cpp0x/constexpr-empty7.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/constexpr-empty7.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/constexpr-empty7.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,28 @@
+// PR c++/61959
+// { dg-do compile { target c++11 } }
+
+template <class Coord> struct BasePoint
+{
+  Coord x, y;
+  constexpr BasePoint (Coord, Coord) : x (0), y (0) {}
+};
+template <class T> struct BaseCoord
+{
+  int value;
+  constexpr BaseCoord (T) : value (1) {}
+};
+template <class units> struct IntCoordTyped : BaseCoord<int>, units
+{
+  typedef BaseCoord Super;
+  constexpr IntCoordTyped (int) : Super (0) {}
+};
+template <class units>
+struct IntPointTyped : BasePoint<IntCoordTyped<units> >, units
+{
+  typedef BasePoint<IntCoordTyped<units> > Super;
+  constexpr IntPointTyped (int, int) : Super (0, 0) {}
+};
+struct A
+{
+};
+IntPointTyped<A> a (0, 0);
Index: gcc/testsuite/g++.dg/cpp0x/lambda/lambda-template13.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-template13.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-template13.C	(.../branches/gcc-4_9-branch)
@@ -1,5 +1,6 @@
 // PR c++/61566
 // { dg-do compile { target c++11 } }
+// { dg-options "-fabi-version=0" }
 
 struct function
 {
@@ -7,6 +8,7 @@
   function (_Functor);
 };
 
+template <class U>
 struct C
 {
   template <typename T>
@@ -15,6 +17,9 @@
 
 void bar ()
 {
-  C c;
+  C<int> c;
   c.foo (1);
 }
+
+// { dg-final { scan-assembler "_ZN8functionC1IZN1CIiE3fooIiEEvT_S_Ed_UlvE_EET_" } }
+// { dg-final { scan-assembler-not "_ZZN1CIiE3fooIiEEvT_8functionEd_NKUlvE_clEv" } }
Index: gcc/testsuite/g++.dg/cpp0x/rv-cond1.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/rv-cond1.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/rv-cond1.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,13 @@
+// PR c++/58714
+// { dg-do compile { target c++11 } }
+
+struct X {
+  X& operator=(const X&) = delete;
+  X& operator=(X&& ) = default;
+};
+
+void f(bool t) {
+  X a, b;
+  *(t ? &a : &b) = X();
+  (t ? a : b) = X();
+}
Index: gcc/testsuite/g++.dg/cpp0x/constexpr-array7.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/constexpr-array7.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/constexpr-array7.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,13 @@
+// PR c++/61994
+// { dg-do compile { target c++11 } }
+
+struct A { int i,j; };
+
+struct X {
+  A a = {1,1};
+};
+
+constexpr X table[1][1] = {{ {} }};
+
+#define SA(X) static_assert(X,#X)
+SA(table[0][0].a.i == 1);
Index: gcc/testsuite/g++.dg/ipa/pr61160-1.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ipa/pr61160-1.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/ipa/pr61160-1.C	(.../branches/gcc-4_9-branch)
@@ -27,5 +27,6 @@
 int main ()
 {
   CExample c;
-  return (test (c) != &c);
+  test (c);
+  return 0;
 }
Index: gcc/testsuite/g++.dg/ipa/devirt-39.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-39.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-39.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,28 @@
+// PR c++/61214
+/* { dg-options "-O2 -fdump-tree-optimized"  } */
+
+struct Base
+{
+  virtual ~Base();
+  virtual Base* clone() {
+    return 0;
+  }
+};
+
+struct Foo : Base
+{
+  virtual ~Foo();
+  virtual Base* clone() {
+    return new Foo();
+  }
+};
+
+int main()
+{
+  Base* f = new Foo();
+  f->clone();
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump-not "OBJ_TYPE_REF" "optimized"  } } */
+/* { dg-final { cleanup-tree-dump "optimized" } } */
Index: gcc/testsuite/g++.dg/ipa/pr61160-2.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ipa/pr61160-2.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/ipa/pr61160-2.C	(.../branches/gcc-4_9-branch)
@@ -39,5 +39,6 @@
 int main ()
 {
   CExample c;
-  return (test (c) != &c);
+  test (c);
+  return 0;
 }
Index: gcc/testsuite/c-c++-common/pr61741.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/pr61741.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/c-c++-common/pr61741.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,22 @@
+/* { dg-do run } */
+
+int a = 1, b;
+
+void
+foo (void)
+{
+  signed char c = 0;
+  for (; a; a--)
+    for (; c >= 0; c++);
+  if (!c)
+    b = 1;
+}
+
+int
+main ()
+{
+  foo ();
+  if (b != 0)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/c-c++-common/cilk-plus/AN/pr61962.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/cilk-plus/AN/pr61962.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/c-c++-common/cilk-plus/AN/pr61962.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,14 @@
+/* PR other/61962 */
+/* { dg-do compile } */
+/* { dg-options "-fcilkplus" } */
+
+struct FloatStruct
+{
+    float *f;
+};
+
+/* Either SRC or DST must be a struct, otherwise the bug does not occur.  */
+void f (struct FloatStruct* dst, float *src, unsigned int length)
+{
+    dst->f[0:length] = src[0:length];
+}
Index: gcc/testsuite/c-c++-common/cilk-plus/AN/pr61963.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/cilk-plus/AN/pr61963.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/c-c++-common/cilk-plus/AN/pr61963.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,9 @@
+/* PR other/61963 */
+/* { dg-do compile } */
+/* { dg-options "-fcilkplus" } */
+
+void f (int * int *a) /* { dg-error "expected" } */
+{
+    a[0:64] = 0; /* { dg-error "was not declared" "" { target c++ } 7 } */
+    a[0:64] = 0;
+}
Index: gcc/testsuite/c-c++-common/cilk-plus/AN/pr62008.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/cilk-plus/AN/pr62008.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/c-c++-common/cilk-plus/AN/pr62008.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,10 @@
+/* PR other/62008 */
+/* { dg-do compile } */
+/* { dg-options "-fcilkplus" } */
+
+void f(int *a, int w, int h)
+{
+  int tmp[w][h];
+  tmp[:][:] = a[0:w][0:h]; /* { dg-error "base of array section must be pointer or array type" } */
+  /* { dg-error "start-index and length fields necessary" "" { target c } 8 } */
+}
Index: gcc/testsuite/c-c++-common/cilk-plus/AN/pr61455-2.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/cilk-plus/AN/pr61455-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/c-c++-common/cilk-plus/AN/pr61455-2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,13 @@
+/* PR c++/61455 */
+/* { dg-options "-fcilkplus" } */
+
+int a[3] = {2, 3, 4};
+
+int main ()
+{
+  int c = 10;
+  int b = __sec_reduce_add(a[:]);
+  if (b+c != 19)
+    __builtin_abort();
+  return 0;
+}
Index: gcc/testsuite/c-c++-common/cilk-plus/AN/pr61455.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/cilk-plus/AN/pr61455.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/c-c++-common/cilk-plus/AN/pr61455.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,9 @@
+/* PR c++/61455 */
+/* { dg-do compile } */
+/* { dg-options "-fcilkplus" } */
+
+void foo ()
+{
+  int a[2];
+  int b = a[:]; /* { dg-error "cannot be scalar" } */
+}
Index: gcc/cp/init.c
===================================================================
--- a/src/gcc/cp/init.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cp/init.c	(.../branches/gcc-4_9-branch)
@@ -3557,19 +3557,11 @@
       try_block = begin_try_block ();
     }
 
-  /* If the initializer is {}, then all elements are initialized from {}.
-     But for non-classes, that's the same as value-initialization.  */
+  bool empty_list = false;
   if (init && BRACE_ENCLOSED_INITIALIZER_P (init)
       && CONSTRUCTOR_NELTS (init) == 0)
-    {
-      if (CLASS_TYPE_P (type))
-	/* Leave init alone.  */;
-      else
-	{
-	  init = NULL_TREE;
-	  explicit_value_init_p = true;
-	}
-    }
+    /* Skip over the handling of non-empty init lists.  */
+    empty_list = true;
 
   /* Maybe pull out constant value when from_array? */
 
@@ -3689,14 +3681,8 @@
 	    vec_free (new_vec);
 	}
 
-      /* Any elements without explicit initializers get {}.  */
-      if (cxx_dialect >= cxx11 && AGGREGATE_TYPE_P (type))
-	init = build_constructor (init_list_type_node, NULL);
-      else
-	{
-	  init = NULL_TREE;
-	  explicit_value_init_p = true;
-	}
+      /* Any elements without explicit initializers get T{}.  */
+      empty_list = true;
     }
   else if (from_array)
     {
@@ -3742,6 +3728,26 @@
 
       to = build1 (INDIRECT_REF, type, base);
 
+      /* If the initializer is {}, then all elements are initialized from T{}.
+	 But for non-classes, that's the same as value-initialization.  */
+      if (empty_list)
+	{
+	  if (cxx_dialect >= cxx11 && AGGREGATE_TYPE_P (type))
+	    {
+	      if (BRACE_ENCLOSED_INITIALIZER_P (init)
+		  && CONSTRUCTOR_NELTS (init) == 0)
+		/* Reuse it.  */;
+	      else
+		init = build_constructor (init_list_type_node, NULL);
+	      CONSTRUCTOR_IS_DIRECT_INIT (init) = true;
+	    }
+	  else
+	    {
+	      init = NULL_TREE;
+	      explicit_value_init_p = true;
+	    }
+	}
+
       if (from_array)
 	{
 	  tree from;
@@ -3846,6 +3852,13 @@
 
   stmt_expr = finish_init_stmts (is_global, stmt_expr, compound_stmt);
 
+  current_stmt_tree ()->stmts_are_full_exprs_p = destroy_temps;
+
+  if (errors)
+    return error_mark_node;
+  if (const_init)
+    return build2 (INIT_EXPR, atype, obase, const_init);
+
   /* Now make the result have the correct type.  */
   if (TREE_CODE (atype) == ARRAY_TYPE)
     {
@@ -3855,12 +3868,6 @@
       TREE_NO_WARNING (stmt_expr) = 1;
     }
 
-  current_stmt_tree ()->stmts_are_full_exprs_p = destroy_temps;
-
-  if (const_init)
-    return build2 (INIT_EXPR, atype, obase, const_init);
-  if (errors)
-    return error_mark_node;
   return stmt_expr;
 }
 
Index: gcc/cp/tree.c
===================================================================
--- a/src/gcc/cp/tree.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cp/tree.c	(.../branches/gcc-4_9-branch)
@@ -3795,6 +3795,10 @@
     {
       init_expr = get_target_expr (exp);
       exp = TARGET_EXPR_SLOT (init_expr);
+      if (CLASS_TYPE_P (TREE_TYPE (exp)))
+	exp = move (exp);
+      else
+	exp = rvalue (exp);
     }
   else
     {
Index: gcc/cp/ChangeLog
===================================================================
--- a/src/gcc/cp/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cp/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,61 @@
+2014-08-22  Igor Zamyatin  <igor.zamyatin@intel.com>
+
+	PR other/62008
+	* cp-array-notation.c (build_array_notation_ref): Added correct
+	handling of case with incorrect array.
+
+2014-08-19  Jason Merrill  <jason@redhat.com>
+
+	PR c++/61214
+	PR tree-optimization/62091
+	* decl2.c (decl_needed_p): Return true for virtual functions when
+	devirtualizing.
+
+	Backport:
+	PR c++/61566
+	* pt.c (instantiate_class_template_1): Ignore lambda on
+	CLASSTYPE_DECL_LIST.
+	(push_template_decl_real): A lambda is not primary.
+	* lambda.c (maybe_add_lambda_conv_op): Distinguish between being
+	currently in a function and the lambda living in a function.
+
+	Backport:
+	PR c++/60417
+	* init.c (build_vec_init): Set CONSTRUCTOR_IS_DIRECT_INIT on
+	init-list for trailing elements.
+	* typeck2.c (process_init_constructor_array): Likewise.
+
+2014-08-07  Jason Merrill  <jason@redhat.com>
+
+	PR c++/61959
+	* semantics.c (cxx_eval_bare_aggregate): Handle POINTER_PLUS_EXPR.
+
+	PR c++/61994
+	* init.c (build_vec_init): Leave atype an ARRAY_TYPE
+	if we're just returning an INIT_EXPR.
+
+	PR c++/60872
+	* call.c (standard_conversion): Don't try to apply restrict to void.
+
+	PR c++/58714
+	* tree.c (stabilize_expr): A stabilized prvalue is an xvalue.
+
+2014-08-01  Igor Zamyatin  <igor.zamyatin@intel.com>
+
+	* cp-array-notation.c (expand_an_in_modify_expr): Fix the misprint
+	in error output.
+
+2014-08-01  Igor Zamyatin  <igor.zamyatin@intel.com>
+
+	PR other/61963
+	* parser.c (cp_parser_array_notation): Added check for array_type.
+
+2014-08-01  Igor Zamyatin  <igor.zamyatin@intel.com>
+
+	PR middle-end/61455
+	* cp-array-notation.c (expand_array_notation_exprs): Handling of
+	DECL_EXPR improved. Changed handling for INIT_EXPR.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: gcc/cp/cp-array-notation.c
===================================================================
--- a/src/gcc/cp/cp-array-notation.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cp/cp-array-notation.c	(.../branches/gcc-4_9-branch)
@@ -607,7 +607,7 @@
     
   if (lhs_rank == 0 && rhs_rank != 0)
     {
-      error_at (location, "%qD cannot be scalar when %qD is not", lhs, rhs);
+      error_at (location, "%qE cannot be scalar when %qE is not", lhs, rhs);
       return error_mark_node;
     }
   if (lhs_rank != 0 && rhs_rank != 0 && lhs_rank != rhs_rank)
@@ -1147,7 +1147,6 @@
     case PARM_DECL:
     case NON_LVALUE_EXPR:
     case NOP_EXPR:
-    case INIT_EXPR:
     case ADDR_EXPR:
     case ARRAY_REF:
     case BIT_FIELD_REF:
@@ -1154,6 +1153,7 @@
     case VECTOR_CST:
     case COMPLEX_CST:
       return t;
+    case INIT_EXPR:
     case MODIFY_EXPR:
       if (contains_array_notation_expr (t))
 	t = expand_an_in_modify_expr (loc, TREE_OPERAND (t, 0), NOP_EXPR, 
@@ -1175,13 +1175,24 @@
 	return t;
       }
     case DECL_EXPR:
-      {
-	tree x = DECL_EXPR_DECL (t);
-	if (t && TREE_CODE (x) != FUNCTION_DECL)
+      if (contains_array_notation_expr (t))
+	{
+	  tree x = DECL_EXPR_DECL (t);
 	  if (DECL_INITIAL (x))
-	    t = expand_unary_array_notation_exprs (t);
+	    {
+	      location_t loc = DECL_SOURCE_LOCATION (x);
+	      tree lhs = x;
+	      tree rhs = DECL_INITIAL (x);
+	      DECL_INITIAL (x) = NULL;
+	      tree new_modify_expr = build_modify_expr (loc, lhs,
+							TREE_TYPE (lhs),
+							NOP_EXPR,
+							loc, rhs,
+							TREE_TYPE(rhs));
+	      t = expand_array_notation_exprs (new_modify_expr);
+	    }
+	}
       return t;
-      }
     case STATEMENT_LIST:
       {
 	tree_stmt_iterator i;
@@ -1392,7 +1403,10 @@
   if (TREE_CODE (type) == ARRAY_TYPE || TREE_CODE (type) == POINTER_TYPE)
     TREE_TYPE (array_ntn_expr) = TREE_TYPE (type);
   else
-    gcc_unreachable ();
+    {
+      error_at (loc, "base of array section must be pointer or array type");
+      return error_mark_node;
+    }
 
   SET_EXPR_LOCATION (array_ntn_expr, loc);
   return array_ntn_expr;
Index: gcc/cp/typeck2.c
===================================================================
--- a/src/gcc/cp/typeck2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cp/typeck2.c	(.../branches/gcc-4_9-branch)
@@ -1237,8 +1237,9 @@
 	  {
 	    /* If this type needs constructors run for default-initialization,
 	       we can't rely on the back end to do it for us, so make the
-	       initialization explicit by list-initializing from {}.  */
+	       initialization explicit by list-initializing from T{}.  */
 	    next = build_constructor (init_list_type_node, NULL);
+	    CONSTRUCTOR_IS_DIRECT_INIT (next) = true;
 	    next = massage_init_elt (TREE_TYPE (type), next, complain);
 	    if (initializer_zerop (next))
 	      /* The default zero-initialization is fine for us; don't
Index: gcc/cp/pt.c
===================================================================
--- a/src/gcc/cp/pt.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cp/pt.c	(.../branches/gcc-4_9-branch)
@@ -4697,6 +4697,9 @@
          template <typename T> friend void A<T>::f();
        is not primary.  */
     is_primary = false;
+  else if (TREE_CODE (decl) == TYPE_DECL
+	   && LAMBDA_TYPE_P (TREE_TYPE (decl)))
+    is_primary = false;
   else
     is_primary = template_parm_scope_p ();
 
@@ -9135,6 +9138,11 @@
 		  && DECL_OMP_DECLARE_REDUCTION_P (r))
 		cp_check_omp_declare_reduction (r);
 	    }
+	  else if (DECL_CLASS_TEMPLATE_P (t)
+		   && LAMBDA_TYPE_P (TREE_TYPE (t)))
+	    /* A closure type for a lambda in a default argument for a
+	       member template.  Ignore it; it will be instantiated with
+	       the default argument.  */;
 	  else
 	    {
 	      /* Build new TYPE_FIELDS.  */
Index: gcc/cp/semantics.c
===================================================================
--- a/src/gcc/cp/semantics.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cp/semantics.c	(.../branches/gcc-4_9-branch)
@@ -8955,7 +8955,9 @@
 	  constructor_elt *inner = base_field_constructor_elt (n, ce->index);
 	  inner->value = elt;
 	}
-      else if (ce->index && TREE_CODE (ce->index) == NOP_EXPR)
+      else if (ce->index
+	       && (TREE_CODE (ce->index) == NOP_EXPR
+		   || TREE_CODE (ce->index) == POINTER_PLUS_EXPR))
 	{
 	  /* This is an initializer for an empty base; now that we've
 	     checked that it's constant, we can ignore it.  */
Index: gcc/cp/decl2.c
===================================================================
--- a/src/gcc/cp/decl2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cp/decl2.c	(.../branches/gcc-4_9-branch)
@@ -1934,6 +1934,11 @@
   if (flag_keep_inline_dllexport
       && lookup_attribute ("dllexport", DECL_ATTRIBUTES (decl)))
     return true;
+  /* Virtual functions might be needed for devirtualization.  */
+  if (flag_devirtualize
+      && TREE_CODE (decl) == FUNCTION_DECL
+      && DECL_VIRTUAL_P (decl))
+    return true;
   /* Otherwise, DECL does not need to be emitted -- yet.  A subsequent
      reference to DECL might cause it to be emitted later.  */
   return false;
Index: gcc/cp/parser.c
===================================================================
--- a/src/gcc/cp/parser.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cp/parser.c	(.../branches/gcc-4_9-branch)
@@ -6306,7 +6306,7 @@
   parser->colon_corrects_to_scope_p = saved_colon_corrects;
 
   if (*init_index == error_mark_node || length_index == error_mark_node
-      || stride == error_mark_node)
+      || stride == error_mark_node || array_type == error_mark_node)
     {
       if (cp_lexer_peek_token (parser->lexer)->type == CPP_CLOSE_SQUARE)
 	cp_lexer_consume_token (parser->lexer);
Index: gcc/cp/call.c
===================================================================
--- a/src/gcc/cp/call.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cp/call.c	(.../branches/gcc-4_9-branch)
@@ -1208,9 +1208,10 @@
 	       && TREE_CODE (TREE_TYPE (from)) != FUNCTION_TYPE)
 	{
 	  tree nfrom = TREE_TYPE (from);
+	  /* Don't try to apply restrict to void.  */
+	  int quals = cp_type_quals (nfrom) & ~TYPE_QUAL_RESTRICT;
 	  from = build_pointer_type
-	    (cp_build_qualified_type (void_type_node, 
-			              cp_type_quals (nfrom)));
+	    (cp_build_qualified_type (void_type_node, quals));
 	  conv = build_conv (ck_ptr, from, conv);
 	}
       else if (TYPE_PTRDATAMEM_P (from))
Index: gcc/cp/lambda.c
===================================================================
--- a/src/gcc/cp/lambda.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cp/lambda.c	(.../branches/gcc-4_9-branch)
@@ -820,6 +820,7 @@
 maybe_add_lambda_conv_op (tree type)
 {
   bool nested = (current_function_decl != NULL_TREE);
+  bool nested_def = decl_function_context (TYPE_MAIN_DECL (type));
   tree callop = lambda_function (type);
 
   if (LAMBDA_EXPR_CAPTURE_LIST (CLASSTYPE_LAMBDA_EXPR (type)) != NULL_TREE)
@@ -972,7 +973,7 @@
   DECL_NOT_REALLY_EXTERN (fn) = 1;
   DECL_DECLARED_INLINE_P (fn) = 1;
   DECL_ARGUMENTS (fn) = build_this_parm (fntype, TYPE_QUAL_CONST);
-  if (nested)
+  if (nested_def)
     DECL_INTERFACE_KNOWN (fn) = 1;
 
   if (generic_lambda_p)
@@ -1012,7 +1013,7 @@
       DECL_NAME (arg) = NULL_TREE;
       DECL_CONTEXT (arg) = fn;
     }
-  if (nested)
+  if (nested_def)
     DECL_INTERFACE_KNOWN (fn) = 1;
 
   if (generic_lambda_p)
Index: gcc/haifa-sched.c
===================================================================
--- a/src/gcc/haifa-sched.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/haifa-sched.c	(.../branches/gcc-4_9-branch)
@@ -2972,7 +2972,7 @@
 {
   advance_state (curr_state);
   if (sched_verbose >= 6)
-    fprintf (sched_dump, ";;\tAdvanced a state.\n");
+    fprintf (sched_dump, ";;\tAdvance the current state.\n");
 }
 
 /* Update register pressure after scheduling INSN.  */
@@ -6007,6 +6007,7 @@
   modulo_insns_scheduled = 0;
 
   ls.modulo_epilogue = false;
+  ls.first_cycle_insn_p = true;
 
   /* Loop until all the insns in BB are scheduled.  */
   while ((*current_sched_info->schedule_more_p) ())
@@ -6077,7 +6078,6 @@
       if (must_backtrack)
 	goto do_backtrack;
 
-      ls.first_cycle_insn_p = true;
       ls.shadows_only_p = false;
       cycle_issued_insns = 0;
       ls.can_issue_more = issue_rate;
@@ -6363,11 +6363,13 @@
 	      break;
 	    }
 	}
+      ls.first_cycle_insn_p = true;
     }
   if (ls.modulo_epilogue)
     success = true;
  end_schedule:
-  advance_one_cycle ();
+  if (!ls.first_cycle_insn_p)
+    advance_one_cycle ();
   perform_replacements_new_cycle ();
   if (modulo_ii > 0)
     {
Index: gcc/tree-ssa-loop-ivopts.c
===================================================================
--- a/src/gcc/tree-ssa-loop-ivopts.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/tree-ssa-loop-ivopts.c	(.../branches/gcc-4_9-branch)
@@ -1679,6 +1679,8 @@
     return false;
 
   unsigned int align = TYPE_ALIGN (TREE_TYPE (ref));
+  if (GET_MODE_ALIGNMENT (TYPE_MODE (TREE_TYPE (ref))) > align)
+    align = GET_MODE_ALIGNMENT (TYPE_MODE (TREE_TYPE (ref)));
 
   unsigned HOST_WIDE_INT bitpos;
   unsigned int ref_align;
Index: gcc/tree-ssa-math-opts.c
===================================================================
--- a/src/gcc/tree-ssa-math-opts.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/tree-ssa-math-opts.c	(.../branches/gcc-4_9-branch)
@@ -1749,6 +1749,8 @@
 	  size = TYPE_PRECISION (n->type);
 	  if (size % BITS_PER_UNIT != 0)
 	    return NULL_TREE;
+	  if (size > HOST_BITS_PER_WIDEST_INT)
+	    return NULL_TREE;
 	  size /= BITS_PER_UNIT;
 	  n->n = (sizeof (HOST_WIDEST_INT) < 8 ? 0 :
 		  (unsigned HOST_WIDEST_INT)0x08070605 << 32 | 0x04030201);
@@ -1792,6 +1794,8 @@
 	    type_size = TYPE_PRECISION (type);
 	    if (type_size % BITS_PER_UNIT != 0)
 	      return NULL_TREE;
+	    if (type_size > (int) HOST_BITS_PER_WIDEST_INT)
+	      return NULL_TREE;
 
 	    /* Sign extension: result is dependent on the value.  */
 	    old_type_size = TYPE_PRECISION (n->type);
@@ -1932,7 +1936,7 @@
   bool changed = false;
   tree bswap16_type = NULL_TREE, bswap32_type = NULL_TREE, bswap64_type = NULL_TREE;
 
-  if (BITS_PER_UNIT != 8)
+  if (BITS_PER_UNIT != 8 || CHAR_BIT != 8)
     return 0;
 
   if (sizeof (HOST_WIDEST_INT) < 8)
Index: gcc/ifcvt.c
===================================================================
--- a/src/gcc/ifcvt.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/ifcvt.c	(.../branches/gcc-4_9-branch)
@@ -306,6 +306,28 @@
 
   return (e) ? e->dest : NULL_BLOCK;
 }
+
+/* Return true if RTXs A and B can be safely interchanged.  */
+
+static bool
+rtx_interchangeable_p (const_rtx a, const_rtx b)
+{
+  if (!rtx_equal_p (a, b))
+    return false;
+
+  if (GET_CODE (a) != MEM)
+    return true;
+
+  /* A dead type-unsafe memory reference is legal, but a live type-unsafe memory
+     reference is not.  Interchanging a dead type-unsafe memory reference with
+     a live type-safe one creates a live type-unsafe memory reference, in other
+     words, it makes the program illegal.
+     We check here conservatively whether the two memory references have equal
+     memory attributes.  */
+
+  return mem_attrs_eq_p (get_mem_attrs (a), get_mem_attrs (b));
+}
+
 
 /* Go through a bunch of insns, converting them to conditional
    execution format if possible.  Return TRUE if all of the non-note
@@ -1034,6 +1056,9 @@
       || (rtx_equal_p (if_info->a, XEXP (cond, 1))
 	  && rtx_equal_p (if_info->b, XEXP (cond, 0))))
     {
+      if (!rtx_interchangeable_p (if_info->a, if_info->b))
+	return FALSE;
+
       y = (code == EQ) ? if_info->a : if_info->b;
 
       /* Avoid generating the move if the source is the destination.  */
@@ -2504,7 +2529,7 @@
       if (! insn_b
 	  || insn_b != last_active_insn (else_bb, FALSE)
 	  || (set_b = single_set (insn_b)) == NULL_RTX
-	  || ! rtx_equal_p (x, SET_DEST (set_b)))
+	  || ! rtx_interchangeable_p (x, SET_DEST (set_b)))
 	return FALSE;
     }
   else
@@ -2517,7 +2542,7 @@
 	  || BLOCK_FOR_INSN (insn_b) != BLOCK_FOR_INSN (if_info->cond_earliest)
 	  || !NONJUMP_INSN_P (insn_b)
 	  || (set_b = single_set (insn_b)) == NULL_RTX
-	  || ! rtx_equal_p (x, SET_DEST (set_b))
+	  || ! rtx_interchangeable_p (x, SET_DEST (set_b))
 	  || ! noce_operand_ok (SET_SRC (set_b))
 	  || reg_overlap_mentioned_p (x, SET_SRC (set_b))
 	  || modified_between_p (SET_SRC (set_b), insn_b, jump)
@@ -2583,7 +2608,7 @@
 
   /* Look and see if A and B are really the same.  Avoid creating silly
      cmove constructs that no one will fix up later.  */
-  if (rtx_equal_p (a, b))
+  if (rtx_interchangeable_p (a, b))
     {
       /* If we have an INSN_B, we don't have to create any new rtl.  Just
 	 move the instruction that we already have.  If we don't have an
Index: gcc/expr.c
===================================================================
--- a/src/gcc/expr.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/expr.c	(.../branches/gcc-4_9-branch)
@@ -6605,7 +6605,7 @@
 	{
 	  HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (exp));
 	  rtx temp_target;
-	  if (mode == BLKmode)
+	  if (mode == BLKmode || mode == VOIDmode)
 	    mode = smallest_mode_for_size (size * BITS_PER_UNIT, MODE_INT);
 	  temp_target = gen_reg_rtx (mode);
 	  emit_group_store (temp_target, temp, TREE_TYPE (exp), size);
Index: gcc/go/gofrontend/parse.cc
===================================================================
--- a/src/gcc/go/gofrontend/parse.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/go/gofrontend/parse.cc	(.../branches/gcc-4_9-branch)
@@ -2865,7 +2865,10 @@
   // For a function literal, the next token must be a '{'.  If we
   // don't see that, then we may have a type expression.
   if (!this->peek_token()->is_op(OPERATOR_LCURLY))
-    return Expression::make_type(type, location);
+    {
+      hold_enclosing_vars.swap(this->enclosing_vars_);
+      return Expression::make_type(type, location);
+    }
 
   bool hold_is_erroneous_function = this->is_erroneous_function_;
   if (fntype_is_error)
Index: gcc/ada/socket.c
===================================================================
--- a/src/gcc/ada/socket.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/ada/socket.c	(.../branches/gcc-4_9-branch)
@@ -212,7 +212,7 @@
   struct hostent *rh;
   int ri;
 
-#if defined(__linux__) || defined(__GLIBC__)
+#if defined(__linux__) || defined(__GLIBC__) || defined(__rtems__)
   (void) gethostbyname_r (name, ret, buf, buflen, &rh, h_errnop);
 #else
   rh = gethostbyname_r (name, ret, buf, buflen, h_errnop);
Index: gcc/ada/ChangeLog
===================================================================
--- a/src/gcc/ada/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/ada/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,12 @@
+2014-08-12  Joel Sherrill <joel.sherrill@oarcorp.com>
+
+	* socket.c: For RTEMS, use correct prototype of gethostbyname_r().
+	* gsocket.h Add include of <unistd.h> on RTEMS.
+
+2014-08-11  Joel Sherrill <joel.sherrill@oarcorp.com>
+
+	* s-osinte-rtems.adb: Correct formatting of line in license block.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: gcc/ada/s-osinte-rtems.adb
===================================================================
--- a/src/gcc/ada/s-osinte-rtems.adb	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/ada/s-osinte-rtems.adb	(.../branches/gcc-4_9-branch)
@@ -22,7 +22,7 @@
 -- You should have received a copy of the GNU General Public License and    --
 -- a copy of the GCC Runtime Library Exception along with this program;     --
 -- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
--- <http://www.gnu.org/licenses/>.                                         
+-- <http://www.gnu.org/licenses/>.                                          --
 --                                                                          --
 -- GNARL was developed by the GNARL team at Florida State University. It is --
 -- now maintained by Ada Core Technologies Inc. in cooperation with Florida --
Index: gcc/ada/gsocket.h
===================================================================
--- a/src/gcc/ada/gsocket.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/ada/gsocket.h	(.../branches/gcc-4_9-branch)
@@ -183,6 +183,11 @@
 #include <sys/time.h>
 #endif
 
+#if defined(__rtems__)
+#include <unistd.h>
+/* Required, for read(), write(), and close() */
+#endif
+
 /*
  * RTEMS has these .h files but not until you have built and installed RTEMS.
  * When building a C/C++ toolset, you also build the newlib C library, so the
Index: gcc/fortran/openmp.c
===================================================================
--- a/src/gcc/fortran/openmp.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/fortran/openmp.c	(.../branches/gcc-4_9-branch)
@@ -464,7 +464,11 @@
 		      || !gfc_add_intrinsic (&sym->attr, NULL)))
 		rop = OMP_REDUCTION_NONE;
 	    }
-	  gfc_omp_udr *udr = gfc_find_omp_udr (gfc_current_ns, buffer, NULL);
+	  else
+	    buffer[0] = '\0';
+	  gfc_omp_udr *udr
+	    = (buffer[0]
+	       ? gfc_find_omp_udr (gfc_current_ns, buffer, NULL) : NULL);
 	  gfc_omp_namelist **head = NULL;
 	  if (rop == OMP_REDUCTION_NONE && udr)
 	    rop = OMP_REDUCTION_USER;
@@ -1240,6 +1244,7 @@
 	 syntax:
 	  gfc_current_locus = old_loc;
 	  gfc_current_ns = combiner_ns->parent;
+	  gfc_undo_symbols ();
 	  gfc_free_omp_udr (omp_udr);
 	  return MATCH_ERROR;
 	}
@@ -2739,7 +2744,7 @@
       break;
     }
 
-  if (var->attr.allocatable)
+  if (gfc_expr_attr (code->expr1).allocatable)
     {
       gfc_error ("!$OMP ATOMIC with ALLOCATABLE variable at %L",
 		 &code->loc);
Index: gcc/fortran/trans-expr.c
===================================================================
--- a/src/gcc/fortran/trans-expr.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/fortran/trans-expr.c	(.../branches/gcc-4_9-branch)
@@ -7842,7 +7842,7 @@
 	  for (a = expr2->value.function.actual; a != NULL; a = a->next)
 	    {
 	      e1 = a->expr;
-	      if (e1->rank > 0 && !is_runtime_conformable (expr1, e1))
+	      if (e1 && e1->rank > 0 && !is_runtime_conformable (expr1, e1))
 		return false;
 	    }
 	  return true;
@@ -7853,7 +7853,7 @@
 	  for (a = expr2->value.function.actual; a != NULL; a = a->next)
 	    {
 	      e1 = a->expr;
-	      if (e1->rank > 0 && !is_runtime_conformable (expr1, e1))
+	      if (e1 && e1->rank > 0 && !is_runtime_conformable (expr1, e1))
 		return false;
 	    }
 	  return true;
Index: gcc/fortran/trans-openmp.c
===================================================================
--- a/src/gcc/fortran/trans-openmp.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/fortran/trans-openmp.c	(.../branches/gcc-4_9-branch)
@@ -1022,6 +1022,7 @@
 	  && !GFC_DECL_CRAY_POINTEE (decl)
 	  && !GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (TREE_TYPE (decl))))
 	return;
+      tree orig_decl = decl;
       c4 = build_omp_clause (OMP_CLAUSE_LOCATION (c), OMP_CLAUSE_MAP);
       OMP_CLAUSE_MAP_KIND (c4) = OMP_CLAUSE_MAP_POINTER;
       OMP_CLAUSE_DECL (c4) = decl;
@@ -1029,6 +1030,17 @@
       decl = build_fold_indirect_ref (decl);
       OMP_CLAUSE_DECL (c) = decl;
       OMP_CLAUSE_SIZE (c) = NULL_TREE;
+      if (TREE_CODE (TREE_TYPE (orig_decl)) == REFERENCE_TYPE
+	  && (GFC_DECL_GET_SCALAR_POINTER (orig_decl)
+	      || GFC_DECL_GET_SCALAR_ALLOCATABLE (orig_decl)))
+	{
+	  c3 = build_omp_clause (OMP_CLAUSE_LOCATION (c), OMP_CLAUSE_MAP);
+	  OMP_CLAUSE_MAP_KIND (c3) = OMP_CLAUSE_MAP_POINTER;
+	  OMP_CLAUSE_DECL (c3) = unshare_expr (decl);
+	  OMP_CLAUSE_SIZE (c3) = size_int (0);
+	  decl = build_fold_indirect_ref (decl);
+	  OMP_CLAUSE_DECL (c) = decl;
+	}
     }
   if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl)))
     {
@@ -1884,8 +1896,15 @@
 		TREE_ADDRESSABLE (decl) = 1;
 	      if (n->expr == NULL || n->expr->ref->u.ar.type == AR_FULL)
 		{
-		  if (POINTER_TYPE_P (TREE_TYPE (decl)))
+		  if (POINTER_TYPE_P (TREE_TYPE (decl))
+		      && (gfc_omp_privatize_by_reference (decl)
+			  || GFC_DECL_GET_SCALAR_POINTER (decl)
+			  || GFC_DECL_GET_SCALAR_ALLOCATABLE (decl)
+			  || GFC_DECL_CRAY_POINTEE (decl)
+			  || GFC_DESCRIPTOR_TYPE_P
+					(TREE_TYPE (TREE_TYPE (decl)))))
 		    {
+		      tree orig_decl = decl;
 		      node4 = build_omp_clause (input_location,
 						OMP_CLAUSE_MAP);
 		      OMP_CLAUSE_MAP_KIND (node4) = OMP_CLAUSE_MAP_POINTER;
@@ -1892,6 +1911,17 @@
 		      OMP_CLAUSE_DECL (node4) = decl;
 		      OMP_CLAUSE_SIZE (node4) = size_int (0);
 		      decl = build_fold_indirect_ref (decl);
+		      if (TREE_CODE (TREE_TYPE (orig_decl)) == REFERENCE_TYPE
+			  && (GFC_DECL_GET_SCALAR_POINTER (orig_decl)
+			      || GFC_DECL_GET_SCALAR_ALLOCATABLE (orig_decl)))
+			{
+			  node3 = build_omp_clause (input_location,
+						    OMP_CLAUSE_MAP);
+			  OMP_CLAUSE_MAP_KIND (node3) = OMP_CLAUSE_MAP_POINTER;
+			  OMP_CLAUSE_DECL (node3) = decl;
+			  OMP_CLAUSE_SIZE (node3) = size_int (0);
+			  decl = build_fold_indirect_ref (decl);
+			}
 		    }
 		  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl)))
 		    {
Index: gcc/fortran/gfortran.h
===================================================================
--- a/src/gcc/fortran/gfortran.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/fortran/gfortran.h	(.../branches/gcc-4_9-branch)
@@ -724,7 +724,7 @@
     optional:1, pointer:1, target:1, value:1, volatile_:1, temporary:1,
     dummy:1, result:1, assign:1, threadprivate:1, not_always_present:1,
     implied_index:1, subref_array_pointer:1, proc_pointer:1, asynchronous:1,
-    contiguous:1;
+    contiguous:1, fe_temp: 1;
 
   /* For CLASS containers, the pointer attribute is sometimes set internally
      even though it was not directly specified.  In this case, keep the
Index: gcc/fortran/ChangeLog
===================================================================
--- a/src/gcc/fortran/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/fortran/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,67 @@
+2014-08-21  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/62214
+	* frontend-passes.c (optimize_binop_array_assignment):
+	Do not try to optimize the array assignment for string
+	concatenation.
+
+2014-08-16  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/62142
+	* trans-expr.c (is_runtime_conformable):  Add NULL pointer checks.
+
+2014-08-15  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/62106
+	* gfortran.h (symbol_attribute):  Add fe_temp flag.
+	* frontend-passes.c (is_fe_temp):  New function.
+	(create_var):  Don't add a temporary for an already
+	created variable or for a constant.
+	(combine_ARRAY_constructor):  Remove special handling
+	for constants.
+
+2014-08-15  Jakub Jelinek  <jakub@redhat.com>
+	    Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/62131
+	* openmp.c (resolve_omp_atomic): Only complain if code->expr1's attr
+	is allocatable, rather than whenever var->attr.allocatable.
+
+2014-08-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/62107
+	* trans-openmp.c (gfc_omp_finish_clause): Handle scalar pointer
+	or allocatable passed by reference.
+	(gfc_trans_omp_clauses) <case OMP_LIST_MAP>: Likewise.
+
+2014-08-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/62076
+	* openmp.c (gfc_match_omp_clauses): When failed to match
+	operator name, defined op name or name, set buffer to
+	empty string.  Don't call gfc_find_omp_udr if buffer is empty
+	string.
+	(gfc_match_omp_declare_reduction): Call gfc_undo_symbols ()
+	before calling gfc_free_omp_udr.
+
+2014-08-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/61999
+	* simplify.c (gfc_simplify_dot_product): Convert types of
+	vectors before calculating the result.
+
+2014-07-19  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/61780
+	* dependency.c (gfc_dep_resolver): Index the 'reverse' array so
+	that elements are skipped. This then correctly aligns 'reverse'
+	with the scalarizer loops.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: gcc/fortran/frontend-passes.c
===================================================================
--- a/src/gcc/fortran/frontend-passes.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/fortran/frontend-passes.c	(.../branches/gcc-4_9-branch)
@@ -430,11 +430,26 @@
   return 0;
 }
 
+/* Auxiliary function to check if an expression is a temporary created by
+   create var.  */
+
+static bool
+is_fe_temp (gfc_expr *e)
+{
+  if (e->expr_type != EXPR_VARIABLE)
+    return false;
+
+  return e->symtree->n.sym->attr.fe_temp;
+}
+
+
 /* Returns a new expression (a variable) to be used in place of the old one,
    with an assignment statement before the current statement to set
    the value of the variable. Creates a new BLOCK for the statement if
    that hasn't already been done and puts the statement, plus the
-   newly created variables, in that block.  */
+   newly created variables, in that block.  Special cases:  If the
+   expression is constant or a temporary which has already
+   been created, just copy it.  */
 
 static gfc_expr*
 create_var (gfc_expr * e)
@@ -448,6 +463,9 @@
   gfc_namespace *ns;
   int i;
 
+  if (e->expr_type == EXPR_CONSTANT || is_fe_temp (e))
+    return gfc_copy_expr (e);
+
   /* If the block hasn't already been created, do so.  */
   if (inserted_block == NULL)
     {
@@ -522,6 +540,7 @@
   symbol->attr.flavor = FL_VARIABLE;
   symbol->attr.referenced = 1;
   symbol->attr.dimension = e->rank > 0;
+  symbol->attr.fe_temp = 1;
   gfc_commit_symbol (symbol);
 
   result = gfc_get_expr ();
@@ -884,6 +903,10 @@
 	    return true;
 	  break;
 
+	case INTRINSIC_CONCAT:
+	  /* Do not do string concatenations.  */
+	  break;
+
 	default:
 	  /* Binary operators.  */
 	  if (optimize_binop_array_assignment (c, &e->value.op.op1, true))
@@ -1082,10 +1105,7 @@
   if (op2->ts.type == BT_CHARACTER)
     return false;
 
-  if (op2->expr_type == EXPR_CONSTANT)
-    scalar = gfc_copy_expr (op2);
-  else
-    scalar = create_var (gfc_copy_expr (op2));
+  scalar = create_var (gfc_copy_expr (op2));
 
   oldbase = op1->value.constructor;
   newbase = NULL;
Index: gcc/fortran/dependency.c
===================================================================
--- a/src/gcc/fortran/dependency.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/fortran/dependency.c	(.../branches/gcc-4_9-branch)
@@ -2023,6 +2023,7 @@
 gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)
 {
   int n;
+  int m;
   gfc_dependency fin_dep;
   gfc_dependency this_dep;
 
@@ -2072,6 +2073,8 @@
 	      break;
 	    }
 
+	  /* Index for the reverse array.  */
+	  m = -1;
 	  for (n=0; n < lref->u.ar.dimen; n++)
 	    {
 	      /* Handle dependency when either of array reference is vector
@@ -2118,31 +2121,37 @@
 		 The ability to reverse or not is set by previous conditions
 		 in this dimension.  If reversal is not activated, the
 		 value GFC_DEP_BACKWARD is reset to GFC_DEP_OVERLAP.  */
+
+	      /* Get the indexing right for the scalarizing loop. If this
+		 is an element, there is no corresponding loop.  */
+	      if (lref->u.ar.dimen_type[n] != DIMEN_ELEMENT)
+		m++;
+
 	      if (rref->u.ar.dimen_type[n] == DIMEN_RANGE
 		    && lref->u.ar.dimen_type[n] == DIMEN_RANGE)
 		{
 		  /* Set reverse if backward dependence and not inhibited.  */
-		  if (reverse && reverse[n] == GFC_ENABLE_REVERSE)
-		    reverse[n] = (this_dep == GFC_DEP_BACKWARD) ?
-			         GFC_REVERSE_SET : reverse[n];
+		  if (reverse && reverse[m] == GFC_ENABLE_REVERSE)
+		    reverse[m] = (this_dep == GFC_DEP_BACKWARD) ?
+			         GFC_REVERSE_SET : reverse[m];
 
 		  /* Set forward if forward dependence and not inhibited.  */
-		  if (reverse && reverse[n] == GFC_ENABLE_REVERSE)
-		    reverse[n] = (this_dep == GFC_DEP_FORWARD) ?
-			         GFC_FORWARD_SET : reverse[n];
+		  if (reverse && reverse[m] == GFC_ENABLE_REVERSE)
+		    reverse[m] = (this_dep == GFC_DEP_FORWARD) ?
+			         GFC_FORWARD_SET : reverse[m];
 
 		  /* Flag up overlap if dependence not compatible with
 		     the overall state of the expression.  */
-		  if (reverse && reverse[n] == GFC_REVERSE_SET
+		  if (reverse && reverse[m] == GFC_REVERSE_SET
 		        && this_dep == GFC_DEP_FORWARD)
 		    {
-	              reverse[n] = GFC_INHIBIT_REVERSE;
+	              reverse[m] = GFC_INHIBIT_REVERSE;
 		      this_dep = GFC_DEP_OVERLAP;
 		    }
-		  else if (reverse && reverse[n] == GFC_FORWARD_SET
+		  else if (reverse && reverse[m] == GFC_FORWARD_SET
 		        && this_dep == GFC_DEP_BACKWARD)
 		    {
-	              reverse[n] = GFC_INHIBIT_REVERSE;
+	              reverse[m] = GFC_INHIBIT_REVERSE;
 		      this_dep = GFC_DEP_OVERLAP;
 		    }
 
@@ -2149,7 +2158,7 @@
 		  /* If no intention of reversing or reversing is explicitly
 		     inhibited, convert backward dependence to overlap.  */
 		  if ((reverse == NULL && this_dep == GFC_DEP_BACKWARD)
-		      || (reverse != NULL && reverse[n] == GFC_INHIBIT_REVERSE))
+		      || (reverse != NULL && reverse[m] == GFC_INHIBIT_REVERSE))
 		    this_dep = GFC_DEP_OVERLAP;
 		}
 
Index: gcc/fortran/simplify.c
===================================================================
--- a/src/gcc/fortran/simplify.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/fortran/simplify.c	(.../branches/gcc-4_9-branch)
@@ -1878,6 +1878,9 @@
 gfc_expr*
 gfc_simplify_dot_product (gfc_expr *vector_a, gfc_expr *vector_b)
 {
+
+  gfc_expr temp;
+
   if (!is_constant_array_expr (vector_a)
       || !is_constant_array_expr (vector_b))
     return NULL;
@@ -1884,8 +1887,14 @@
 
   gcc_assert (vector_a->rank == 1);
   gcc_assert (vector_b->rank == 1);
-  gcc_assert (gfc_compare_types (&vector_a->ts, &vector_b->ts));
 
+  temp.expr_type = EXPR_OP;
+  gfc_clear_ts (&temp.ts);
+  temp.value.op.op = INTRINSIC_NONE;
+  temp.value.op.op1 = vector_a;
+  temp.value.op.op2 = vector_b;
+  gfc_type_convert_binary (&temp, 1);
+
   return compute_dot_product (vector_a, 1, 0, vector_b, 1, 0, true);
 }
 
Index: gcc/tree-vect-loop.c
===================================================================
--- a/src/gcc/tree-vect-loop.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/tree-vect-loop.c	(.../branches/gcc-4_9-branch)
@@ -2321,7 +2321,8 @@
         }
 
       def1 = SSA_NAME_DEF_STMT (op1);
-      if (flow_bb_inside_loop_p (loop, gimple_bb (def_stmt))
+      if (gimple_bb (def1)
+	  && flow_bb_inside_loop_p (loop, gimple_bb (def_stmt))
           && loop->inner
           && flow_bb_inside_loop_p (loop->inner, gimple_bb (def1))
           && is_gimple_assign (def1))
Index: gcc/gimplify.c
===================================================================
--- a/src/gcc/gimplify.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/gimplify.c	(.../branches/gcc-4_9-branch)
@@ -6263,7 +6263,7 @@
 		= splay_tree_lookup (ctx->variables, (splay_tree_key) decl);
 	      if (on && (on->value & (GOVD_FIRSTPRIVATE | GOVD_LASTPRIVATE
 				      | GOVD_PRIVATE | GOVD_REDUCTION
-				      | GOVD_LINEAR)) != 0)
+				      | GOVD_LINEAR | GOVD_MAP)) != 0)
 		break;
 	      ctx = ctx->outer_context;
 	    }
Index: gcc/lra-constraints.c
===================================================================
--- a/src/gcc/lra-constraints.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/lra-constraints.c	(.../branches/gcc-4_9-branch)
@@ -5752,6 +5752,20 @@
 			SUBREG_REG (SET_SRC (set)) = SET_SRC (prev_set);
 		      else
 			SET_SRC (set) = SET_SRC (prev_set);
+		      /* As we are finishing with processing the insn
+			 here, check the destination too as it might
+			 inheritance pseudo for another pseudo.  */
+		      if (bitmap_bit_p (remove_pseudos, dregno)
+			  && bitmap_bit_p (&lra_inheritance_pseudos, dregno)
+			  && (restore_regno
+			      = lra_reg_info[dregno].restore_regno) >= 0)
+			{
+			  if (GET_CODE (SET_DEST (set)) == SUBREG)
+			    SUBREG_REG (SET_DEST (set))
+			      = regno_reg_rtx[restore_regno];
+			  else
+			    SET_DEST (set) = regno_reg_rtx[restore_regno];
+			}
 		      lra_push_insn_and_update_insn_regno_info (curr_insn);
 		      lra_set_used_insn_alternative_by_uid
 			(INSN_UID (curr_insn), -1);
Index: gcc/emit-rtl.c
===================================================================
--- a/src/gcc/emit-rtl.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/emit-rtl.c	(.../branches/gcc-4_9-branch)
@@ -245,7 +245,7 @@
 
 /* Return true if the given memory attributes are equal.  */
 
-static bool
+bool
 mem_attrs_eq_p (const struct mem_attrs *p, const struct mem_attrs *q)
 {
   return (p->alias == q->alias
Index: gcc/gimple-fold.c
===================================================================
--- a/src/gcc/gimple-fold.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/gimple-fold.c	(.../branches/gcc-4_9-branch)
@@ -3104,8 +3104,8 @@
      result.  */
   if (!AGGREGATE_TYPE_P (TREE_TYPE (ctor)) && !offset
       /* VIEW_CONVERT_EXPR is defined only for matching sizes.  */
-      && operand_equal_p (TYPE_SIZE (type),
-			  TYPE_SIZE (TREE_TYPE (ctor)), 0))
+      && !compare_tree_int (TYPE_SIZE (type), size)
+      && !compare_tree_int (TYPE_SIZE (TREE_TYPE (ctor)), size))
     {
       ret = canonicalize_constructor_val (unshare_expr (ctor), from_decl);
       ret = fold_unary (VIEW_CONVERT_EXPR, type, ret);
Index: gcc/emit-rtl.h
===================================================================
--- a/src/gcc/emit-rtl.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/emit-rtl.h	(.../branches/gcc-4_9-branch)
@@ -20,6 +20,9 @@
 #ifndef GCC_EMIT_RTL_H
 #define GCC_EMIT_RTL_H
 
+/* Return whether two MEM_ATTRs are equal.  */
+bool mem_attrs_eq_p (const struct mem_attrs *, const struct mem_attrs *);
+
 /* Set the alias set of MEM to SET.  */
 extern void set_mem_alias_set (rtx, alias_set_type);
 
Index: gcc/tree-cfgcleanup.c
===================================================================
--- a/src/gcc/tree-cfgcleanup.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/tree-cfgcleanup.c	(.../branches/gcc-4_9-branch)
@@ -162,6 +162,23 @@
   return retval;
 }
 
+/* Cleanup the GF_CALL_CTRL_ALTERING flag according to
+   to updated gimple_call_flags.  */
+
+static void
+cleanup_call_ctrl_altering_flag (gimple bb_end)
+{
+  if (!is_gimple_call (bb_end)
+      || !gimple_call_ctrl_altering_p (bb_end))
+    return;
+
+  int flags = gimple_call_flags (bb_end);
+  if (((flags & (ECF_CONST | ECF_PURE))
+       && !(flags & ECF_LOOPING_CONST_OR_PURE))
+      || (flags & ECF_LEAF))
+    gimple_call_set_ctrl_altering (bb_end, false);
+}
+
 /* Try to remove superfluous control structures in basic block BB.  Returns
    true if anything changes.  */
 
@@ -182,6 +199,9 @@
 
   stmt = gsi_stmt (gsi);
 
+  /* Try to cleanup ctrl altering flag for call which ends bb.  */
+  cleanup_call_ctrl_altering_flag (stmt);
+
   if (gimple_code (stmt) == GIMPLE_COND
       || gimple_code (stmt) == GIMPLE_SWITCH)
     retval |= cleanup_control_expr_graph (bb, gsi);
@@ -594,30 +614,24 @@
    known not to return, and remove the unreachable code.  */
 
 static bool
-split_bbs_on_noreturn_calls (void)
+split_bb_on_noreturn_calls (basic_block bb)
 {
   bool changed = false;
-  gimple stmt;
-  basic_block bb;
+  gimple_stmt_iterator gsi;
 
-  /* Detect cases where a mid-block call is now known not to return.  */
-  if (cfun->gimple_df)
-    while (vec_safe_length (MODIFIED_NORETURN_CALLS (cfun)))
-      {
-	stmt = MODIFIED_NORETURN_CALLS (cfun)->pop ();
-	bb = gimple_bb (stmt);
-	/* BB might be deleted at this point, so verify first
-	   BB is present in the cfg.  */
-	if (bb == NULL
-	    || bb->index < NUM_FIXED_BLOCKS
-	    || bb->index >= last_basic_block_for_fn (cfun)
-	    || BASIC_BLOCK_FOR_FN (cfun, bb->index) != bb
-	    || !gimple_call_noreturn_p (stmt))
-	  continue;
+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
+    {
+      gimple stmt = gsi_stmt (gsi);
 
+      if (!is_gimple_call (stmt))
+	continue;
+
+      if (gimple_call_noreturn_p (stmt))
 	changed |= fixup_noreturn_call (stmt);
-      }
+    }
 
+  if (changed)
+    bitmap_set_bit (cfgcleanup_altered_bbs, bb->index);
   return changed;
 }
 
@@ -655,8 +669,6 @@
   basic_block bb;
   unsigned i, n;
 
-  retval |= split_bbs_on_noreturn_calls ();
-
   /* Prepare the worklists of altered blocks.  */
   cfgcleanup_altered_bbs = BITMAP_ALLOC (NULL);
 
@@ -672,7 +684,10 @@
     {
       bb = BASIC_BLOCK_FOR_FN (cfun, i);
       if (bb)
-	retval |= cleanup_tree_cfg_bb (bb);
+	{
+	  retval |= cleanup_tree_cfg_bb (bb);
+	  retval |= split_bb_on_noreturn_calls (bb);
+	}
     }
 
   /* Now process the altered blocks, as long as any are available.  */
@@ -689,9 +704,9 @@
 
       retval |= cleanup_tree_cfg_bb (bb);
 
-      /* Rerun split_bbs_on_noreturn_calls, in case we have altered any noreturn
+      /* Rerun split_bb_on_noreturn_calls, in case we have altered any noreturn
 	 calls.  */
-      retval |= split_bbs_on_noreturn_calls ();
+      retval |= split_bb_on_noreturn_calls (bb);
     }
 
   end_recording_case_labels ();
Index: gcc/lto/ChangeLog
===================================================================
--- a/src/gcc/lto/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/lto/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,11 @@
+2014-08-15  Bin Cheng  <bin.cheng@arm.com>
+
+	Backport from mainline
+	2014-08-08  Bin Cheng  <bin.cheng@arm.com>
+
+	PR lto/62032
+	* lto-lang.c (lto_init): Switch mis-matched arguments.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: gcc/lto/lto-lang.c
===================================================================
--- a/src/gcc/lto/lto-lang.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/lto/lto-lang.c	(.../branches/gcc-4_9-branch)
@@ -1186,10 +1186,10 @@
     }
   else
     {
-      lto_define_builtins (va_list_type_node,
-			   build_reference_type (va_list_type_node));
+      lto_define_builtins (build_reference_type (va_list_type_node),
+			   va_list_type_node);
     }
-  
+
   if (flag_cilkplus)
     cilk_init_builtins ();
 
Index: gcc/tree-ssa-copy.c
===================================================================
--- a/src/gcc/tree-ssa-copy.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/tree-ssa-copy.c	(.../branches/gcc-4_9-branch)
@@ -235,38 +235,26 @@
   enum ssa_prop_result retval = SSA_PROP_VARYING;
   location_t loc = gimple_location (stmt);
 
-  tree op0 = gimple_cond_lhs (stmt);
-  tree op1 = gimple_cond_rhs (stmt);
+  tree op0 = valueize_val (gimple_cond_lhs (stmt));
+  tree op1 = valueize_val (gimple_cond_rhs (stmt));
 
-  /* The only conditionals that we may be able to compute statically
-     are predicates involving two SSA_NAMEs.  */
-  if (TREE_CODE (op0) == SSA_NAME && TREE_CODE (op1) == SSA_NAME)
+  /* See if we can determine the predicate's value.  */
+  if (dump_file && (dump_flags & TDF_DETAILS))
     {
-      op0 = valueize_val (op0);
-      op1 = valueize_val (op1);
+      fprintf (dump_file, "Trying to determine truth value of ");
+      fprintf (dump_file, "predicate ");
+      print_gimple_stmt (dump_file, stmt, 0, 0);
+    }
 
-      /* See if we can determine the predicate's value.  */
-      if (dump_file && (dump_flags & TDF_DETAILS))
-	{
-	  fprintf (dump_file, "Trying to determine truth value of ");
-	  fprintf (dump_file, "predicate ");
-	  print_gimple_stmt (dump_file, stmt, 0, 0);
-	}
-
-      /* We can fold COND and get a useful result only when we have
-	 the same SSA_NAME on both sides of a comparison operator.  */
-      if (op0 == op1)
-	{
-	  tree folded_cond = fold_binary_loc (loc, gimple_cond_code (stmt),
-                                          boolean_type_node, op0, op1);
-	  if (folded_cond)
-	    {
-	      basic_block bb = gimple_bb (stmt);
-	      *taken_edge_p = find_taken_edge (bb, folded_cond);
-	      if (*taken_edge_p)
-		retval = SSA_PROP_INTERESTING;
-	    }
-	}
+  /* Fold COND and see whether we get a useful result.  */
+  tree folded_cond = fold_binary_loc (loc, gimple_cond_code (stmt),
+				      boolean_type_node, op0, op1);
+  if (folded_cond)
+    {
+      basic_block bb = gimple_bb (stmt);
+      *taken_edge_p = find_taken_edge (bb, folded_cond);
+      if (*taken_edge_p)
+	retval = SSA_PROP_INTERESTING;
     }
 
   if (dump_file && (dump_flags & TDF_DETAILS) && *taken_edge_p)
Index: gcc/sched-deps.c
===================================================================
--- a/src/gcc/sched-deps.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/sched-deps.c	(.../branches/gcc-4_9-branch)
@@ -2750,7 +2750,8 @@
 	   Consider for instance a volatile asm that changes the fpu rounding
 	   mode.  An insn should not be moved across this even if it only uses
 	   pseudo-regs because it might give an incorrectly rounded result.  */
-	if (code != ASM_OPERANDS || MEM_VOLATILE_P (x))
+	if ((code != ASM_OPERANDS || MEM_VOLATILE_P (x))
+	    && !DEBUG_INSN_P (insn))
 	  reg_pending_barrier = TRUE_BARRIER;
 
 	/* For all ASM_OPERANDS, we must traverse the vector of input operands.
@@ -4746,6 +4747,24 @@
 		  goto next;
 		}
 	    }
+
+	  /* The inc instruction could have clobbers, make sure those
+	     registers are not used in mem insn.  */
+	  for (def_rec = DF_INSN_DEFS (mii->inc_insn); *def_rec; def_rec++)
+	    if (!reg_overlap_mentioned_p (DF_REF_REG (*def_rec), mii->mem_reg0))
+	      {
+		df_ref *use_rec;
+		for (use_rec = DF_INSN_USES (mii->mem_insn); *use_rec; use_rec++)
+		  if (reg_overlap_mentioned_p (DF_REF_REG (*def_rec),
+					       DF_REF_REG (*use_rec)))
+		    {
+		      if (sched_verbose >= 5)
+			fprintf (sched_dump,
+				 "inc clobber used in store failure.\n");
+		      goto next;
+		    }
+	      }
+
 	  newaddr = mii->inc_input;
 	  if (mii->mem_index != NULL_RTX)
 	    newaddr = gen_rtx_PLUS (GET_MODE (newaddr), newaddr,
Index: gcc/config.gcc
===================================================================
--- a/src/gcc/config.gcc	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config.gcc	(.../branches/gcc-4_9-branch)
@@ -432,7 +432,7 @@
 nios2-*-*)
 	cpu_type=nios2
 	extra_options="${extra_options} g.opt"
-	;;	
+	;;
 picochip-*-*)
         cpu_type=picochip
         ;;
@@ -1129,8 +1129,7 @@
 	;;
 crisv32-*-linux* | cris-*-linux*)
 	tm_file="dbxelf.h elfos.h ${tm_file} gnu-user.h linux.h glibc-stdint.h cris/linux.h"
-	# We need to avoid using t-linux, so override default tmake_file
-	tmake_file="cris/t-cris cris/t-linux t-slibgcc t-linux"
+	tmake_file="${tmake_file} cris/t-cris cris/t-linux"
 	extra_options="${extra_options} cris/linux.opt"
 	case $target in
 	  cris-*-*)
@@ -2156,6 +2155,10 @@
 		tm_file="${tm_file} newlib-stdint.h nios2/elf.h"
 		extra_options="${extra_options} nios2/elf.opt"
 		;;
+	nios2-*-rtems*)
+		tm_file="${tm_file} newlib-stdint.h nios2/rtems.h rtems.h"
+		tmake_file="${tmake_file} t-rtems nios2/t-rtems"
+		;;
         esac
 	;;
 pdp11-*-*)
Index: gcc/gimple.h
===================================================================
--- a/src/gcc/gimple.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/gimple.h	(.../branches/gcc-4_9-branch)
@@ -90,6 +90,7 @@
     GF_CALL_NOTHROW		= 1 << 4,
     GF_CALL_ALLOCA_FOR_VAR	= 1 << 5,
     GF_CALL_INTERNAL		= 1 << 6,
+    GF_CALL_CTRL_ALTERING       = 1 << 7,
     GF_OMP_PARALLEL_COMBINED	= 1 << 0,
     GF_OMP_FOR_KIND_MASK	= 3 << 0,
     GF_OMP_FOR_KIND_FOR		= 0 << 0,
@@ -2447,7 +2448,30 @@
   return static_cast <const gimple_statement_call *> (gs)->u.internal_fn;
 }
 
+/* If CTRL_ALTERING_P is true, mark GIMPLE_CALL S to be a stmt
+   that could alter control flow.  */
 
+static inline void
+gimple_call_set_ctrl_altering (gimple s, bool ctrl_altering_p)
+{
+  GIMPLE_CHECK (s, GIMPLE_CALL);
+  if (ctrl_altering_p)
+    s->subcode |= GF_CALL_CTRL_ALTERING;
+  else
+    s->subcode &= ~GF_CALL_CTRL_ALTERING;
+}
+
+/* Return true if call GS calls an func whose GF_CALL_CTRL_ALTERING
+   flag is set. Such call could not be a stmt in the middle of a bb.  */
+
+static inline bool
+gimple_call_ctrl_altering_p (const_gimple gs)
+{
+  GIMPLE_CHECK (gs, GIMPLE_CALL);
+  return (gs->subcode & GF_CALL_CTRL_ALTERING) != 0;
+}
+
+
 /* Return the function type of the function called by GS.  */
 
 static inline tree
Index: gcc/tree-cfg.c
===================================================================
--- a/src/gcc/tree-cfg.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/tree-cfg.c	(.../branches/gcc-4_9-branch)
@@ -162,6 +162,7 @@
 static void gimple_make_forwarder_block (edge);
 static gimple first_non_label_stmt (basic_block);
 static bool verify_gimple_transaction (gimple);
+static bool call_can_make_abnormal_goto (gimple);
 
 /* Flowgraph optimization and cleanup.  */
 static void gimple_merge_blocks (basic_block, basic_block);
@@ -424,6 +425,32 @@
 }
 
 
+/* Initialize GF_CALL_CTRL_ALTERING flag, which indicates the call
+   could alter control flow except via eh. We initialize the flag at
+   CFG build time and only ever clear it later.  */
+
+static void
+gimple_call_initialize_ctrl_altering (gimple stmt)
+{
+  int flags = gimple_call_flags (stmt);
+
+  /* A call alters control flow if it can make an abnormal goto.  */
+  if (call_can_make_abnormal_goto (stmt)
+      /* A call also alters control flow if it does not return.  */
+      || flags & ECF_NORETURN
+      /* TM ending statements have backedges out of the transaction.
+	 Return true so we split the basic block containing them.
+	 Note that the TM_BUILTIN test is merely an optimization.  */
+      || ((flags & ECF_TM_BUILTIN)
+	  && is_tm_ending_fndecl (gimple_call_fndecl (stmt)))
+      /* BUILT_IN_RETURN call is same as return statement.  */
+      || gimple_call_builtin_p (stmt, BUILT_IN_RETURN))
+    gimple_call_set_ctrl_altering (stmt, true);
+  else
+    gimple_call_set_ctrl_altering (stmt, false);
+}
+
+
 /* Build a flowgraph for the sequence of stmts SEQ.  */
 
 static void
@@ -442,6 +469,9 @@
       prev_stmt = stmt;
       stmt = gsi_stmt (i);
 
+      if (stmt && is_gimple_call (stmt))
+	gimple_call_initialize_ctrl_altering (stmt);
+
       /* If the statement starts a new basic block or if we have determined
 	 in a previous pass that we need to create a new block for STMT, do
 	 so now.  */
@@ -2349,28 +2379,10 @@
   switch (gimple_code (t))
     {
     case GIMPLE_CALL:
-      {
-	int flags = gimple_call_flags (t);
-
-	/* A call alters control flow if it can make an abnormal goto.  */
-	if (call_can_make_abnormal_goto (t))
-	  return true;
-
-	/* A call also alters control flow if it does not return.  */
-	if (flags & ECF_NORETURN)
-	  return true;
-
-	/* TM ending statements have backedges out of the transaction.
-	   Return true so we split the basic block containing them.
-	   Note that the TM_BUILTIN test is merely an optimization.  */
-	if ((flags & ECF_TM_BUILTIN)
-	    && is_tm_ending_fndecl (gimple_call_fndecl (t)))
-	  return true;
-
-	/* BUILT_IN_RETURN call is same as return statement.  */
-	if (gimple_call_builtin_p (t, BUILT_IN_RETURN))
-	  return true;
-      }
+      /* Per stmt call flag indicates whether the call could alter
+	 controlflow.  */
+      if (gimple_call_ctrl_altering_p (t))
+	return true;
       break;
 
     case GIMPLE_EH_DISPATCH:
@@ -8470,6 +8482,8 @@
 		  && (!is_gimple_call (stmt)
 		      || (gimple_call_flags (stmt) & ECF_NORETURN) == 0)))
 	    {
+	      if (stmt && is_gimple_call (stmt))
+		gimple_call_set_ctrl_altering (stmt, false);
 	      stmt = gimple_build_call
 		  (builtin_decl_implicit (BUILT_IN_UNREACHABLE), 0);
 	      gimple_stmt_iterator gsi = gsi_last_bb (bb);
@@ -8480,10 +8494,6 @@
   if (count_scale != REG_BR_PROB_BASE)
     compute_function_frequency ();
 
-  /* We just processed all calls.  */
-  if (cfun->gimple_df)
-    vec_free (MODIFIED_NORETURN_CALLS (cfun));
-
   /* Dump a textual representation of the flowgraph.  */
   if (dump_file)
     gimple_dump_cfg (dump_file, dump_flags);
Index: gcc/config/alpha/elf.h
===================================================================
--- a/src/gcc/config/alpha/elf.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/alpha/elf.h	(.../branches/gcc-4_9-branch)
@@ -126,6 +126,10 @@
   "%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s} \
    %{shared|pie:crtendS.o%s;:crtend.o%s} crtn.o%s"
 
+/* This variable should be set to 'true' if the target ABI requires
+   unwinding tables even when exceptions are not used.  */
+#define TARGET_UNWIND_TABLES_DEFAULT true
+
 /* Select a format to encode pointers in exception handling data.  CODE
    is 0 for data, 1 for code labels, 2 for function pointers.  GLOBAL is
    true if the symbol may be affected by dynamic relocations.
Index: gcc/config/sparc/sync.md
===================================================================
--- a/src/gcc/config/sparc/sync.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/sparc/sync.md	(.../branches/gcc-4_9-branch)
@@ -64,11 +64,19 @@
   "stbar"
   [(set_attr "type" "multi")])
 
+;; For LEON3, STB has the effect of membar #StoreLoad.
+(define_insn "*membar_storeload_leon3"
+  [(set (match_operand:BLK 0 "" "")
+	(unspec:BLK [(match_dup 0) (const_int 2)] UNSPEC_MEMBAR))]
+  "TARGET_LEON3"
+  "stb\t%%g0, [%%sp-1]"
+  [(set_attr "type" "store")])
+
 ;; For V8, LDSTUB has the effect of membar #StoreLoad.
 (define_insn "*membar_storeload"
   [(set (match_operand:BLK 0 "" "")
 	(unspec:BLK [(match_dup 0) (const_int 2)] UNSPEC_MEMBAR))]
-  "TARGET_V8"
+  "TARGET_V8 && !TARGET_LEON3"
   "ldstub\t[%%sp-1], %%g0"
   [(set_attr "type" "multi")])
 
Index: gcc/config/i386/i386.h
===================================================================
--- a/src/gcc/config/i386/i386.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/i386/i386.h	(.../branches/gcc-4_9-branch)
@@ -457,6 +457,8 @@
 	ix86_tune_features[X86_TUNE_SPLIT_MEM_OPND_FOR_FP_CONVERTS]
 #define TARGET_ADJUST_UNROLL \
     ix86_tune_features[X86_TUNE_ADJUST_UNROLL]
+#define TARGET_AVOID_FALSE_DEP_FOR_BMI \
+	ix86_tune_features[X86_TUNE_AVOID_FALSE_DEP_FOR_BMI]
 
 /* Feature tests against the various architecture variations.  */
 enum ix86_arch_indices {
Index: gcc/config/i386/i386.md
===================================================================
--- a/src/gcc/config/i386/i386.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/i386/i386.md	(.../branches/gcc-4_9-branch)
@@ -111,6 +111,7 @@
   UNSPEC_LEA_ADDR
   UNSPEC_XBEGIN_ABORT
   UNSPEC_STOS
+  UNSPEC_INSN_FALSE_DEP
 
   ;; For SSE/MMX support:
   UNSPEC_FIX_NOTRUNC
@@ -11856,7 +11857,8 @@
       DONE;
     }
 
-  flags_mode = TARGET_BMI ? CCCmode : CCZmode;
+  flags_mode
+    = (TARGET_BMI && !TARGET_AVOID_FALSE_DEP_FOR_BMI) ? CCCmode : CCZmode;
 
   operands[2] = gen_reg_rtx (<MODE>mode);
   operands[3] = gen_rtx_REG (flags_mode, FLAGS_REG);
@@ -11882,7 +11884,8 @@
    (parallel [(set (match_dup 0) (plus:SI (match_dup 0) (const_int 1)))
 	      (clobber (reg:CC FLAGS_REG))])]
 {
-  enum machine_mode flags_mode = TARGET_BMI ? CCCmode : CCZmode;
+  enum machine_mode flags_mode
+    = (TARGET_BMI && !TARGET_AVOID_FALSE_DEP_FOR_BMI) ? CCCmode : CCZmode;
 
   operands[3] = gen_lowpart (QImode, operands[2]);
   operands[4] = gen_rtx_REG (flags_mode, FLAGS_REG);
@@ -11897,7 +11900,7 @@
 		     (const_int 0)))
    (set (match_operand:SWI48 0 "register_operand" "=r")
 	(ctz:SWI48 (match_dup 1)))]
-  "TARGET_BMI"
+  "TARGET_BMI && !TARGET_AVOID_FALSE_DEP_FOR_BMI"
   "tzcnt{<imodesuffix>}\t{%1, %0|%0, %1}"
   [(set_attr "type" "alu1")
    (set_attr "prefix_0f" "1")
@@ -11918,7 +11921,58 @@
    (set_attr "btver2_decode" "double")
    (set_attr "mode" "<MODE>")])
 
-(define_insn "ctz<mode>2"
+(define_expand "ctz<mode>2"
+  [(parallel
+    [(set (match_operand:SWI248 0 "register_operand")
+	  (ctz:SWI248
+	    (match_operand:SWI248 1 "nonimmediate_operand")))
+     (clobber (reg:CC FLAGS_REG))])])
+
+; False dependency happens when destination is only updated by tzcnt,
+; lzcnt or popcnt.  There is no false dependency when destination is
+; also used in source.
+(define_insn_and_split "*ctz<mode>2_falsedep_1"
+  [(set (match_operand:SWI48 0 "register_operand" "=r")
+	(ctz:SWI48
+	  (match_operand:SWI48 1 "nonimmediate_operand" "rm")))
+   (clobber (reg:CC FLAGS_REG))]
+  "(TARGET_BMI || TARGET_GENERIC)
+   && TARGET_AVOID_FALSE_DEP_FOR_BMI && optimize_function_for_speed_p (cfun)"
+  "#"
+  "&& reload_completed"
+  [(parallel
+    [(set (match_dup 0)
+	  (ctz:SWI48 (match_dup 1)))
+     (unspec [(match_dup 0)] UNSPEC_INSN_FALSE_DEP)
+     (clobber (reg:CC FLAGS_REG))])]
+{
+  if (!reg_mentioned_p (operands[0], operands[1]))
+    ix86_expand_clear (operands[0]);
+})
+
+(define_insn "*ctz<mode>2_falsedep"
+  [(set (match_operand:SWI48 0 "register_operand" "=r")
+	(ctz:SWI48
+	  (match_operand:SWI48 1 "nonimmediate_operand" "rm")))
+   (unspec [(match_operand:SWI48 2 "register_operand" "0")]
+	   UNSPEC_INSN_FALSE_DEP)
+   (clobber (reg:CC FLAGS_REG))]
+  ""
+{
+  if (TARGET_BMI)
+    return "tzcnt{<imodesuffix>}\t{%1, %0|%0, %1}";
+  else if (TARGET_GENERIC)
+    /* tzcnt expands to 'rep bsf' and we can use it even if !TARGET_BMI.  */
+    return "rep%; bsf{<imodesuffix>}\t{%1, %0|%0, %1}";
+  else
+    gcc_unreachable ();
+}
+  [(set_attr "type" "alu1")
+   (set_attr "prefix_0f" "1")
+   (set_attr "prefix_rep" "1")
+   (set_attr "mode" "<MODE>")])
+
+(define_insn "*ctz<mode>2"
   [(set (match_operand:SWI248 0 "register_operand" "=r")
 	(ctz:SWI248 (match_operand:SWI248 1 "nonimmediate_operand" "rm")))
    (clobber (reg:CC FLAGS_REG))]
@@ -11965,7 +12019,47 @@
   operands[2] = GEN_INT (GET_MODE_BITSIZE (<MODE>mode)-1);
 })
 
-(define_insn "clz<mode>2_lzcnt"
+(define_expand "clz<mode>2_lzcnt"
+  [(parallel
+    [(set (match_operand:SWI248 0 "register_operand")
+	  (clz:SWI248
+	    (match_operand:SWI248 1 "nonimmediate_operand")))
+     (clobber (reg:CC FLAGS_REG))])]
+  "TARGET_LZCNT")
+
+(define_insn_and_split "*clz<mode>2_lzcnt_falsedep_1"
+  [(set (match_operand:SWI48 0 "register_operand" "=r")
+	(clz:SWI48
+	  (match_operand:SWI48 1 "nonimmediate_operand" "rm")))
+   (clobber (reg:CC FLAGS_REG))]
+  "TARGET_LZCNT
+   && TARGET_AVOID_FALSE_DEP_FOR_BMI && optimize_function_for_speed_p (cfun)"
+  "#"
+  "&& reload_completed"
+  [(parallel
+    [(set (match_dup 0)
+	  (clz:SWI48 (match_dup 1)))
+     (unspec [(match_dup 0)] UNSPEC_INSN_FALSE_DEP)
+     (clobber (reg:CC FLAGS_REG))])]
+{
+  if (!reg_mentioned_p (operands[0], operands[1]))
+    ix86_expand_clear (operands[0]);
+})
+
+(define_insn "*clz<mode>2_lzcnt_falsedep"
+  [(set (match_operand:SWI48 0 "register_operand" "=r")
+	(clz:SWI48
+	  (match_operand:SWI48 1 "nonimmediate_operand" "rm")))
+   (unspec [(match_operand:SWI48 2 "register_operand" "0")]
+	   UNSPEC_INSN_FALSE_DEP)
+   (clobber (reg:CC FLAGS_REG))]
+  "TARGET_LZCNT"
+  "lzcnt{<imodesuffix>}\t{%1, %0|%0, %1}"
+  [(set_attr "prefix_rep" "1")
+   (set_attr "type" "bitmanip")
+   (set_attr "mode" "<MODE>")])
+
+(define_insn "*clz<mode>2_lzcnt"
   [(set (match_operand:SWI248 0 "register_operand" "=r")
 	(clz:SWI248 (match_operand:SWI248 1 "nonimmediate_operand" "rm")))
    (clobber (reg:CC FLAGS_REG))]
@@ -12248,11 +12342,40 @@
    (set_attr "prefix_0f" "1")
    (set_attr "mode" "HI")])
 
-(define_insn "popcount<mode>2"
-  [(set (match_operand:SWI248 0 "register_operand" "=r")
-	(popcount:SWI248
-	  (match_operand:SWI248 1 "nonimmediate_operand" "rm")))
+(define_expand "popcount<mode>2"
+  [(parallel
+    [(set (match_operand:SWI248 0 "register_operand")
+	  (popcount:SWI248
+	    (match_operand:SWI248 1 "nonimmediate_operand")))
+     (clobber (reg:CC FLAGS_REG))])]
+  "TARGET_POPCNT")
+
+(define_insn_and_split "*popcount<mode>2_falsedep_1"
+  [(set (match_operand:SWI48 0 "register_operand" "=r")
+	(popcount:SWI48
+	  (match_operand:SWI48 1 "nonimmediate_operand" "rm")))
    (clobber (reg:CC FLAGS_REG))]
+  "TARGET_POPCNT
+   && TARGET_AVOID_FALSE_DEP_FOR_BMI && optimize_function_for_speed_p (cfun)"
+  "#"
+  "&& reload_completed"
+  [(parallel
+    [(set (match_dup 0)
+	  (popcount:SWI48 (match_dup 1)))
+     (unspec [(match_dup 0)] UNSPEC_INSN_FALSE_DEP)
+     (clobber (reg:CC FLAGS_REG))])]
+{
+  if (!reg_mentioned_p (operands[0], operands[1]))
+    ix86_expand_clear (operands[0]);
+})
+
+(define_insn "*popcount<mode>2_falsedep"
+  [(set (match_operand:SWI48 0 "register_operand" "=r")
+	(popcount:SWI48
+	  (match_operand:SWI48 1 "nonimmediate_operand" "rm")))
+   (unspec [(match_operand:SWI48 2 "register_operand" "0")]
+	   UNSPEC_INSN_FALSE_DEP)
+   (clobber (reg:CC FLAGS_REG))]
   "TARGET_POPCNT"
 {
 #if TARGET_MACHO
@@ -12265,15 +12388,12 @@
    (set_attr "type" "bitmanip")
    (set_attr "mode" "<MODE>")])
 
-(define_insn "*popcount<mode>2_cmp"
-  [(set (reg FLAGS_REG)
-	(compare
-	  (popcount:SWI248
-	    (match_operand:SWI248 1 "nonimmediate_operand" "rm"))
-	  (const_int 0)))
-   (set (match_operand:SWI248 0 "register_operand" "=r")
-	(popcount:SWI248 (match_dup 1)))]
-  "TARGET_POPCNT && ix86_match_ccmode (insn, CCZmode)"
+(define_insn "*popcount<mode>2"
+  [(set (match_operand:SWI248 0 "register_operand" "=r")
+	(popcount:SWI248
+	  (match_operand:SWI248 1 "nonimmediate_operand" "rm")))
+   (clobber (reg:CC FLAGS_REG))]
+  "TARGET_POPCNT"
 {
 #if TARGET_MACHO
   return "popcnt\t{%1, %0|%0, %1}";
@@ -12285,25 +12405,6 @@
    (set_attr "type" "bitmanip")
    (set_attr "mode" "<MODE>")])
 
-(define_insn "*popcountsi2_cmp_zext"
-  [(set (reg FLAGS_REG)
-        (compare
-          (popcount:SI (match_operand:SI 1 "nonimmediate_operand" "rm"))
-          (const_int 0)))
-   (set (match_operand:DI 0 "register_operand" "=r")
-        (zero_extend:DI(popcount:SI (match_dup 1))))]
-  "TARGET_64BIT && TARGET_POPCNT && ix86_match_ccmode (insn, CCZmode)"
-{
-#if TARGET_MACHO
-  return "popcnt\t{%1, %0|%0, %1}";
-#else
-  return "popcnt{l}\t{%1, %0|%0, %1}";
-#endif
-}
-  [(set_attr "prefix_rep" "1")
-   (set_attr "type" "bitmanip")
-   (set_attr "mode" "SI")])
-
 (define_expand "bswapdi2"
   [(set (match_operand:DI 0 "register_operand")
 	(bswap:DI (match_operand:DI 1 "nonimmediate_operand")))]
Index: gcc/config/i386/x86-tune.def
===================================================================
--- a/src/gcc/config/i386/x86-tune.def	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/i386/x86-tune.def	(.../branches/gcc-4_9-branch)
@@ -500,6 +500,11 @@
 DEF_TUNE (X86_TUNE_AVOID_VECTOR_DECODE, "avoid_vector_decode",
           m_K8)
 
+/* X86_TUNE_AVOID_FALSE_DEP_FOR_BMI: Avoid false dependency
+   for bit-manipulation instructions.  */
+DEF_TUNE (X86_TUNE_AVOID_FALSE_DEP_FOR_BMI, "avoid_false_dep_for_bmi",
+	  m_SANDYBRIDGE | m_HASWELL | m_INTEL | m_GENERIC)
+
 /*****************************************************************************/
 /* This never worked well before.                                            */
 /*****************************************************************************/
Index: gcc/config/i386/sse.md
===================================================================
--- a/src/gcc/config/i386/sse.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/i386/sse.md	(.../branches/gcc-4_9-branch)
@@ -5887,9 +5887,10 @@
 	      (match_operand 5  "const_0_to_15_operand")]))
 	  (match_operand:<ssequartermode> 6 "memory_operand" "0")
 	  (match_operand:QI 7 "register_operand" "Yk")))]
-  "TARGET_AVX512F && (INTVAL (operands[2]) = INTVAL (operands[3]) - 1)
-  && (INTVAL (operands[3]) = INTVAL (operands[4]) - 1)
-  && (INTVAL (operands[4]) = INTVAL (operands[5]) - 1)"
+  "TARGET_AVX512F
+   && (INTVAL (operands[2]) == (INTVAL (operands[3]) - 1)
+       && INTVAL (operands[3]) == (INTVAL (operands[4]) - 1)
+       && INTVAL (operands[4]) == (INTVAL (operands[5]) - 1))"
 {
   operands[2] = GEN_INT ((INTVAL (operands[2])) >> 2);
   return "vextract<shuffletype>32x4\t{%2, %1, %0%{%7%}|%0%{%7%}, %1, %2}";
@@ -5909,9 +5910,10 @@
             (match_operand 3  "const_0_to_15_operand")
             (match_operand 4  "const_0_to_15_operand")
             (match_operand 5  "const_0_to_15_operand")])))]
-  "TARGET_AVX512F && (INTVAL (operands[2]) = INTVAL (operands[3]) - 1)
-  && (INTVAL (operands[3]) = INTVAL (operands[4]) - 1)
-  && (INTVAL (operands[4]) = INTVAL (operands[5]) - 1)"
+  "TARGET_AVX512F
+   && (INTVAL (operands[2]) == (INTVAL (operands[3]) - 1)
+       && INTVAL (operands[3]) == (INTVAL (operands[4]) - 1)
+       && INTVAL (operands[4]) == (INTVAL (operands[5]) - 1))"
 {
   operands[2] = GEN_INT ((INTVAL (operands[2])) >> 2);
   return "vextract<shuffletype>32x4\t{%2, %1, %0<mask_operand6>|%0<mask_operand6>, %1, %2}";
@@ -5992,9 +5994,9 @@
    (set_attr "mode" "<sseinsnmode>")])
 
 (define_insn "vec_extract_lo_<mode><mask_name>"
-  [(set (match_operand:<ssehalfvecmode> 0 "<store_mask_predicate>" "=<store_mask_constraint>")
+  [(set (match_operand:<ssehalfvecmode> 0 "<store_mask_predicate>" "=<store_mask_constraint>,v")
 	(vec_select:<ssehalfvecmode>
-	  (match_operand:V8FI 1 "nonimmediate_operand" "vm")
+	  (match_operand:V8FI 1 "nonimmediate_operand" "v,m")
 	  (parallel [(const_int 0) (const_int 1)
             (const_int 2) (const_int 3)])))]
   "TARGET_AVX512F && !(MEM_P (operands[0]) && MEM_P (operands[1]))"
Index: gcc/config/i386/avx512fintrin.h
===================================================================
--- a/src/gcc/config/i386/avx512fintrin.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/i386/avx512fintrin.h	(.../branches/gcc-4_9-branch)
@@ -8103,6 +8103,22 @@
   return __builtin_ia32_movntdqa512 ((__v8di *)__P);
 }
 
+/* Constants for mantissa extraction */
+typedef enum
+{
+  _MM_MANT_NORM_1_2,		/* interval [1, 2)      */
+  _MM_MANT_NORM_p5_2,		/* interval [0.5, 2)    */
+  _MM_MANT_NORM_p5_1,		/* interval [0.5, 1)    */
+  _MM_MANT_NORM_p75_1p5		/* interval [0.75, 1.5) */
+} _MM_MANTISSA_NORM_ENUM;
+
+typedef enum
+{
+  _MM_MANT_SIGN_src,		/* sign = sign(SRC)     */
+  _MM_MANT_SIGN_zero,		/* sign = 0             */
+  _MM_MANT_SIGN_nan		/* DEST = NaN if sign(SRC) = 1 */
+} _MM_MANTISSA_SIGN_ENUM;
+
 #ifdef __OPTIMIZE__
 extern __inline __m128
 __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
@@ -8182,22 +8198,6 @@
 						    (__mmask8) __U, __R);
 }
 
-/* Constants for mantissa extraction */
-typedef enum
-{
-  _MM_MANT_NORM_1_2,		/* interval [1, 2)      */
-  _MM_MANT_NORM_p5_2,		/* interval [0.5, 2)    */
-  _MM_MANT_NORM_p5_1,		/* interval [0.5, 1)    */
-  _MM_MANT_NORM_p75_1p5		/* interval [0.75, 1.5) */
-} _MM_MANTISSA_NORM_ENUM;
-
-typedef enum
-{
-  _MM_MANT_SIGN_src,		/* sign = sign(SRC)     */
-  _MM_MANT_SIGN_zero,		/* sign = 0             */
-  _MM_MANT_SIGN_nan		/* DEST = NaN if sign(SRC) = 1 */
-} _MM_MANTISSA_SIGN_ENUM;
-
 extern __inline __m512d
 __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
 _mm512_getmant_round_pd (__m512d __A, _MM_MANTISSA_NORM_ENUM __B,
Index: gcc/config/i386/ia32intrin.h
===================================================================
--- a/src/gcc/config/i386/ia32intrin.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/i386/ia32intrin.h	(.../branches/gcc-4_9-branch)
@@ -256,11 +256,7 @@
 
 #define _bswap64(a)		__bswapq(a)
 #define _popcnt64(a)		__popcntq(a)
-#define _lrotl(a,b)		__rolq((a), (b))
-#define _lrotr(a,b)		__rorq((a), (b))
 #else
-#define _lrotl(a,b)		__rold((a), (b))
-#define _lrotr(a,b)		__rord((a), (b))
 
 /* Read flags register */
 extern __inline unsigned int
@@ -280,6 +276,16 @@
 
 #endif
 
+/* On LP64 systems, longs are 64-bit.  Use the appropriate rotate
+ * function.  */
+#ifdef __LP64__
+#define _lrotl(a,b)		__rolq((a), (b))
+#define _lrotr(a,b)		__rorq((a), (b))
+#else
+#define _lrotl(a,b)		__rold((a), (b))
+#define _lrotr(a,b)		__rord((a), (b))
+#endif
+
 #define _bit_scan_forward(a)	__bsfd(a)
 #define _bit_scan_reverse(a)	__bsrd(a)
 #define _bswap(a)		__bswapd(a)
Index: gcc/config/i386/driver-i386.c
===================================================================
--- a/src/gcc/config/i386/driver-i386.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/i386/driver-i386.c	(.../branches/gcc-4_9-branch)
@@ -431,7 +431,8 @@
 
   model = (eax >> 4) & 0x0f;
   family = (eax >> 8) & 0x0f;
-  if (vendor == signature_INTEL_ebx)
+  if (vendor == signature_INTEL_ebx
+      || vendor == signature_AMD_ebx)
     {
       unsigned int extended_model, extended_family;
 
@@ -570,7 +571,7 @@
 
       if (name == signature_NSC_ebx)
 	processor = PROCESSOR_GEODE;
-      else if (has_movbe)
+      else if (has_movbe && family == 22)
 	processor = PROCESSOR_BTVER2;
       else if (has_avx2)
         processor = PROCESSOR_BDVER4;
Index: gcc/config/i386/i386.c
===================================================================
--- a/src/gcc/config/i386/i386.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/i386/i386.c	(.../branches/gcc-4_9-branch)
@@ -3258,12 +3258,13 @@
 	| PTA_FMA | PTA_PRFCHW | PTA_FXSR | PTA_XSAVE 
 	| PTA_XSAVEOPT | PTA_FSGSBASE},
      {"bdver4", PROCESSOR_BDVER4, CPU_BDVER4,
-        PTA_64BIT | PTA_MMX | PTA_SSE | PTA_SSE2 | PTA_SSE3
-        | PTA_SSE4A | PTA_CX16 | PTA_ABM | PTA_SSSE3 | PTA_SSE4_1
-        | PTA_SSE4_2 | PTA_AES | PTA_PCLMUL | PTA_AVX | PTA_AVX2 
+	PTA_64BIT | PTA_MMX | PTA_SSE | PTA_SSE2 | PTA_SSE3
+	| PTA_SSE4A | PTA_CX16 | PTA_ABM | PTA_SSSE3 | PTA_SSE4_1
+	| PTA_SSE4_2 | PTA_AES | PTA_PCLMUL | PTA_AVX | PTA_AVX2 
 	| PTA_FMA4 | PTA_XOP | PTA_LWP | PTA_BMI | PTA_BMI2 
 	| PTA_TBM | PTA_F16C | PTA_FMA | PTA_PRFCHW | PTA_FXSR 
-	| PTA_XSAVE | PTA_XSAVEOPT | PTA_FSGSBASE},
+	| PTA_XSAVE | PTA_XSAVEOPT | PTA_FSGSBASE | PTA_RDRND
+	| PTA_MOVBE},
       {"btver1", PROCESSOR_BTVER1, CPU_GENERIC,
 	PTA_64BIT | PTA_MMX |  PTA_SSE  | PTA_SSE2 | PTA_SSE3
 	| PTA_SSSE3 | PTA_SSE4A |PTA_ABM | PTA_CX16 | PTA_PRFCHW
@@ -6552,7 +6553,7 @@
 					   bit_offset);
 		  if (!num)
 		    return 0;
-		  for (i = 0; i < num; i++)
+		  for (i = 0; i < num && i < words; i++)
 		    classes[i] = merge_classes (subclasses[i], classes[i]);
 		}
 	    }
@@ -45092,8 +45093,10 @@
       /* t4: ((B*E)+(A*F))<<32, ((D*G)+(C*H))<<32 */
       emit_insn (gen_ashlv2di3 (t4, t3, GEN_INT (32)));
 
-      /* op0: (((B*E)+(A*F))<<32)+(B*F), (((D*G)+(C*H))<<32)+(D*H) */
-      emit_insn (gen_xop_pmacsdql (op0, op1, op2, t4));
+      /* Multiply lower parts and add all */
+      t5 = gen_reg_rtx (V2DImode);
+      emit_insn (gen_vec_widen_umult_even_v4si (t5, gen_lowpart (V4SImode, op1), gen_lowpart (V4SImode, op2)));
+      op0 = expand_binop (mode, add_optab, t5, t4, op0, 1, OPTAB_DIRECT);
     }
   else
     {
Index: gcc/config/sh/predicates.md
===================================================================
--- a/src/gcc/config/sh/predicates.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/sh/predicates.md	(.../branches/gcc-4_9-branch)
@@ -489,6 +489,10 @@
       rtx mem_rtx = MEM_P (op) ? op : SUBREG_REG (op);
       rtx x = XEXP (mem_rtx, 0);
 
+      if (! ALLOW_INDEXED_ADDRESS
+	  && GET_CODE (x) == PLUS && REG_P (XEXP (x, 0)) && REG_P (XEXP (x, 1)))
+	return false;
+
       if ((mode == QImode || mode == HImode)
 	  && GET_CODE (x) == PLUS
 	  && REG_P (XEXP (x, 0))
@@ -567,6 +571,10 @@
       rtx mem_rtx = MEM_P (op) ? op : SUBREG_REG (op);
       rtx x = XEXP (mem_rtx, 0);
 
+      if (! ALLOW_INDEXED_ADDRESS
+	  && GET_CODE (x) == PLUS && REG_P (XEXP (x, 0)) && REG_P (XEXP (x, 1)))
+	return false;
+
       if ((mode == QImode || mode == HImode)
 	  && GET_CODE (x) == PLUS
 	  && REG_P (XEXP (x, 0))
Index: gcc/config/sh/sh.c
===================================================================
--- a/src/gcc/config/sh/sh.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/sh/sh.c	(.../branches/gcc-4_9-branch)
@@ -10207,6 +10207,10 @@
 static bool
 sh_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)
 {
+  if (! ALLOW_INDEXED_ADDRESS
+      && GET_CODE (x) == PLUS && REG_P (XEXP (x, 0)) && REG_P (XEXP (x, 1)))
+    return false;
+
   if (REG_P (x) && REGNO (x) == GBR_REG)
     return true;
 
@@ -10436,6 +10440,28 @@
   enum reload_type type = (enum reload_type) itype;
   const int mode_sz = GET_MODE_SIZE (mode);
 
+  if (! ALLOW_INDEXED_ADDRESS
+      && GET_CODE (*p) == PLUS
+      && REG_P (XEXP (*p, 0)) && REG_P (XEXP (*p, 1)))
+    {
+      *p = copy_rtx (*p);
+      push_reload (*p, NULL_RTX, p, NULL,
+		   BASE_REG_CLASS, Pmode, VOIDmode, 0, 0, opnum, type);
+      return true;
+    }
+
+  if (! ALLOW_INDEXED_ADDRESS
+      && GET_CODE (*p) == PLUS
+      && GET_CODE (XEXP (*p, 0)) == PLUS)
+    {
+      rtx sum = gen_rtx_PLUS (Pmode, XEXP (XEXP (*p, 0), 0),
+				     XEXP (XEXP (*p, 0), 1));
+      *p = gen_rtx_PLUS (Pmode, sum, XEXP (*p, 1));
+      push_reload (sum, NULL_RTX, &XEXP (*p, 0), NULL,
+		   BASE_REG_CLASS, Pmode, VOIDmode, 0, 0, opnum, type);
+      return true;
+    }
+
   if (TARGET_SHMEDIA)
     return false;
 
Index: gcc/config/nios2/rtems.h
===================================================================
--- a/src/gcc/config/nios2/rtems.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/nios2/rtems.h	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,34 @@
+/* Definitions for rtems targeting a NIOS2 using ELF.
+   Copyright (C) 2011-2014 Free Software Foundation, Inc.
+
+   Contributed by Chris Johns (chrisj@rtems.org).
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* Specify predefined symbols in preprocessor.  */
+#define TARGET_OS_CPP_BUILTINS()        \
+do {                                    \
+  builtin_define ("__rtems__");         \
+  builtin_define ("__USE_INIT_FINI__"); \
+  builtin_assert ("system=rtems");      \
+} while (0)
+
+/* This toolchain implements the ABI for Linux Systems documented in the
+   Nios II Processor Reference Handbook.
+
+   This is done so RTEMS targets have Thread Local Storage like Linux.  */
+#define TARGET_LINUX_ABI 1
Index: gcc/config/nios2/t-rtems
===================================================================
--- a/src/gcc/config/nios2/t-rtems	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/nios2/t-rtems	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,133 @@
+# Custom RTEMS multilibs
+
+MULTILIB_OPTIONS = mhw-mul mhw-mulx mhw-div mcustom-fadds=253 mcustom-fdivs=255 mcustom-fmuls=252 mcustom-fsubs=254
+
+# Enumeration of multilibs
+
+# MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div/mcustom-fadds=253/mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div/mcustom-fadds=253/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div/mcustom-fadds=253/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div/mcustom-fadds=253/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div/mcustom-fadds=253
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div/mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div/mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div/mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div/mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div/mcustom-fsubs=254
+# MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mcustom-fadds=253/mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mcustom-fadds=253/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mcustom-fadds=253/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mcustom-fadds=253/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mcustom-fadds=253
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div/mcustom-fadds=253/mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div/mcustom-fadds=253/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div/mcustom-fadds=253/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div/mcustom-fadds=253/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div/mcustom-fadds=253
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div/mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div/mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div/mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div/mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div
+MULTILIB_EXCEPTIONS += mhw-mul/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mcustom-fadds=253/mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mhw-mul/mcustom-fadds=253/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mcustom-fadds=253/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mcustom-fadds=253/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mcustom-fadds=253
+MULTILIB_EXCEPTIONS += mhw-mul/mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mhw-mul/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mcustom-fsubs=254
+# MULTILIB_EXCEPTIONS += mhw-mul
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div/mcustom-fadds=253/mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div/mcustom-fadds=253/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div/mcustom-fadds=253/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div/mcustom-fadds=253/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div/mcustom-fadds=253
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div/mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div/mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div/mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div/mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div
+MULTILIB_EXCEPTIONS += mhw-mulx/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mulx/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx/mcustom-fadds=253/mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mhw-mulx/mcustom-fadds=253/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx/mcustom-fadds=253/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mulx/mcustom-fadds=253/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx/mcustom-fadds=253
+MULTILIB_EXCEPTIONS += mhw-mulx/mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx/mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mulx/mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx/mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mhw-mulx/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mulx/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx
+MULTILIB_EXCEPTIONS += mhw-div/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-div/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-div/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-div/mcustom-fadds=253/mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mhw-div/mcustom-fadds=253/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-div/mcustom-fadds=253/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-div/mcustom-fadds=253/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-div/mcustom-fadds=253
+MULTILIB_EXCEPTIONS += mhw-div/mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-div/mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-div/mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-div/mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mhw-div/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-div/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-div/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-div
+MULTILIB_EXCEPTIONS += mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mcustom-fadds=253/mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mcustom-fadds=253/mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mcustom-fadds=253/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mcustom-fadds=253/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mcustom-fadds=253/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mcustom-fadds=253
+MULTILIB_EXCEPTIONS += mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mcustom-fsubs=254
Index: gcc/config/cris/cris.md
===================================================================
--- a/src/gcc/config/cris/cris.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/cris/cris.md	(.../branches/gcc-4_9-branch)
@@ -919,6 +919,8 @@
     (match_operand:SI 1 "cris_general_operand_or_symbol" ""))]
   ""
 {
+  enum cris_symbol_type t;
+
   /* If the output goes to a MEM, make sure we have zero or a register as
      input.  */
   if (MEM_P (operands[0])
@@ -934,12 +936,12 @@
      valid symbol?  Can we exclude global PIC addresses with an added
      offset?  */
     if (flag_pic
-	&& CONSTANT_ADDRESS_P (operands[1])
+	&& CONSTANT_P (operands[1])
 	&& !cris_valid_pic_const (operands[1], false))
       {
-	enum cris_pic_symbol_type t = cris_pic_symbol_type_of (operands[1]);
+	t = cris_symbol_type_of (operands[1]);
 
-	gcc_assert (t != cris_no_symbol);
+	gcc_assert (t != cris_no_symbol && t != cris_offsettable_symbol);
 
 	if (! REG_S_P (operands[0]))
 	  {
@@ -1086,7 +1088,12 @@
 	 if (!flag_pic
 	     && (GET_CODE (operands[1]) == SYMBOL_REF
 		 || GET_CODE (operands[1]) == LABEL_REF
-		 || GET_CODE (operands[1]) == CONST))
+		 || (GET_CODE (operands[1]) == CONST
+		     && (GET_CODE (XEXP (operands[1], 0)) != UNSPEC
+			 || (XINT (XEXP (operands[1], 0), 1)
+			     == CRIS_UNSPEC_PLT_PCREL)
+			 || (XINT (XEXP (operands[1], 0), 1)
+			     == CRIS_UNSPEC_PCREL)))))
 	   {
 	     /* FIXME: Express this through (set_attr cc none) instead,
 		since we can't express the ``none'' at this point.  FIXME:
@@ -1169,6 +1176,12 @@
 	  case CRIS_UNSPEC_PCREL:
 	  case CRIS_UNSPEC_PLT_PCREL:
 	    gcc_assert (TARGET_V32);
+	    /* LAPC doesn't set condition codes; clear them to make the
+	       (equivalence-marked) result of this insn not presumed
+	       present.  This instruction can be a PIC symbol load (for
+	       a hidden symbol) which for weak symbols will be followed
+	       by a test for NULL.  */
+	    CC_STATUS_INIT;
 	    return "lapc %1,%0";
 
 	  default:
@@ -3710,15 +3723,16 @@
 {
   gcc_assert (MEM_P (operands[0]));
   if (flag_pic)
-    cris_expand_pic_call_address (&operands[0]);
+    cris_expand_pic_call_address (&operands[0], &operands[1]);
+  else
+    operands[1] = const0_rtx;
 })
 
-;; Accept *anything* as operand 1.  Accept operands for operand 0 in
-;; order of preference.
+;; Accept operands for operand 0 in order of preference.
 
 (define_insn "*expanded_call_non_v32"
   [(call (mem:QI (match_operand:SI 0 "general_operand" "r,Q>,g"))
-	 (match_operand 1 "" ""))
+	 (match_operand:SI 1 "cris_call_type_marker" "rM,rM,rM"))
    (clobber (reg:SI CRIS_SRP_REGNUM))]
   "!TARGET_V32"
   "jsr %0")
@@ -3727,7 +3741,7 @@
   [(call
     (mem:QI
      (match_operand:SI 0 "cris_nonmemory_operand_or_callable_symbol" "n,r,U,i"))
-    (match_operand 1 "" ""))
+    (match_operand:SI 1 "cris_call_type_marker" "rM,rM,rM,rM"))
    (clobber (reg:SI CRIS_SRP_REGNUM))]
   "TARGET_V32"
   "@
@@ -3740,7 +3754,7 @@
 ;; Parallel when calculating and reusing address of indirect pointer
 ;; with simple offset.  (Makes most sense with PIC.)  It looks a bit
 ;; wrong not to have the clobber last, but that's the way combine
-;; generates it (except it doesn' look into the *inner* mem, so this
+;; generates it (except it doesn't look into the *inner* mem, so this
 ;; just matches a peephole2).  FIXME: investigate that.
 (define_insn "*expanded_call_side"
   [(call (mem:QI
@@ -3747,12 +3761,14 @@
 	  (mem:SI
 	   (plus:SI (match_operand:SI 0 "cris_bdap_operand" "%r,  r,r")
 		    (match_operand:SI 1 "cris_bdap_operand" "r>Rn,r,>Rn"))))
-	 (match_operand 2 "" ""))
+	 (match_operand:SI 2 "cris_call_type_marker" "rM,rM,rM"))
    (clobber (reg:SI CRIS_SRP_REGNUM))
    (set (match_operand:SI 3 "register_operand" "=*0,r,r")
 	(plus:SI (match_dup 0)
 		 (match_dup 1)))]
-  "!TARGET_AVOID_GOTPLT && !TARGET_V32"
+  ;; Disabled until after reload until we can avoid an output reload for
+  ;; operand 3 (being forbidden for call insns).
+  "reload_completed && !TARGET_AVOID_GOTPLT && !TARGET_V32"
   "jsr [%3=%0%S1]")
 
 (define_expand "call_value"
@@ -3764,10 +3780,12 @@
 {
   gcc_assert (MEM_P (operands[1]));
   if (flag_pic)
-    cris_expand_pic_call_address (&operands[1]);
+    cris_expand_pic_call_address (&operands[1], &operands[2]);
+  else
+    operands[2] = const0_rtx;
 })
 
-;; Accept *anything* as operand 2.  The validity other than "general" of
+;; The validity other than "general" of
 ;; operand 0 will be checked elsewhere.  Accept operands for operand 1 in
 ;; order of preference (Q includes r, but r is shorter, faster).
 ;;  We also accept a PLT symbol.  We output it as [rPIC+sym:GOTPLT] rather
@@ -3776,7 +3794,7 @@
 (define_insn "*expanded_call_value_non_v32"
   [(set (match_operand 0 "nonimmediate_operand" "=g,g,g")
 	(call (mem:QI (match_operand:SI 1 "general_operand" "r,Q>,g"))
-	      (match_operand 2 "" "")))
+	      (match_operand:SI 2 "cris_call_type_marker" "rM,rM,rM")))
    (clobber (reg:SI CRIS_SRP_REGNUM))]
   "!TARGET_V32"
   "Jsr %1"
@@ -3790,12 +3808,14 @@
 	  (mem:SI
 	   (plus:SI (match_operand:SI 1 "cris_bdap_operand" "%r,  r,r")
 		    (match_operand:SI 2 "cris_bdap_operand" "r>Rn,r,>Rn"))))
-	      (match_operand 3 "" "")))
+	 (match_operand:SI 3 "cris_call_type_marker" "rM,rM,rM")))
    (clobber (reg:SI CRIS_SRP_REGNUM))
    (set (match_operand:SI 4 "register_operand" "=*1,r,r")
 	(plus:SI (match_dup 1)
 		 (match_dup 2)))]
-  "!TARGET_AVOID_GOTPLT && !TARGET_V32"
+  ;; Disabled until after reload until we can avoid an output reload for
+  ;; operand 4 (being forbidden for call insns).
+  "reload_completed && !TARGET_AVOID_GOTPLT && !TARGET_V32"
   "Jsr [%4=%1%S2]"
   [(set_attr "cc" "clobber")])
 
@@ -3805,7 +3825,7 @@
     (call
      (mem:QI
       (match_operand:SI 1 "cris_nonmemory_operand_or_callable_symbol" "n,r,U,i"))
-     (match_operand 2 "" "")))
+     (match_operand:SI 2 "cris_call_type_marker" "rM,rM,rM,rM")))
    (clobber (reg:SI 16))]
   "TARGET_V32"
   "@
@@ -4827,7 +4847,7 @@
   /* Make sure we have canonical RTX so we match the insn pattern -
      not a constant in the first operand.  We also require the order
      (plus reg mem) to match the final pattern.  */
-  if (CONSTANT_P (otherop) || MEM_P (otherop))
+  if (CRIS_CONSTANT_P (otherop) || MEM_P (otherop))
     {
       operands[7] = operands[1];
       operands[8] = otherop;
@@ -4878,7 +4898,7 @@
   /* Make sure we have canonical RTX so we match the insn pattern -
      not a constant in the first operand.  We also require the order
      (plus reg mem) to match the final pattern.  */
-  if (CONSTANT_P (otherop) || MEM_P (otherop))
+  if (CRIS_CONSTANT_P (otherop) || MEM_P (otherop))
     {
       operands[7] = operands[1];
       operands[8] = otherop;
Index: gcc/config/cris/cris.c
===================================================================
--- a/src/gcc/config/cris/cris.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/cris/cris.c	(.../branches/gcc-4_9-branch)
@@ -147,6 +147,7 @@
 static void cris_function_arg_advance (cumulative_args_t, enum machine_mode,
 				       const_tree, bool);
 static tree cris_md_asm_clobbers (tree, tree, tree);
+static bool cris_cannot_force_const_mem (enum machine_mode, rtx);
 
 static void cris_option_override (void);
 
@@ -214,6 +215,9 @@
 #undef TARGET_LEGITIMATE_ADDRESS_P
 #define TARGET_LEGITIMATE_ADDRESS_P cris_legitimate_address_p
 
+#undef TARGET_LEGITIMATE_CONSTANT_P
+#define TARGET_LEGITIMATE_CONSTANT_P cris_legitimate_constant_p
+
 #undef TARGET_PREFERRED_RELOAD_CLASS
 #define TARGET_PREFERRED_RELOAD_CLASS cris_preferred_reload_class
 
@@ -248,6 +252,10 @@
 #define TARGET_FUNCTION_ARG_ADVANCE cris_function_arg_advance
 #undef TARGET_MD_ASM_CLOBBERS
 #define TARGET_MD_ASM_CLOBBERS cris_md_asm_clobbers
+
+#undef TARGET_CANNOT_FORCE_CONST_MEM
+#define TARGET_CANNOT_FORCE_CONST_MEM cris_cannot_force_const_mem
+
 #undef TARGET_FRAME_POINTER_REQUIRED
 #define TARGET_FRAME_POINTER_REQUIRED cris_frame_pointer_required
 
@@ -506,6 +514,21 @@
   return crtl->uses_pic_offset_table;
 }
 
+/* Worker function for TARGET_CANNOT_FORCE_CONST_MEM.
+   We can't put PIC addresses in the constant pool, not even the ones that
+   can be reached as pc-relative as we can't tell when or how to do that.  */
+
+static bool
+cris_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)
+{
+  enum cris_symbol_type t = cris_symbol_type_of (x);
+
+  return
+    t == cris_unspec
+    || t == cris_got_symbol
+    || t == cris_rel_symbol;
+}
+
 /* Given an rtx, return the text string corresponding to the CODE of X.
    Intended for use in the assembly language output section of a
    define_insn.  */
@@ -601,7 +624,7 @@
 
   if (REG_P (index))
     fprintf (file, "$%s.b", reg_names[REGNO (index)]);
-  else if (CONSTANT_P (index))
+  else if (CRIS_CONSTANT_P (index))
     cris_output_addr_const (file, index);
   else if (GET_CODE (index) == MULT)
     {
@@ -1041,7 +1064,7 @@
       /* If this is a GOT symbol, force it to be emitted as :GOT and
 	 :GOTPLT regardless of -fpic (i.e. not as :GOT16, :GOTPLT16).
 	 Avoid making this too much of a special case.  */
-      if (flag_pic == 1 && CONSTANT_P (operand))
+      if (flag_pic == 1 && CRIS_CONSTANT_P (operand))
 	{
 	  int flag_pic_save = flag_pic;
 
@@ -1161,7 +1184,7 @@
     default:
       /* No need to handle all strange variants, let output_addr_const
 	 do it for us.  */
-      if (CONSTANT_P (operand))
+      if (CRIS_CONSTANT_P (operand))
 	{
 	  cris_output_addr_const (file, operand);
 	  return;
@@ -1358,7 +1381,7 @@
 bool
 cris_constant_index_p (const_rtx x)
 {
-  return (CONSTANT_P (x) && (!flag_pic || cris_valid_pic_const (x, true)));
+  return (CRIS_CONSTANT_P (x) && (!flag_pic || cris_valid_pic_const (x, true)));
 }
 
 /* True if X is a valid base register.  */
@@ -1467,6 +1490,29 @@
   return false;
 }
 
+/* Worker function for TARGET_LEGITIMATE_CONSTANT_P.  We have to handle
+   PIC constants that aren't legitimized.  FIXME: there used to be a
+   guarantee that the target LEGITIMATE_CONSTANT_P didn't have to handle
+   PIC constants, but no more (4.7 era); testcase: glibc init-first.c.
+   While that may be seen as a bug, that guarantee seems a wart by design,
+   so don't bother; fix the documentation instead.  */
+
+bool
+cris_legitimate_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)
+{
+  enum cris_symbol_type t;
+
+  if (flag_pic)
+    return LEGITIMATE_PIC_OPERAND_P (x);
+
+  t = cris_symbol_type_of (x);
+
+  return
+    t == cris_no_symbol
+    || t == cris_offsettable_symbol
+    || t == cris_unspec;
+}
+
 /* Worker function for LEGITIMIZE_RELOAD_ADDRESS.  */
 
 bool
@@ -2214,7 +2260,7 @@
 	return (2 + 2) / 2;
 
       /* A BDAP with some other constant is 2 bytes extra.  */
-      if (CONSTANT_P (tem2))
+      if (CRIS_CONSTANT_P (tem2))
 	return (2 + 2 + 2) / 2;
 
       /* BDAP with something indirect should have a higher cost than
@@ -2312,7 +2358,7 @@
 	return 0;
 
       /* Check allowed cases, like [r(+)?].[bwd] and const.  */
-      if (CONSTANT_P (val_rtx))
+      if (CRIS_CONSTANT_P (val_rtx))
 	return 1;
 
       if (MEM_P (val_rtx)
@@ -2464,32 +2510,34 @@
 	gcc_unreachable ();
       }
 
-  return cris_pic_symbol_type_of (x) == cris_no_symbol;
+  return cris_symbol_type_of (x) == cris_no_symbol;
 }
 
-/* Helper function to find the right PIC-type symbol to generate,
+/* Helper function to find the right symbol-type to generate,
    given the original (non-PIC) representation.  */
 
-enum cris_pic_symbol_type
-cris_pic_symbol_type_of (const_rtx x)
+enum cris_symbol_type
+cris_symbol_type_of (const_rtx x)
 {
   switch (GET_CODE (x))
     {
     case SYMBOL_REF:
-      return SYMBOL_REF_LOCAL_P (x)
-	? cris_rel_symbol : cris_got_symbol;
+      return flag_pic
+	? (SYMBOL_REF_LOCAL_P (x)
+	   ? cris_rel_symbol : cris_got_symbol)
+	: cris_offsettable_symbol;
 
     case LABEL_REF:
-      return cris_rel_symbol;
+      return flag_pic ? cris_rel_symbol : cris_offsettable_symbol;
 
     case CONST:
-      return cris_pic_symbol_type_of (XEXP (x, 0));
+      return cris_symbol_type_of (XEXP (x, 0));
 
     case PLUS:
     case MINUS:
       {
-	enum cris_pic_symbol_type t1 = cris_pic_symbol_type_of (XEXP (x, 0));
-	enum cris_pic_symbol_type t2 = cris_pic_symbol_type_of (XEXP (x, 1));
+	enum cris_symbol_type t1 = cris_symbol_type_of (XEXP (x, 0));
+	enum cris_symbol_type t2 = cris_symbol_type_of (XEXP (x, 1));
 
 	gcc_assert (t1 == cris_no_symbol || t2 == cris_no_symbol);
 
@@ -2504,9 +2552,7 @@
       return cris_no_symbol;
 
     case UNSPEC:
-      /* Likely an offsettability-test attempting to add a constant to
-	 a GOTREAD symbol, which can't be handled.  */
-      return cris_invalid_pic_symbol;
+      return cris_unspec;
 
     default:
       fatal_insn ("unrecognized supposed constant", x);
@@ -3714,19 +3760,19 @@
 /* Worker function for expanding the address for PIC function calls.  */
 
 void
-cris_expand_pic_call_address (rtx *opp)
+cris_expand_pic_call_address (rtx *opp, rtx *markerp)
 {
   rtx op = *opp;
 
-  gcc_assert (MEM_P (op));
+  gcc_assert (flag_pic && MEM_P (op));
   op = XEXP (op, 0);
 
   /* It might be that code can be generated that jumps to 0 (or to a
      specific address).  Don't die on that.  (There is a
      testcase.)  */
-  if (CONSTANT_ADDRESS_P (op) && !CONST_INT_P (op))
+  if (CONSTANT_P (op) && !CONST_INT_P (op))
     {
-      enum cris_pic_symbol_type t = cris_pic_symbol_type_of (op);
+      enum cris_symbol_type t = cris_symbol_type_of (op);
 
       CRIS_ASSERT (can_create_pseudo_p ());
 
@@ -3752,6 +3798,9 @@
 	    }
 	  else
 	    op = force_reg (Pmode, op);
+
+	  /* A local call.  */
+	  *markerp = const0_rtx;
 	}
       else if (t == cris_got_symbol)
 	{
@@ -3758,12 +3807,12 @@
 	  if (TARGET_AVOID_GOTPLT)
 	    {
 	      /* Change a "jsr sym" into (allocate register rM, rO)
-		 "move.d (const (unspec [sym rPIC] CRIS_UNSPEC_PLT_GOTREL)),rM"
+		 "move.d (const (unspec [sym] CRIS_UNSPEC_PLT_GOTREL)),rM"
 		 "add.d rPIC,rM,rO", "jsr rO" for pre-v32 and
-		 "jsr (const (unspec [sym rPIC] CRIS_UNSPEC_PLT_PCREL))"
+		 "jsr (const (unspec [sym] CRIS_UNSPEC_PLT_PCREL))"
 		 for v32.  */
 	      rtx tem, rm, ro;
-	      gcc_assert (can_create_pseudo_p ());
+
 	      crtl->uses_pic_offset_table = 1;
 	      tem = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op),
 				    TARGET_V32
@@ -3817,14 +3866,27 @@
 	      MEM_NOTRAP_P (mem) = 1;
 	      op = mem;
 	    }
+
+	  /* We need to prepare this call to go through the PLT; we
+	     need to make GOT available.  */
+	  *markerp = pic_offset_table_rtx;
 	}
       else
-	/* Can't possibly get a GOT-needing-fixup for a function-call,
-	   right?  */
+	/* Can't possibly get anything else for a function-call, right?  */
 	fatal_insn ("unidentifiable call op", op);
 
-      *opp = replace_equiv_address (*opp, op);
+      /* If the validizing variant is called, it will try to validize
+	 the address as a valid any-operand constant, but as it's only
+	 valid for calls and moves, it will fail and always be forced
+	 into a register.  */
+      *opp = replace_equiv_address_nv (*opp, op);
     }
+  else
+    /* Can't tell what locality a call to a non-constant address has;
+       better make the GOT register alive at it.
+       FIXME: Can we see whether the register has known constant
+       contents?  */
+    *markerp = pic_offset_table_rtx;
 }
 
 /* Make sure operands are in the right order for an addsi3 insn as
Index: gcc/config/cris/predicates.md
===================================================================
--- a/src/gcc/config/cris/predicates.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/cris/predicates.md	(.../branches/gcc-4_9-branch)
@@ -142,7 +142,7 @@
   (ior (match_operand 0 "general_operand")
        (and (match_code "const, symbol_ref, label_ref")
        	    ; The following test is actually just an assertion.
-	    (match_test "cris_pic_symbol_type_of (op) != cris_no_symbol"))))
+	    (match_test "cris_symbol_type_of (op) != cris_no_symbol"))))
 
 ;; A predicate for the anon movsi expansion, one that fits a PCREL
 ;; operand as well as general_operand.
@@ -176,3 +176,15 @@
        (ior (match_operand 0 "memory_operand")
 	    (match_test "cris_general_operand_or_symbol (XEXP (op, 0),
 							 Pmode)"))))
+
+;; A marker for the call-insn: (const_int 0) for a call to a
+;; hidden or static function and non-pic and
+;; pic_offset_table_rtx for a call that *might* go through the
+;; PLT.
+
+(define_predicate "cris_call_type_marker"
+  (ior (and (match_operand 0 "const_int_operand")
+	    (match_test "op == const0_rtx"))
+       (and (and (match_operand 0 "register_operand")
+		 (match_test "op == pic_offset_table_rtx"))
+	    (match_test "flag_pic != 0"))))
Index: gcc/config/cris/constraints.md
===================================================================
--- a/src/gcc/config/cris/constraints.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/cris/constraints.md	(.../branches/gcc-4_9-branch)
@@ -118,7 +118,7 @@
 						       reload_in_progress
 						       || reload_completed)"))
 	    ;; Just an explicit indirect reference: [const]?
-	    (match_test "CONSTANT_P (XEXP (op, 0))")
+	    (match_test "CRIS_CONSTANT_P (XEXP (op, 0))")
 	    ;; Something that is indexed; [...+...]?
 	    (and (match_code "plus" "0")
 		      ;; A BDAP constant: [reg+(8|16|32)bit offset]?
@@ -159,6 +159,8 @@
 (define_constraint "U"
   "@internal"
   (and (match_test "flag_pic")
+       ;; We're just interested in the ..._or_callable_symbol part.
+       ;; (Using CRIS_CONSTANT_P would exclude that too.)
        (match_test "CONSTANT_P (op)")
        (match_operand 0 "cris_nonmemory_operand_or_callable_symbol")))
 
Index: gcc/config/cris/cris.h
===================================================================
--- a/src/gcc/config/cris/cris.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/cris/cris.h	(.../branches/gcc-4_9-branch)
@@ -794,6 +794,12 @@
     }									\
   while (0)
 
+/* The mode argument to cris_legitimate_constant_p isn't used, so just
+   pass a cheap dummy.  N.B. we have to cast away const from the
+   parameter rather than adjust the parameter, as it's type is mandated
+   by the TARGET_LEGITIMATE_CONSTANT_P target hook interface.  */
+#define CRIS_CONSTANT_P(X) \
+  (CONSTANT_P (X) && cris_legitimate_constant_p (VOIDmode, CONST_CAST_RTX (X)))
 
 /* Node: Condition Code */
 
@@ -833,13 +839,14 @@
 
 /* Helper type.  */
 
-enum cris_pic_symbol_type
+enum cris_symbol_type
   {
     cris_no_symbol = 0,
     cris_got_symbol = 1,
     cris_rel_symbol = 2,
     cris_got_symbol_needing_fixup = 3,
-    cris_invalid_pic_symbol = 4
+    cris_unspec = 7,
+    cris_offsettable_symbol = 8
   };
 
 #define PIC_OFFSET_TABLE_REGNUM (flag_pic ? CRIS_GOT_REGNUM : INVALID_REGNUM)
Index: gcc/config/cris/cris-protos.h
===================================================================
--- a/src/gcc/config/cris/cris-protos.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/cris/cris-protos.h	(.../branches/gcc-4_9-branch)
@@ -31,8 +31,9 @@
 extern rtx cris_return_addr_rtx (int, rtx);
 extern rtx cris_split_movdx (rtx *);
 extern int cris_legitimate_pic_operand (rtx);
-extern enum cris_pic_symbol_type cris_pic_symbol_type_of (const_rtx);
+extern enum cris_symbol_type cris_symbol_type_of (const_rtx);
 extern bool cris_valid_pic_const (const_rtx, bool);
+extern bool cris_legitimate_constant_p (enum machine_mode, rtx);
 extern bool cris_constant_index_p (const_rtx);
 extern bool cris_base_p (const_rtx, bool);
 extern bool cris_base_or_autoincr_p (const_rtx, bool);
@@ -46,7 +47,7 @@
 extern void cris_asm_output_case_end (FILE *, int, rtx);
 extern rtx cris_gen_movem_load (rtx, rtx, int);
 extern rtx cris_emit_movem_store (rtx, rtx, int, bool);
-extern void cris_expand_pic_call_address (rtx *);
+extern void cris_expand_pic_call_address (rtx *, rtx *);
 extern void cris_order_for_addsi3 (rtx *, int);
 extern void cris_emit_trap_for_misalignment (rtx);
 #endif /* RTX_CODE */
Index: gcc/config/aarch64/aarch64-linux.h
===================================================================
--- a/src/gcc/config/aarch64/aarch64-linux.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/aarch64/aarch64-linux.h	(.../branches/gcc-4_9-branch)
@@ -44,4 +44,6 @@
     }						\
   while (0)
 
+#define TARGET_ASM_FILE_END file_end_indicate_exec_stack
+
 #endif  /* GCC_AARCH64_LINUX_H */
Index: gcc/config/rs6000/constraints.md
===================================================================
--- a/src/gcc/config/rs6000/constraints.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/rs6000/constraints.md	(.../branches/gcc-4_9-branch)
@@ -68,6 +68,20 @@
 (define_register_constraint "wg" "rs6000_constraints[RS6000_CONSTRAINT_wg]"
   "If -mmfpgpr was used, a floating point register or NO_REGS.")
 
+(define_register_constraint "wh" "rs6000_constraints[RS6000_CONSTRAINT_wh]"
+  "Floating point register if direct moves are available, or NO_REGS.")
+
+;; At present, DImode is not allowed in the Altivec registers.  If in the
+;; future it is allowed, wi/wj can be set to VSX_REGS instead of FLOAT_REGS.
+(define_register_constraint "wi" "rs6000_constraints[RS6000_CONSTRAINT_wi]"
+  "FP or VSX register to hold 64-bit integers for VSX insns or NO_REGS.")
+
+(define_register_constraint "wj" "rs6000_constraints[RS6000_CONSTRAINT_wj]"
+  "FP or VSX register to hold 64-bit integers for direct moves or NO_REGS.")
+
+(define_register_constraint "wk" "rs6000_constraints[RS6000_CONSTRAINT_wk]"
+  "FP or VSX register to hold 64-bit doubles for direct moves or NO_REGS.")
+
 (define_register_constraint "wl" "rs6000_constraints[RS6000_CONSTRAINT_wl]"
   "Floating point register if the LFIWAX instruction is enabled or NO_REGS.")
 
@@ -101,7 +115,7 @@
   "Floating point register if the STFIWX instruction is enabled or NO_REGS.")
 
 (define_register_constraint "wy" "rs6000_constraints[RS6000_CONSTRAINT_wy]"
-  "VSX vector register to hold scalar float values or NO_REGS.")
+  "FP or VSX register to perform ISA 2.07 float ops or NO_REGS.")
 
 (define_register_constraint "wz" "rs6000_constraints[RS6000_CONSTRAINT_wz]"
   "Floating point register if the LFIWZX instruction is enabled or NO_REGS.")
Index: gcc/config/rs6000/freebsd64.h
===================================================================
--- a/src/gcc/config/rs6000/freebsd64.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/rs6000/freebsd64.h	(.../branches/gcc-4_9-branch)
@@ -367,7 +367,7 @@
 /* PowerPC64 Linux word-aligns FP doubles when -malign-power is given.  */
 #undef  ADJUST_FIELD_ALIGN
 #define ADJUST_FIELD_ALIGN(FIELD, COMPUTED) \
-  ((TARGET_ALTIVEC && TREE_CODE (TREE_TYPE (FIELD)) == VECTOR_TYPE)     \
+  (rs6000_special_adjust_field_align_p ((FIELD), (COMPUTED))		\
    ? 128                                                                \
    : (TARGET_64BIT                                                      \
       && TARGET_ALIGN_NATURAL == 0                                      \
Index: gcc/config/rs6000/rs6000-protos.h
===================================================================
--- a/src/gcc/config/rs6000/rs6000-protos.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/rs6000/rs6000-protos.h	(.../branches/gcc-4_9-branch)
@@ -155,6 +155,7 @@
 
 #ifdef TREE_CODE
 extern unsigned int rs6000_data_alignment (tree, unsigned int, enum data_align);
+extern bool rs6000_special_adjust_field_align_p (tree, unsigned int);
 extern unsigned int rs6000_special_round_type_align (tree, unsigned int,
 						     unsigned int);
 extern unsigned int darwin_rs6000_special_round_type_align (tree, unsigned int,
Index: gcc/config/rs6000/linux64.h
===================================================================
--- a/src/gcc/config/rs6000/linux64.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/rs6000/linux64.h	(.../branches/gcc-4_9-branch)
@@ -246,7 +246,7 @@
 /* PowerPC64 Linux word-aligns FP doubles when -malign-power is given.  */
 #undef  ADJUST_FIELD_ALIGN
 #define ADJUST_FIELD_ALIGN(FIELD, COMPUTED) \
-  ((TARGET_ALTIVEC && TREE_CODE (TREE_TYPE (FIELD)) == VECTOR_TYPE)	\
+  (rs6000_special_adjust_field_align_p ((FIELD), (COMPUTED))		\
    ? 128								\
    : (TARGET_64BIT							\
       && TARGET_ALIGN_NATURAL == 0					\
Index: gcc/config/rs6000/rs6000.c
===================================================================
--- a/src/gcc/config/rs6000/rs6000.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/rs6000/rs6000.c	(.../branches/gcc-4_9-branch)
@@ -388,6 +388,7 @@
   enum insn_code reload_gpr_vsx;	/* INSN to move from GPR to VSX.  */
   enum insn_code reload_vsx_gpr;	/* INSN to move from VSX to GPR.  */
   addr_mask_type addr_mask[(int)N_RELOAD_REG]; /* Valid address masks.  */
+  bool scalar_in_vmx_p;			/* Scalar value can go in VMX.  */
 };
 
 static struct rs6000_reg_addr reg_addr[NUM_MACHINE_MODES];
@@ -1221,7 +1222,12 @@
       /* Soft frame pointer.  */
       "sfp",
       /* HTM SPR registers.  */
-      "tfhar", "tfiar", "texasr"
+      "tfhar", "tfiar", "texasr",
+      /* SPE High registers.  */
+      "0",  "1",  "2",  "3",  "4",  "5",  "6",  "7",
+      "8",  "9", "10", "11", "12", "13", "14", "15",
+     "16", "17", "18", "19", "20", "21", "22", "23",
+     "24", "25", "26", "27", "28", "29", "30", "31"
 };
 
 #ifdef TARGET_REGNAMES
@@ -1249,7 +1255,12 @@
   /* Soft frame pointer.  */
   "sfp",
   /* HTM SPR registers.  */
-  "tfhar", "tfiar", "texasr"
+  "tfhar", "tfiar", "texasr",
+  /* SPE High registers.  */
+  "%rh0",  "%rh1",  "%rh2",  "%rh3",  "%rh4",  "%rh5",  "%rh6",   "%rh7",
+  "%rh8",  "%rh9",  "%rh10", "%r11",  "%rh12", "%rh13", "%rh14", "%rh15",
+  "%rh16", "%rh17", "%rh18", "%rh19", "%rh20", "%rh21", "%rh22", "%rh23",
+  "%rh24", "%rh25", "%rh26", "%rh27", "%rh28", "%rh29", "%rh30", "%rh31"
 };
 #endif
 
@@ -1723,8 +1734,7 @@
      asked for it.  */
   if (TARGET_VSX && VSX_REGNO_P (regno)
       && (VECTOR_MEM_VSX_P (mode)
-	  || (TARGET_VSX_SCALAR_FLOAT && mode == SFmode)
-	  || (TARGET_VSX_SCALAR_DOUBLE && (mode == DFmode || mode == DImode))
+	  || reg_addr[mode].scalar_in_vmx_p
 	  || (TARGET_VSX_TIMODE && mode == TImode)
 	  || (TARGET_VADDUQM && mode == V1TImode)))
     {
@@ -1733,12 +1743,9 @@
 
       if (ALTIVEC_REGNO_P (regno))
 	{
-	  if (mode == SFmode && !TARGET_UPPER_REGS_SF)
+	  if (GET_MODE_SIZE (mode) != 16 && !reg_addr[mode].scalar_in_vmx_p)
 	    return 0;
 
-	  if ((mode == DFmode || mode == DImode) && !TARGET_UPPER_REGS_DF)
-	    return 0;
-
 	  return ALTIVEC_REGNO_P (last_regno);
 	}
     }
@@ -1916,14 +1923,16 @@
   if (rs6000_vector_unit[m] != VECTOR_NONE
       || rs6000_vector_mem[m] != VECTOR_NONE
       || (reg_addr[m].reload_store != CODE_FOR_nothing)
-      || (reg_addr[m].reload_load != CODE_FOR_nothing))
+      || (reg_addr[m].reload_load != CODE_FOR_nothing)
+      || reg_addr[m].scalar_in_vmx_p)
     {
       fprintf (stderr,
-	       "  Vector-arith=%-10s Vector-mem=%-10s Reload=%c%c",
+	       "  Vector-arith=%-10s Vector-mem=%-10s Reload=%c%c Upper=%c",
 	       rs6000_debug_vector_unit (rs6000_vector_unit[m]),
 	       rs6000_debug_vector_unit (rs6000_vector_mem[m]),
 	       (reg_addr[m].reload_store != CODE_FOR_nothing) ? 's' : '*',
-	       (reg_addr[m].reload_load != CODE_FOR_nothing) ? 'l' : '*');
+	       (reg_addr[m].reload_load != CODE_FOR_nothing) ? 'l' : '*',
+	       (reg_addr[m].scalar_in_vmx_p) ? 'y' : 'n');
     }
 
   fputs ("\n", stderr);
@@ -2040,6 +2049,10 @@
 	   "wd reg_class = %s\n"
 	   "wf reg_class = %s\n"
 	   "wg reg_class = %s\n"
+	   "wh reg_class = %s\n"
+	   "wi reg_class = %s\n"
+	   "wj reg_class = %s\n"
+	   "wk reg_class = %s\n"
 	   "wl reg_class = %s\n"
 	   "wm reg_class = %s\n"
 	   "wr reg_class = %s\n"
@@ -2059,6 +2072,10 @@
 	   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wd]],
 	   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wf]],
 	   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wg]],
+	   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wh]],
+	   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wi]],
+	   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wj]],
+	   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wk]],
 	   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wl]],
 	   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wm]],
 	   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wr]],
@@ -2347,6 +2364,8 @@
 
   for (m = 0; m < NUM_MACHINE_MODES; ++m)
     {
+      enum machine_mode m2 = (enum machine_mode)m;
+
       /* SDmode is special in that we want to access it only via REG+REG
 	 addressing on power7 and above, since we want to use the LFIWZX and
 	 STFIWZX instructions to load it.  */
@@ -2381,13 +2400,12 @@
 
 	      if (TARGET_UPDATE
 		  && (rc == RELOAD_REG_GPR || rc == RELOAD_REG_FPR)
-		  && GET_MODE_SIZE (m) <= 8
-		  && !VECTOR_MODE_P (m)
-		  && !COMPLEX_MODE_P (m)
+		  && GET_MODE_SIZE (m2) <= 8
+		  && !VECTOR_MODE_P (m2)
+		  && !COMPLEX_MODE_P (m2)
 		  && !indexed_only_p
-		  && !(TARGET_E500_DOUBLE && GET_MODE_SIZE (m) == 8)
-		  && !(m == DFmode && TARGET_UPPER_REGS_DF)
-		  && !(m == SFmode && TARGET_UPPER_REGS_SF))
+		  && !(TARGET_E500_DOUBLE && GET_MODE_SIZE (m2) == 8)
+		  && !reg_addr[m2].scalar_in_vmx_p)
 		{
 		  addr_mask |= RELOAD_REG_PRE_INCDEC;
 
@@ -2618,16 +2636,22 @@
 	f  - Register class to use with traditional SFmode instructions.
 	v  - Altivec register.
 	wa - Any VSX register.
+	wc - Reserved to represent individual CR bits (used in LLVM).
 	wd - Preferred register class for V2DFmode.
 	wf - Preferred register class for V4SFmode.
 	wg - Float register for power6x move insns.
+	wh - FP register for direct move instructions.
+	wi - FP or VSX register to hold 64-bit integers for VSX insns.
+	wj - FP or VSX register to hold 64-bit integers for direct moves.
+	wk - FP or VSX register to hold 64-bit doubles for direct moves.
 	wl - Float register if we can do 32-bit signed int loads.
 	wm - VSX register for ISA 2.07 direct move operations.
+	wn - always NO_REGS.
 	wr - GPR if 64-bit mode is permitted.
 	ws - Register class to do ISA 2.06 DF operations.
+	wt - VSX register for TImode in VSX registers.
 	wu - Altivec register for ISA 2.07 VSX SF/SI load/stores.
 	wv - Altivec register for ISA 2.06 VSX DF/DI load/stores.
-	wt - VSX register for TImode in VSX registers.
 	ww - Register class to do SF conversions in with VSX operations.
 	wx - Float register if we can do 32-bit int stores.
 	wy - Register class to do ISA 2.07 SF operations.
@@ -2634,21 +2658,22 @@
 	wz - Float register if we can do 32-bit unsigned int loads.  */
 
   if (TARGET_HARD_FLOAT && TARGET_FPRS)
-    rs6000_constraints[RS6000_CONSTRAINT_f] = FLOAT_REGS;
+    rs6000_constraints[RS6000_CONSTRAINT_f] = FLOAT_REGS;	/* SFmode  */
 
   if (TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT)
-    rs6000_constraints[RS6000_CONSTRAINT_d] = FLOAT_REGS;
+    rs6000_constraints[RS6000_CONSTRAINT_d]  = FLOAT_REGS;	/* DFmode  */
 
   if (TARGET_VSX)
     {
       rs6000_constraints[RS6000_CONSTRAINT_wa] = VSX_REGS;
-      rs6000_constraints[RS6000_CONSTRAINT_wd] = VSX_REGS;
-      rs6000_constraints[RS6000_CONSTRAINT_wf] = VSX_REGS;
+      rs6000_constraints[RS6000_CONSTRAINT_wd] = VSX_REGS;	/* V2DFmode  */
+      rs6000_constraints[RS6000_CONSTRAINT_wf] = VSX_REGS;	/* V4SFmode  */
+      rs6000_constraints[RS6000_CONSTRAINT_wi] = FLOAT_REGS;	/* DImode  */
 
       if (TARGET_VSX_TIMODE)
-	rs6000_constraints[RS6000_CONSTRAINT_wt] = VSX_REGS;
+	rs6000_constraints[RS6000_CONSTRAINT_wt] = VSX_REGS;	/* TImode  */
 
-      if (TARGET_UPPER_REGS_DF)
+      if (TARGET_UPPER_REGS_DF)					/* DFmode  */
 	{
 	  rs6000_constraints[RS6000_CONSTRAINT_ws] = VSX_REGS;
 	  rs6000_constraints[RS6000_CONSTRAINT_wv] = ALTIVEC_REGS;
@@ -2662,19 +2687,26 @@
   if (TARGET_ALTIVEC)
     rs6000_constraints[RS6000_CONSTRAINT_v] = ALTIVEC_REGS;
 
-  if (TARGET_MFPGPR)
+  if (TARGET_MFPGPR)						/* DFmode  */
     rs6000_constraints[RS6000_CONSTRAINT_wg] = FLOAT_REGS;
 
   if (TARGET_LFIWAX)
-    rs6000_constraints[RS6000_CONSTRAINT_wl] = FLOAT_REGS;
+    rs6000_constraints[RS6000_CONSTRAINT_wl] = FLOAT_REGS;	/* DImode  */
 
   if (TARGET_DIRECT_MOVE)
-    rs6000_constraints[RS6000_CONSTRAINT_wm] = VSX_REGS;
+    {
+      rs6000_constraints[RS6000_CONSTRAINT_wh] = FLOAT_REGS;
+      rs6000_constraints[RS6000_CONSTRAINT_wj]			/* DImode  */
+	= rs6000_constraints[RS6000_CONSTRAINT_wi];
+      rs6000_constraints[RS6000_CONSTRAINT_wk]			/* DFmode  */
+	= rs6000_constraints[RS6000_CONSTRAINT_ws];
+      rs6000_constraints[RS6000_CONSTRAINT_wm] = VSX_REGS;
+    }
 
   if (TARGET_POWERPC64)
     rs6000_constraints[RS6000_CONSTRAINT_wr] = GENERAL_REGS;
 
-  if (TARGET_P8_VECTOR && TARGET_UPPER_REGS_SF)
+  if (TARGET_P8_VECTOR && TARGET_UPPER_REGS_SF)			/* SFmode  */
     {
       rs6000_constraints[RS6000_CONSTRAINT_wu] = ALTIVEC_REGS;
       rs6000_constraints[RS6000_CONSTRAINT_wy] = VSX_REGS;
@@ -2689,10 +2721,10 @@
     rs6000_constraints[RS6000_CONSTRAINT_ww] = FLOAT_REGS;
 
   if (TARGET_STFIWX)
-    rs6000_constraints[RS6000_CONSTRAINT_wx] = FLOAT_REGS;
+    rs6000_constraints[RS6000_CONSTRAINT_wx] = FLOAT_REGS;	/* DImode  */
 
   if (TARGET_LFIWZX)
-    rs6000_constraints[RS6000_CONSTRAINT_wz] = FLOAT_REGS;
+    rs6000_constraints[RS6000_CONSTRAINT_wz] = FLOAT_REGS;	/* DImode  */
 
   /* Set up the reload helper and direct move functions.  */
   if (TARGET_VSX || TARGET_ALTIVEC)
@@ -2715,10 +2747,11 @@
 	  reg_addr[V2DFmode].reload_load   = CODE_FOR_reload_v2df_di_load;
 	  if (TARGET_VSX && TARGET_UPPER_REGS_DF)
 	    {
-	      reg_addr[DFmode].reload_store  = CODE_FOR_reload_df_di_store;
-	      reg_addr[DFmode].reload_load   = CODE_FOR_reload_df_di_load;
-	      reg_addr[DDmode].reload_store  = CODE_FOR_reload_dd_di_store;
-	      reg_addr[DDmode].reload_load   = CODE_FOR_reload_dd_di_load;
+	      reg_addr[DFmode].reload_store    = CODE_FOR_reload_df_di_store;
+	      reg_addr[DFmode].reload_load     = CODE_FOR_reload_df_di_load;
+	      reg_addr[DFmode].scalar_in_vmx_p = true;
+	      reg_addr[DDmode].reload_store    = CODE_FOR_reload_dd_di_store;
+	      reg_addr[DDmode].reload_load     = CODE_FOR_reload_dd_di_load;
 	    }
 	  if (TARGET_P8_VECTOR)
 	    {
@@ -2726,6 +2759,8 @@
 	      reg_addr[SFmode].reload_load   = CODE_FOR_reload_sf_di_load;
 	      reg_addr[SDmode].reload_store  = CODE_FOR_reload_sd_di_store;
 	      reg_addr[SDmode].reload_load   = CODE_FOR_reload_sd_di_load;
+	      if (TARGET_UPPER_REGS_SF)
+		reg_addr[SFmode].scalar_in_vmx_p = true;
 	    }
 	  if (TARGET_VSX_TIMODE)
 	    {
@@ -2782,10 +2817,11 @@
 	  reg_addr[V2DFmode].reload_load   = CODE_FOR_reload_v2df_si_load;
 	  if (TARGET_VSX && TARGET_UPPER_REGS_DF)
 	    {
-	      reg_addr[DFmode].reload_store  = CODE_FOR_reload_df_si_store;
-	      reg_addr[DFmode].reload_load   = CODE_FOR_reload_df_si_load;
-	      reg_addr[DDmode].reload_store  = CODE_FOR_reload_dd_si_store;
-	      reg_addr[DDmode].reload_load   = CODE_FOR_reload_dd_si_load;
+	      reg_addr[DFmode].reload_store    = CODE_FOR_reload_df_si_store;
+	      reg_addr[DFmode].reload_load     = CODE_FOR_reload_df_si_load;
+	      reg_addr[DFmode].scalar_in_vmx_p = true;
+	      reg_addr[DDmode].reload_store    = CODE_FOR_reload_dd_si_store;
+	      reg_addr[DDmode].reload_load     = CODE_FOR_reload_dd_si_load;
 	    }
 	  if (TARGET_P8_VECTOR)
 	    {
@@ -2793,6 +2829,8 @@
 	      reg_addr[SFmode].reload_load   = CODE_FOR_reload_sf_si_load;
 	      reg_addr[SDmode].reload_store  = CODE_FOR_reload_sd_si_store;
 	      reg_addr[SDmode].reload_load   = CODE_FOR_reload_sd_si_load;
+	      if (TARGET_UPPER_REGS_SF)
+		reg_addr[SFmode].scalar_in_vmx_p = true;
 	    }
 	  if (TARGET_VSX_TIMODE)
 	    {
@@ -2833,6 +2871,7 @@
 
       for (m = 0; m < NUM_MACHINE_MODES; ++m)
 	{
+	  enum machine_mode m2 = (enum machine_mode)m;
 	  int reg_size2 = reg_size;
 
 	  /* TFmode/TDmode always takes 2 registers, even in VSX.  */
@@ -2841,7 +2880,7 @@
 	    reg_size2 = UNITS_PER_FP_WORD;
 
 	  rs6000_class_max_nregs[m][c]
-	    = (GET_MODE_SIZE (m) + reg_size2 - 1) / reg_size2;
+	    = (GET_MODE_SIZE (m2) + reg_size2 - 1) / reg_size2;
 	}
     }
 
@@ -5871,6 +5910,34 @@
   return align;
 }
 
+/* Previous GCC releases forced all vector types to have 16-byte alignment.  */
+
+bool
+rs6000_special_adjust_field_align_p (tree field, unsigned int computed)
+{
+  if (TARGET_ALTIVEC && TREE_CODE (TREE_TYPE (field)) == VECTOR_TYPE)
+    {
+      if (computed != 128)
+	{
+	  static bool warned;
+	  if (!warned && warn_psabi)
+	    {
+	      warned = true;
+	      inform (input_location,
+		      "the layout of aggregates containing vectors with"
+		      " %d-byte alignment will change in a future GCC release",
+		      computed / BITS_PER_UNIT);
+	    }
+	}
+      /* GCC 4.8/4.9 Note: To avoid any ABI change on a release branch, we
+	 keep the special treatment of vector types, but warn if there will
+	 be differences in future GCC releases.  */
+      return true;
+    }
+
+  return false;
+}
+
 /* AIX increases natural record alignment to doubleword if the first
    field is an FP double while the FP fields remain word aligned.  */
 
@@ -9180,14 +9247,51 @@
 	   || (type && TREE_CODE (type) == VECTOR_TYPE
 	       && int_size_in_bytes (type) >= 16))
     return 128;
-  else if (((TARGET_MACHO && rs6000_darwin64_abi)
-	    || DEFAULT_ABI == ABI_ELFv2
-            || (DEFAULT_ABI == ABI_AIX && !rs6000_compat_align_parm))
- 	   && mode == BLKmode
-	   && type && TYPE_ALIGN (type) > 64)
+
+  /* Aggregate types that need > 8 byte alignment are quadword-aligned
+     in the parameter area in the ELFv2 ABI, and in the AIX ABI unless
+     -mcompat-align-parm is used.  */
+  if (((DEFAULT_ABI == ABI_AIX && !rs6000_compat_align_parm)
+       || DEFAULT_ABI == ABI_ELFv2)
+      && type && TYPE_ALIGN (type) > 64)
+    {
+      /* "Aggregate" means any AGGREGATE_TYPE except for single-element
+         or homogeneous float/vector aggregates here.  We already handled
+         vector aggregates above, but still need to check for float here. */
+      bool aggregate_p = (AGGREGATE_TYPE_P (type)
+			  && !SCALAR_FLOAT_MODE_P (elt_mode));
+
+      /* We used to check for BLKmode instead of the above aggregate type
+	 check.  Warn when this results in any difference to the ABI.  */
+      if (aggregate_p != (mode == BLKmode))
+	{
+	  static bool warned;
+	  if (!warned && warn_psabi)
+	    {
+	      warned = true;
+	      inform (input_location,
+		      "the ABI of passing aggregates with %d-byte alignment"
+		      " will change in a future GCC release",
+		      (int) TYPE_ALIGN (type) / BITS_PER_UNIT);
+	    }
+	}
+
+      /* GCC 4.8/4.9 Note: To avoid any ABI change on a release branch, we
+	 keep using the BLKmode check, but warn if there will be differences
+	 in future GCC releases.  */
+      if (mode == BLKmode)
+	return 128;
+    }
+
+  /* Similar for the Darwin64 ABI.  Note that for historical reasons we
+     implement the "aggregate type" check as a BLKmode check here; this
+     means certain aggregate types are in fact not aligned.  */
+  if (TARGET_MACHO && rs6000_darwin64_abi
+      && mode == BLKmode
+      && type && TYPE_ALIGN (type) > 64)
     return 128;
-  else
-    return PARM_BOUNDARY;
+
+  return PARM_BOUNDARY;
 }
 
 /* The offset in words to the start of the parameter save area.  */
@@ -10225,6 +10329,7 @@
 	  rtx r, off;
 	  int i, k = 0;
 	  unsigned long n_fpreg = (GET_MODE_SIZE (elt_mode) + 7) >> 3;
+	  int fpr_words;
 
 	  /* Do we also need to pass this argument in the parameter
 	     save area?  */
@@ -10253,6 +10358,37 @@
 	      rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, r, off);
 	    }
 
+	  /* If there were not enough FPRs to hold the argument, the rest
+	     usually goes into memory.  However, if the current position
+	     is still within the register parameter area, a portion may
+	     actually have to go into GPRs.
+
+	     Note that it may happen that the portion of the argument
+	     passed in the first "half" of the first GPR was already
+	     passed in the last FPR as well.
+
+	     For unnamed arguments, we already set up GPRs to cover the
+	     whole argument in rs6000_psave_function_arg, so there is
+	     nothing further to do at this point.
+
+	     GCC 4.8/4.9 Note: This was implemented incorrectly in earlier
+	     GCC releases.  To avoid any ABI change on the release branch,
+	     we retain that original implementation here, but warn if we
+	     encounter a case where the ABI will change in the future.  */
+	  fpr_words = (i * GET_MODE_SIZE (elt_mode)) / (TARGET_32BIT ? 4 : 8);
+	  if (i < n_elts && align_words + fpr_words < GP_ARG_NUM_REG
+	      && cum->nargs_prototype > 0)
+            {
+	      static bool warned;
+	      if (!warned && warn_psabi)
+		{
+		  warned = true;
+		  inform (input_location,
+			  "the ABI of passing homogeneous float aggregates"
+			  " will change in a future GCC release");
+		}
+	    }
+
 	  return rs6000_finish_function_arg (mode, rvec, k);
 	}
       else if (align_words < GP_ARG_NUM_REG)
@@ -17070,7 +17206,14 @@
      prefer Altivec loads..  */
   if (rclass == VSX_REGS)
     {
-      if (GET_MODE_SIZE (mode) <= 8)
+      if (MEM_P (x) && reg_addr[mode].scalar_in_vmx_p)
+	{
+	  rtx addr = XEXP (x, 0);
+	  if (rs6000_legitimate_offset_address_p (mode, addr, false, true)
+	      || legitimate_lo_sum_address_p (mode, addr, false))
+	    return FLOAT_REGS;
+	}
+      else if (GET_MODE_SIZE (mode) <= 8 && !reg_addr[mode].scalar_in_vmx_p)
 	return FLOAT_REGS;
 
       if (VECTOR_UNIT_ALTIVEC_P (mode) || VECTOR_MEM_ALTIVEC_P (mode)
@@ -31074,13 +31217,13 @@
     {
       if (BYTES_BIG_ENDIAN)
 	{
-	  parts[2 * i] = gen_rtx_REG (SImode, regno + 1200);
+	  parts[2 * i] = gen_rtx_REG (SImode, regno + FIRST_SPE_HIGH_REGNO);
 	  parts[2 * i + 1] = gen_rtx_REG (SImode, regno);
 	}
       else
 	{
 	  parts[2 * i] = gen_rtx_REG (SImode, regno);
-	  parts[2 * i + 1] = gen_rtx_REG (SImode, regno + 1200);
+	  parts[2 * i + 1] = gen_rtx_REG (SImode, regno + FIRST_SPE_HIGH_REGNO);
 	}
     }
 
@@ -31100,11 +31243,11 @@
       rtx mem = gen_rtx_MEM (BLKmode, addr);
       rtx value = gen_int_mode (4, mode);
 
-      for (i = 1201; i < 1232; i++)
+      for (i = FIRST_SPE_HIGH_REGNO; i < LAST_SPE_HIGH_REGNO+1; i++)
 	{
-	  int column = DWARF_REG_TO_UNWIND_COLUMN (i);
-	  HOST_WIDE_INT offset
-	    = DWARF_FRAME_REGNUM (column) * GET_MODE_SIZE (mode);
+	  int column = DWARF_REG_TO_UNWIND_COLUMN
+		(DWARF2_FRAME_REG_OUT (DWARF_FRAME_REGNUM (i), true));
+	  HOST_WIDE_INT offset = column * GET_MODE_SIZE (mode);
 
 	  emit_move_insn (adjust_address (mem, mode, offset), value);
 	}
@@ -31123,9 +31266,9 @@
 
       for (i = FIRST_ALTIVEC_REGNO; i < LAST_ALTIVEC_REGNO+1; i++)
 	{
-	  int column = DWARF_REG_TO_UNWIND_COLUMN (i);
-	  HOST_WIDE_INT offset
-	    = DWARF_FRAME_REGNUM (column) * GET_MODE_SIZE (mode);
+	  int column = DWARF_REG_TO_UNWIND_COLUMN
+		(DWARF2_FRAME_REG_OUT (DWARF_FRAME_REGNUM (i), true));
+	  HOST_WIDE_INT offset = column * GET_MODE_SIZE (mode);
 
 	  emit_move_insn (adjust_address (mem, mode, offset), value);
 	}
@@ -31157,9 +31300,8 @@
     return 99;
   if (regno == SPEFSCR_REGNO)
     return 612;
-  /* SPE high reg number.  We get these values of regno from
-     rs6000_dwarf_register_span.  */
-  gcc_assert (regno >= 1200 && regno < 1232);
+  if (SPE_HIGH_REGNO_P (regno))
+    return regno - FIRST_SPE_HIGH_REGNO + 1200;
   return regno;
 }
 
Index: gcc/config/rs6000/vsx.md
===================================================================
--- a/src/gcc/config/rs6000/vsx.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/rs6000/vsx.md	(.../branches/gcc-4_9-branch)
@@ -86,19 +86,26 @@
 			 (V4SF  "wf")
 			 (V2DI  "wd")
 			 (V2DF  "wd")
+			 (DI	"wi")
 			 (DF    "ws")
-			 (SF	"d")
+			 (SF	"ww")
 			 (V1TI  "v")
 			 (TI    "wt")])
 
-;; Map the register class used for float<->int conversions
+;; Map the register class used for float<->int conversions (floating point side)
+;; VSr2 is the preferred register class, VSr3 is any register class that will
+;; hold the data
 (define_mode_attr VSr2	[(V2DF  "wd")
 			 (V4SF  "wf")
-			 (DF    "ws")])
+			 (DF    "ws")
+			 (SF	"ww")
+			 (DI	"wi")])
 
 (define_mode_attr VSr3	[(V2DF  "wa")
 			 (V4SF  "wa")
-			 (DF    "ws")])
+			 (DF    "ws")
+			 (SF	"ww")
+			 (DI	"wi")])
 
 ;; Map the register class for sp<->dp float conversions, destination
 (define_mode_attr VSr4	[(SF	"ws")
@@ -106,12 +113,27 @@
 			 (V2DF  "wd")
 			 (V4SF	"v")])
 
-;; Map the register class for sp<->dp float conversions, destination
+;; Map the register class for sp<->dp float conversions, source
 (define_mode_attr VSr5	[(SF	"ws")
 			 (DF	"f")
 			 (V2DF  "v")
 			 (V4SF	"wd")])
 
+;; The VSX register class that a type can occupy, even if it is not the
+;; preferred register class (VSr is the preferred register class that will get
+;; allocated first).
+(define_mode_attr VSa	[(V16QI "wa")
+			 (V8HI  "wa")
+			 (V4SI  "wa")
+			 (V4SF  "wa")
+			 (V2DI  "wa")
+			 (V2DF  "wa")
+			 (DI	"wi")
+			 (DF    "ws")
+			 (SF	"ww")
+			 (V1TI	"wa")
+			 (TI    "wt")])
+
 ;; Same size integer type for floating point data
 (define_mode_attr VSi [(V4SF  "v4si")
 		       (V2DF  "v2di")
@@ -207,6 +229,16 @@
 			     (V2DF	"V4DF")
 			     (V1TI	"V2TI")])
 
+;; Map register class for 64-bit element in 128-bit vector for direct moves
+;; to/from gprs
+(define_mode_attr VS_64dm [(V2DF	"wk")
+			   (V2DI	"wj")])
+
+;; Map register class for 64-bit element in 128-bit vector for normal register
+;; to register moves
+(define_mode_attr VS_64reg [(V2DF	"ws")
+			    (V2DI	"wi")])
+
 ;; Constants for creating unspecs
 (define_c_enum "unspec"
   [UNSPEC_VSX_CONCAT
@@ -235,7 +267,7 @@
 ;; The patterns for LE permuted loads and stores come before the general
 ;; VSX moves so they match first.
 (define_insn_and_split "*vsx_le_perm_load_<mode>"
-  [(set (match_operand:VSX_LE 0 "vsx_register_operand" "=wa")
+  [(set (match_operand:VSX_LE 0 "vsx_register_operand" "=<VSa>")
         (match_operand:VSX_LE 1 "memory_operand" "Z"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX"
   "#"
@@ -258,7 +290,7 @@
    (set_attr "length" "8")])
 
 (define_insn_and_split "*vsx_le_perm_load_<mode>"
-  [(set (match_operand:VSX_W 0 "vsx_register_operand" "=wa")
+  [(set (match_operand:VSX_W 0 "vsx_register_operand" "=<VSa>")
         (match_operand:VSX_W 1 "memory_operand" "Z"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX"
   "#"
@@ -350,7 +382,7 @@
 
 (define_insn "*vsx_le_perm_store_<mode>"
   [(set (match_operand:VSX_LE 0 "memory_operand" "=Z")
-        (match_operand:VSX_LE 1 "vsx_register_operand" "+wa"))]
+        (match_operand:VSX_LE 1 "vsx_register_operand" "+<VSa>"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX"
   "#"
   [(set_attr "type" "vecstore")
@@ -395,7 +427,7 @@
 
 (define_insn "*vsx_le_perm_store_<mode>"
   [(set (match_operand:VSX_W 0 "memory_operand" "=Z")
-        (match_operand:VSX_W 1 "vsx_register_operand" "+wa"))]
+        (match_operand:VSX_W 1 "vsx_register_operand" "+<VSa>"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX"
   "#"
   [(set_attr "type" "vecstore")
@@ -585,8 +617,8 @@
 
 
 (define_insn "*vsx_mov<mode>"
-  [(set (match_operand:VSX_M 0 "nonimmediate_operand" "=Z,<VSr>,<VSr>,?Z,?wa,?wa,wQ,?&r,??Y,??r,??r,<VSr>,?wa,*r,v,wZ, v")
-	(match_operand:VSX_M 1 "input_operand" "<VSr>,Z,<VSr>,wa,Z,wa,r,wQ,r,Y,r,j,j,j,W,v,wZ"))]
+  [(set (match_operand:VSX_M 0 "nonimmediate_operand" "=Z,<VSr>,<VSr>,?Z,?<VSa>,?<VSa>,wQ,?&r,??Y,??r,??r,<VSr>,?<VSa>,*r,v,wZ, v")
+	(match_operand:VSX_M 1 "input_operand" "<VSr>,Z,<VSr>,<VSa>,Z,<VSa>,r,wQ,r,Y,r,j,j,j,W,v,wZ"))]
   "VECTOR_MEM_VSX_P (<MODE>mode)
    && (register_operand (operands[0], <MODE>mode) 
        || register_operand (operands[1], <MODE>mode))"
@@ -688,9 +720,9 @@
 ;; instructions are now combined with the insn for the traditional floating
 ;; point unit.
 (define_insn "*vsx_add<mode>3"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-        (plus:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")
-		    (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,wa")))]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+        (plus:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")
+		    (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvadd<VSs> %x0,%x1,%x2"
   [(set_attr "type" "<VStype_simple>")
@@ -697,9 +729,9 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "*vsx_sub<mode>3"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-        (minus:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")
-		     (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,wa")))]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+        (minus:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")
+		     (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvsub<VSs> %x0,%x1,%x2"
   [(set_attr "type" "<VStype_simple>")
@@ -706,9 +738,9 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "*vsx_mul<mode>3"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-        (mult:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")
-		    (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,wa")))]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+        (mult:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")
+		    (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvmul<VSs> %x0,%x1,%x2"
   [(set_attr "type" "<VStype_simple>")
@@ -715,9 +747,9 @@
    (set_attr "fp_type" "<VSfptype_mul>")])
 
 (define_insn "*vsx_div<mode>3"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-        (div:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")
-		   (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,wa")))]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+        (div:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")
+		   (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvdiv<VSs> %x0,%x1,%x2"
   [(set_attr "type" "<VStype_div>")
@@ -753,8 +785,8 @@
 
 (define_insn "*vsx_tdiv<mode>3_internal"
   [(set (match_operand:CCFP 0 "cc_reg_operand" "=x,x")
-	(unspec:CCFP [(match_operand:VSX_B 1 "vsx_register_operand" "<VSr>,wa")
-		      (match_operand:VSX_B 2 "vsx_register_operand" "<VSr>,wa")]
+	(unspec:CCFP [(match_operand:VSX_B 1 "vsx_register_operand" "<VSr>,<VSa>")
+		      (match_operand:VSX_B 2 "vsx_register_operand" "<VSr>,<VSa>")]
 		   UNSPEC_VSX_TDIV))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "x<VSv>tdiv<VSs> %0,%x1,%x2"
@@ -762,8 +794,8 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "vsx_fre<mode>2"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-	(unspec:VSX_F [(match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+	(unspec:VSX_F [(match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")]
 		      UNSPEC_FRES))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvre<VSs> %x0,%x1"
@@ -771,8 +803,8 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "*vsx_neg<mode>2"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-        (neg:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")))]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+        (neg:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvneg<VSs> %x0,%x1"
   [(set_attr "type" "<VStype_simple>")
@@ -779,8 +811,8 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "*vsx_abs<mode>2"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-        (abs:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")))]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+        (abs:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvabs<VSs> %x0,%x1"
   [(set_attr "type" "<VStype_simple>")
@@ -787,10 +819,10 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "vsx_nabs<mode>2"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
         (neg:VSX_F
 	 (abs:VSX_F
-	  (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa"))))]
+	  (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>"))))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvnabs<VSs> %x0,%x1"
   [(set_attr "type" "<VStype_simple>")
@@ -797,9 +829,9 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "vsx_smax<mode>3"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-        (smax:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")
-		    (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,wa")))]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+        (smax:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")
+		    (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvmax<VSs> %x0,%x1,%x2"
   [(set_attr "type" "<VStype_simple>")
@@ -806,9 +838,9 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "*vsx_smin<mode>3"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-        (smin:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")
-		    (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,wa")))]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+        (smin:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")
+		    (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvmin<VSs> %x0,%x1,%x2"
   [(set_attr "type" "<VStype_simple>")
@@ -815,8 +847,8 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "*vsx_sqrt<mode>2"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-        (sqrt:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")))]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+        (sqrt:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvsqrt<VSs> %x0,%x1"
   [(set_attr "type" "<VStype_sqrt>")
@@ -823,8 +855,8 @@
    (set_attr "fp_type" "<VSfptype_sqrt>")])
 
 (define_insn "*vsx_rsqrte<mode>2"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-	(unspec:VSX_F [(match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+	(unspec:VSX_F [(match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")]
 		      UNSPEC_RSQRT))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvrsqrte<VSs> %x0,%x1"
@@ -859,7 +891,7 @@
 
 (define_insn "*vsx_tsqrt<mode>2_internal"
   [(set (match_operand:CCFP 0 "cc_reg_operand" "=x,x")
-	(unspec:CCFP [(match_operand:VSX_B 1 "vsx_register_operand" "<VSr>,wa")]
+	(unspec:CCFP [(match_operand:VSX_B 1 "vsx_register_operand" "<VSr>,<VSa>")]
 		     UNSPEC_VSX_TSQRT))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "x<VSv>tsqrt<VSs> %0,%x1"
@@ -901,12 +933,12 @@
   [(set_attr "type" "vecdouble")])
 
 (define_insn "*vsx_fms<mode>4"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,<VSr>,?wa,?wa")
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,<VSr>,?<VSa>,?<VSa>")
 	(fma:VSX_F
-	  (match_operand:VSX_F 1 "vsx_register_operand" "%<VSr>,<VSr>,wa,wa")
-	  (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,0,wa,0")
+	  (match_operand:VSX_F 1 "vsx_register_operand" "%<VSr>,<VSr>,<VSa>,<VSa>")
+	  (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,0,<VSa>,0")
 	  (neg:VSX_F
-	    (match_operand:VSX_F 3 "vsx_register_operand" "0,<VSr>,0,wa"))))]
+	    (match_operand:VSX_F 3 "vsx_register_operand" "0,<VSr>,0,<VSa>"))))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "@
    xvmsuba<VSs> %x0,%x1,%x2
@@ -916,12 +948,12 @@
   [(set_attr "type" "<VStype_mul>")])
 
 (define_insn "*vsx_nfma<mode>4"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,<VSr>,?wa,?wa")
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,<VSr>,?<VSa>,?<VSa>")
 	(neg:VSX_F
 	 (fma:VSX_F
-	  (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSr>,wa,wa")
-	  (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,0,wa,0")
-	  (match_operand:VSX_F 3 "vsx_register_operand" "0,<VSr>,0,wa"))))]
+	  (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSr>,<VSa>,<VSa>")
+	  (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,0,<VSa>,0")
+	  (match_operand:VSX_F 3 "vsx_register_operand" "0,<VSr>,0,<VSa>"))))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "@
    xvnmadda<VSs> %x0,%x1,%x2
@@ -966,9 +998,9 @@
 
 ;; Vector conditional expressions (no scalar version for these instructions)
 (define_insn "vsx_eq<mode>"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-	(eq:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")
-		  (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,wa")))]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+	(eq:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")
+		  (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvcmpeq<VSs> %x0,%x1,%x2"
   [(set_attr "type" "<VStype_simple>")
@@ -975,9 +1007,9 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "vsx_gt<mode>"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-	(gt:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")
-		  (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,wa")))]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+	(gt:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")
+		  (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvcmpgt<VSs> %x0,%x1,%x2"
   [(set_attr "type" "<VStype_simple>")
@@ -984,9 +1016,9 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "*vsx_ge<mode>"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-	(ge:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")
-		  (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,wa")))]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+	(ge:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")
+		  (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvcmpge<VSs> %x0,%x1,%x2"
   [(set_attr "type" "<VStype_simple>")
@@ -997,10 +1029,10 @@
 (define_insn "*vsx_eq_<mode>_p"
   [(set (reg:CC 74)
 	(unspec:CC
-	 [(eq:CC (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,?wa")
-		 (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,?wa"))]
+	 [(eq:CC (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,?<VSa>")
+		 (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,?<VSa>"))]
 	 UNSPEC_PREDICATE))
-   (set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
+   (set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
 	(eq:VSX_F (match_dup 1)
 		  (match_dup 2)))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
@@ -1010,10 +1042,10 @@
 (define_insn "*vsx_gt_<mode>_p"
   [(set (reg:CC 74)
 	(unspec:CC
-	 [(gt:CC (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,?wa")
-		 (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,?wa"))]
+	 [(gt:CC (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,?<VSa>")
+		 (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,?<VSa>"))]
 	 UNSPEC_PREDICATE))
-   (set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
+   (set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
 	(gt:VSX_F (match_dup 1)
 		  (match_dup 2)))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
@@ -1023,10 +1055,10 @@
 (define_insn "*vsx_ge_<mode>_p"
   [(set (reg:CC 74)
 	(unspec:CC
-	 [(ge:CC (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,?wa")
-		 (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,?wa"))]
+	 [(ge:CC (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,?<VSa>")
+		 (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,?<VSa>"))]
 	 UNSPEC_PREDICATE))
-   (set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
+   (set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
 	(ge:VSX_F (match_dup 1)
 		  (match_dup 2)))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
@@ -1035,23 +1067,23 @@
 
 ;; Vector select
 (define_insn "*vsx_xxsel<mode>"
-  [(set (match_operand:VSX_L 0 "vsx_register_operand" "=<VSr>,?wa")
+  [(set (match_operand:VSX_L 0 "vsx_register_operand" "=<VSr>,?<VSa>")
 	(if_then_else:VSX_L
-	 (ne:CC (match_operand:VSX_L 1 "vsx_register_operand" "<VSr>,wa")
+	 (ne:CC (match_operand:VSX_L 1 "vsx_register_operand" "<VSr>,<VSa>")
 		(match_operand:VSX_L 4 "zero_constant" ""))
-	 (match_operand:VSX_L 2 "vsx_register_operand" "<VSr>,wa")
-	 (match_operand:VSX_L 3 "vsx_register_operand" "<VSr>,wa")))]
+	 (match_operand:VSX_L 2 "vsx_register_operand" "<VSr>,<VSa>")
+	 (match_operand:VSX_L 3 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_MEM_VSX_P (<MODE>mode)"
   "xxsel %x0,%x3,%x2,%x1"
   [(set_attr "type" "vecperm")])
 
 (define_insn "*vsx_xxsel<mode>_uns"
-  [(set (match_operand:VSX_L 0 "vsx_register_operand" "=<VSr>,?wa")
+  [(set (match_operand:VSX_L 0 "vsx_register_operand" "=<VSr>,?<VSa>")
 	(if_then_else:VSX_L
-	 (ne:CCUNS (match_operand:VSX_L 1 "vsx_register_operand" "<VSr>,wa")
+	 (ne:CCUNS (match_operand:VSX_L 1 "vsx_register_operand" "<VSr>,<VSa>")
 		   (match_operand:VSX_L 4 "zero_constant" ""))
-	 (match_operand:VSX_L 2 "vsx_register_operand" "<VSr>,wa")
-	 (match_operand:VSX_L 3 "vsx_register_operand" "<VSr>,wa")))]
+	 (match_operand:VSX_L 2 "vsx_register_operand" "<VSr>,<VSa>")
+	 (match_operand:VSX_L 3 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_MEM_VSX_P (<MODE>mode)"
   "xxsel %x0,%x3,%x2,%x1"
   [(set_attr "type" "vecperm")])
@@ -1058,10 +1090,10 @@
 
 ;; Copy sign
 (define_insn "vsx_copysign<mode>3"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
 	(unspec:VSX_F
-	 [(match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")
-	  (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,wa")]
+	 [(match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")
+	  (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,<VSa>")]
 	 UNSPEC_COPYSIGN))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvcpsgn<VSs> %x0,%x2,%x1"
@@ -1074,7 +1106,7 @@
 ;; in rs6000.md so don't test VECTOR_UNIT_VSX_P, just test against VSX.
 ;; Don't use vsx_register_operand here, use gpc_reg_operand to match rs6000.md.
 (define_insn "vsx_float<VSi><mode>2"
-  [(set (match_operand:VSX_B 0 "gpc_reg_operand" "=<VSr>,?wa")
+  [(set (match_operand:VSX_B 0 "gpc_reg_operand" "=<VSr>,?<VSa>")
 	(float:VSX_B (match_operand:<VSI> 1 "gpc_reg_operand" "<VSr2>,<VSr3>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "x<VSv>cvsx<VSc><VSs> %x0,%x1"
@@ -1082,7 +1114,7 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "vsx_floatuns<VSi><mode>2"
-  [(set (match_operand:VSX_B 0 "gpc_reg_operand" "=<VSr>,?wa")
+  [(set (match_operand:VSX_B 0 "gpc_reg_operand" "=<VSr>,?<VSa>")
 	(unsigned_float:VSX_B (match_operand:<VSI> 1 "gpc_reg_operand" "<VSr2>,<VSr3>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "x<VSv>cvux<VSc><VSs> %x0,%x1"
@@ -1091,7 +1123,7 @@
 
 (define_insn "vsx_fix_trunc<mode><VSi>2"
   [(set (match_operand:<VSI> 0 "gpc_reg_operand" "=<VSr2>,?<VSr3>")
-	(fix:<VSI> (match_operand:VSX_B 1 "gpc_reg_operand" "<VSr>,wa")))]
+	(fix:<VSI> (match_operand:VSX_B 1 "gpc_reg_operand" "<VSr>,<VSa>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "x<VSv>cv<VSs>sx<VSc>s %x0,%x1"
   [(set_attr "type" "<VStype_simple>")
@@ -1099,7 +1131,7 @@
 
 (define_insn "vsx_fixuns_trunc<mode><VSi>2"
   [(set (match_operand:<VSI> 0 "gpc_reg_operand" "=<VSr2>,?<VSr3>")
-	(unsigned_fix:<VSI> (match_operand:VSX_B 1 "gpc_reg_operand" "<VSr>,wa")))]
+	(unsigned_fix:<VSI> (match_operand:VSX_B 1 "gpc_reg_operand" "<VSr>,<VSa>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "x<VSv>cv<VSs>ux<VSc>s %x0,%x1"
   [(set_attr "type" "<VStype_simple>")
@@ -1107,8 +1139,8 @@
 
 ;; Math rounding functions
 (define_insn "vsx_x<VSv>r<VSs>i"
-  [(set (match_operand:VSX_B 0 "vsx_register_operand" "=<VSr>,?wa")
-	(unspec:VSX_B [(match_operand:VSX_B 1 "vsx_register_operand" "<VSr>,wa")]
+  [(set (match_operand:VSX_B 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+	(unspec:VSX_B [(match_operand:VSX_B 1 "vsx_register_operand" "<VSr>,<VSa>")]
 		      UNSPEC_VSX_ROUND_I))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "x<VSv>r<VSs>i %x0,%x1"
@@ -1116,8 +1148,8 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "vsx_x<VSv>r<VSs>ic"
-  [(set (match_operand:VSX_B 0 "vsx_register_operand" "=<VSr>,?wa")
-	(unspec:VSX_B [(match_operand:VSX_B 1 "vsx_register_operand" "<VSr>,wa")]
+  [(set (match_operand:VSX_B 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+	(unspec:VSX_B [(match_operand:VSX_B 1 "vsx_register_operand" "<VSr>,<VSa>")]
 		      UNSPEC_VSX_ROUND_IC))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "x<VSv>r<VSs>ic %x0,%x1"
@@ -1125,8 +1157,8 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "vsx_btrunc<mode>2"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-	(fix:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")))]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+	(fix:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvr<VSs>iz %x0,%x1"
   [(set_attr "type" "<VStype_simple>")
@@ -1133,8 +1165,8 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "*vsx_b2trunc<mode>2"
-  [(set (match_operand:VSX_B 0 "vsx_register_operand" "=<VSr>,?wa")
-	(unspec:VSX_B [(match_operand:VSX_B 1 "vsx_register_operand" "<VSr>,wa")]
+  [(set (match_operand:VSX_B 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+	(unspec:VSX_B [(match_operand:VSX_B 1 "vsx_register_operand" "<VSr>,<VSa>")]
 		      UNSPEC_FRIZ))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "x<VSv>r<VSs>iz %x0,%x1"
@@ -1142,8 +1174,8 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "vsx_floor<mode>2"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-	(unspec:VSX_F [(match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+	(unspec:VSX_F [(match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")]
 		      UNSPEC_FRIM))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvr<VSs>im %x0,%x1"
@@ -1151,8 +1183,8 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "vsx_ceil<mode>2"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-	(unspec:VSX_F [(match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+	(unspec:VSX_F [(match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")]
 		      UNSPEC_FRIP))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvr<VSs>ip %x0,%x1"
@@ -1167,8 +1199,8 @@
 ;; scalar single precision instructions internally use the double format.
 ;; Prefer the altivec registers, since we likely will need to do a vperm
 (define_insn "vsx_<VS_spdp_insn>"
-  [(set (match_operand:<VS_spdp_res> 0 "vsx_register_operand" "=<VSr4>,?wa")
-	(unspec:<VS_spdp_res> [(match_operand:VSX_SPDP 1 "vsx_register_operand" "<VSr5>,wa")]
+  [(set (match_operand:<VS_spdp_res> 0 "vsx_register_operand" "=<VSr4>,?<VSa>")
+	(unspec:<VS_spdp_res> [(match_operand:VSX_SPDP 1 "vsx_register_operand" "<VSr5>,<VSa>")]
 			      UNSPEC_VSX_CVSPDP))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "<VS_spdp_insn> %x0,%x1"
@@ -1176,8 +1208,8 @@
 
 ;; xscvspdp, represent the scalar SF type as V4SF
 (define_insn "vsx_xscvspdp"
-  [(set (match_operand:DF 0 "vsx_register_operand" "=ws,?wa")
-	(unspec:DF [(match_operand:V4SF 1 "vsx_register_operand" "wa,wa")]
+  [(set (match_operand:DF 0 "vsx_register_operand" "=ws")
+	(unspec:DF [(match_operand:V4SF 1 "vsx_register_operand" "wa")]
 		   UNSPEC_VSX_CVSPDP))]
   "VECTOR_UNIT_VSX_P (V4SFmode)"
   "xscvspdp %x0,%x1"
@@ -1204,7 +1236,7 @@
 
 ;; ISA 2.07 xscvdpspn/xscvspdpn that does not raise an error on signalling NaNs
 (define_insn "vsx_xscvdpspn"
-  [(set (match_operand:V4SF 0 "vsx_register_operand" "=ws,?wa")
+  [(set (match_operand:V4SF 0 "vsx_register_operand" "=ww,?ww")
 	(unspec:V4SF [(match_operand:DF 1 "vsx_register_operand" "wd,wa")]
 		     UNSPEC_VSX_CVDPSPN))]
   "TARGET_XSCVDPSPN"
@@ -1212,8 +1244,8 @@
   [(set_attr "type" "fp")])
 
 (define_insn "vsx_xscvspdpn"
-  [(set (match_operand:DF 0 "vsx_register_operand" "=ws,?wa")
-	(unspec:DF [(match_operand:V4SF 1 "vsx_register_operand" "wa,wa")]
+  [(set (match_operand:DF 0 "vsx_register_operand" "=ws,?ws")
+	(unspec:DF [(match_operand:V4SF 1 "vsx_register_operand" "wf,wa")]
 		   UNSPEC_VSX_CVSPDPN))]
   "TARGET_XSCVSPDPN"
   "xscvspdpn %x0,%x1"
@@ -1220,8 +1252,8 @@
   [(set_attr "type" "fp")])
 
 (define_insn "vsx_xscvdpspn_scalar"
-  [(set (match_operand:V4SF 0 "vsx_register_operand" "=wa")
-	(unspec:V4SF [(match_operand:SF 1 "vsx_register_operand" "f")]
+  [(set (match_operand:V4SF 0 "vsx_register_operand" "=wf,?wa")
+	(unspec:V4SF [(match_operand:SF 1 "vsx_register_operand" "ww,ww")]
 		     UNSPEC_VSX_CVDPSPN))]
   "TARGET_XSCVDPSPN"
   "xscvdpspn %x0,%x1"
@@ -1309,10 +1341,10 @@
 ;; since the xsrdpiz instruction does not truncate the value if the floating
 ;; point value is < LONG_MIN or > LONG_MAX.
 (define_insn "*vsx_float_fix_<mode>2"
-  [(set (match_operand:VSX_DF 0 "vsx_register_operand" "=<VSr>,?wa")
+  [(set (match_operand:VSX_DF 0 "vsx_register_operand" "=<VSr>,?<VSa>")
 	(float:VSX_DF
 	 (fix:<VSI>
-	  (match_operand:VSX_DF 1 "vsx_register_operand" "<VSr>,?wa"))))]
+	  (match_operand:VSX_DF 1 "vsx_register_operand" "<VSr>,?<VSa>"))))]
   "TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT
    && VECTOR_UNIT_VSX_P (<MODE>mode) && flag_unsafe_math_optimizations
    && !flag_trapping_math && TARGET_FRIZ"
@@ -1325,10 +1357,10 @@
 
 ;; Build a V2DF/V2DI vector from two scalars
 (define_insn "vsx_concat_<mode>"
-  [(set (match_operand:VSX_D 0 "vsx_register_operand" "=<VSr>,?wa")
+  [(set (match_operand:VSX_D 0 "vsx_register_operand" "=<VSr>,?<VSa>")
 	(vec_concat:VSX_D
-	 (match_operand:<VS_scalar> 1 "vsx_register_operand" "ws,wa")
-	 (match_operand:<VS_scalar> 2 "vsx_register_operand" "ws,wa")))]
+	 (match_operand:<VS_scalar> 1 "vsx_register_operand" "ws,<VSa>")
+	 (match_operand:<VS_scalar> 2 "vsx_register_operand" "ws,<VSa>")))]
   "VECTOR_MEM_VSX_P (<MODE>mode)"
 {
   if (BYTES_BIG_ENDIAN)
@@ -1359,9 +1391,9 @@
 ;; xxpermdi for little endian loads and stores.  We need several of
 ;; these since the form of the PARALLEL differs by mode.
 (define_insn "*vsx_xxpermdi2_le_<mode>"
-  [(set (match_operand:VSX_LE 0 "vsx_register_operand" "=wa")
+  [(set (match_operand:VSX_LE 0 "vsx_register_operand" "=<VSa>")
         (vec_select:VSX_LE
-          (match_operand:VSX_LE 1 "vsx_register_operand" "wa")
+          (match_operand:VSX_LE 1 "vsx_register_operand" "<VSa>")
           (parallel [(const_int 1) (const_int 0)])))]
   "!BYTES_BIG_ENDIAN && VECTOR_MEM_VSX_P (<MODE>mode)"
   "xxpermdi %x0,%x1,%x1,2"
@@ -1368,9 +1400,9 @@
   [(set_attr "type" "vecperm")])
 
 (define_insn "*vsx_xxpermdi4_le_<mode>"
-  [(set (match_operand:VSX_W 0 "vsx_register_operand" "=wa")
+  [(set (match_operand:VSX_W 0 "vsx_register_operand" "=<VSa>")
         (vec_select:VSX_W
-          (match_operand:VSX_W 1 "vsx_register_operand" "wa")
+          (match_operand:VSX_W 1 "vsx_register_operand" "<VSa>")
           (parallel [(const_int 2) (const_int 3)
                      (const_int 0) (const_int 1)])))]
   "!BYTES_BIG_ENDIAN && VECTOR_MEM_VSX_P (<MODE>mode)"
@@ -1408,7 +1440,7 @@
 ;; lxvd2x for little endian loads.  We need several of
 ;; these since the form of the PARALLEL differs by mode.
 (define_insn "*vsx_lxvd2x2_le_<mode>"
-  [(set (match_operand:VSX_LE 0 "vsx_register_operand" "=wa")
+  [(set (match_operand:VSX_LE 0 "vsx_register_operand" "=<VSa>")
         (vec_select:VSX_LE
           (match_operand:VSX_LE 1 "memory_operand" "Z")
           (parallel [(const_int 1) (const_int 0)])))]
@@ -1417,7 +1449,7 @@
   [(set_attr "type" "vecload")])
 
 (define_insn "*vsx_lxvd2x4_le_<mode>"
-  [(set (match_operand:VSX_W 0 "vsx_register_operand" "=wa")
+  [(set (match_operand:VSX_W 0 "vsx_register_operand" "=<VSa>")
         (vec_select:VSX_W
           (match_operand:VSX_W 1 "memory_operand" "Z")
           (parallel [(const_int 2) (const_int 3)
@@ -1459,7 +1491,7 @@
 (define_insn "*vsx_stxvd2x2_le_<mode>"
   [(set (match_operand:VSX_LE 0 "memory_operand" "=Z")
         (vec_select:VSX_LE
-          (match_operand:VSX_LE 1 "vsx_register_operand" "wa")
+          (match_operand:VSX_LE 1 "vsx_register_operand" "<VSa>")
           (parallel [(const_int 1) (const_int 0)])))]
   "!BYTES_BIG_ENDIAN && VECTOR_MEM_VSX_P (<MODE>mode)"
   "stxvd2x %x1,%y0"
@@ -1468,7 +1500,7 @@
 (define_insn "*vsx_stxvd2x4_le_<mode>"
   [(set (match_operand:VSX_W 0 "memory_operand" "=Z")
         (vec_select:VSX_W
-          (match_operand:VSX_W 1 "vsx_register_operand" "wa")
+          (match_operand:VSX_W 1 "vsx_register_operand" "<VSa>")
           (parallel [(const_int 2) (const_int 3)
                      (const_int 0) (const_int 1)])))]
   "!BYTES_BIG_ENDIAN && VECTOR_MEM_VSX_P (<MODE>mode)"
@@ -1520,11 +1552,12 @@
 
 ;; Set the element of a V2DI/VD2F mode
 (define_insn "vsx_set_<mode>"
-  [(set (match_operand:VSX_D 0 "vsx_register_operand" "=wd,?wa")
-	(unspec:VSX_D [(match_operand:VSX_D 1 "vsx_register_operand" "wd,wa")
-		       (match_operand:<VS_scalar> 2 "vsx_register_operand" "ws,wa")
-		       (match_operand:QI 3 "u5bit_cint_operand" "i,i")]
-		      UNSPEC_VSX_SET))]
+  [(set (match_operand:VSX_D 0 "vsx_register_operand" "=wd,?<VSa>")
+	(unspec:VSX_D
+	 [(match_operand:VSX_D 1 "vsx_register_operand" "wd,<VSa>")
+	  (match_operand:<VS_scalar> 2 "vsx_register_operand" "<VS_64reg>,<VSa>")
+	  (match_operand:QI 3 "u5bit_cint_operand" "i,i")]
+	 UNSPEC_VSX_SET))]
   "VECTOR_MEM_VSX_P (<MODE>mode)"
 {
   int idx_first = BYTES_BIG_ENDIAN ? 0 : 1;
@@ -1549,11 +1582,11 @@
 ;; Optimize cases were we can do a simple or direct move.
 ;; Or see if we can avoid doing the move at all
 (define_insn "*vsx_extract_<mode>_internal1"
-  [(set (match_operand:<VS_scalar> 0 "register_operand" "=d,ws,?wa,r")
+  [(set (match_operand:<VS_scalar> 0 "register_operand" "=d,<VS_64reg>,r")
 	(vec_select:<VS_scalar>
-	 (match_operand:VSX_D 1 "register_operand" "d,wd,wa,wm")
+	 (match_operand:VSX_D 1 "register_operand" "d,<VS_64reg>,<VS_64dm>")
 	 (parallel
-	  [(match_operand:QI 2 "vsx_scalar_64bit" "wD,wD,wD,wD")])))]
+	  [(match_operand:QI 2 "vsx_scalar_64bit" "wD,wD,wD")])))]
   "VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_POWERPC64 && TARGET_DIRECT_MOVE"
 {
   int op0_regno = REGNO (operands[0]);
@@ -1570,14 +1603,14 @@
 
   return "xxlor %x0,%x1,%x1";
 }
-  [(set_attr "type" "fp,vecsimple,vecsimple,mftgpr")
+  [(set_attr "type" "fp,vecsimple,mftgpr")
    (set_attr "length" "4")])
 
 (define_insn "*vsx_extract_<mode>_internal2"
-  [(set (match_operand:<VS_scalar> 0 "vsx_register_operand" "=d,ws,ws,?wa")
+  [(set (match_operand:<VS_scalar> 0 "vsx_register_operand" "=d,<VS_64reg>,<VS_64reg>")
 	(vec_select:<VS_scalar>
-	 (match_operand:VSX_D 1 "vsx_register_operand" "d,wd,wd,wa")
-	 (parallel [(match_operand:QI 2 "u5bit_cint_operand" "wD,wD,i,i")])))]
+	 (match_operand:VSX_D 1 "vsx_register_operand" "d,wd,wd")
+	 (parallel [(match_operand:QI 2 "u5bit_cint_operand" "wD,wD,i")])))]
   "VECTOR_MEM_VSX_P (<MODE>mode)
    && (!TARGET_POWERPC64 || !TARGET_DIRECT_MOVE
        || INTVAL (operands[2]) != VECTOR_ELEMENT_SCALAR_64BIT)"
@@ -1605,7 +1638,7 @@
   operands[3] = GEN_INT (fldDM);
   return "xxpermdi %x0,%x1,%x1,%3";
 }
-  [(set_attr "type" "fp,vecsimple,vecperm,vecperm")
+  [(set_attr "type" "fp,vecsimple,vecperm")
    (set_attr "length" "4")])
 
 ;; Optimize extracting a single scalar element from memory if the scalar is in
@@ -1643,7 +1676,7 @@
 (define_insn "*vsx_extract_<mode>_store"
   [(set (match_operand:<VS_scalar> 0 "memory_operand" "=m,Z,?Z")
 	(vec_select:<VS_scalar>
-	 (match_operand:VSX_D 1 "register_operand" "d,wd,wa")
+	 (match_operand:VSX_D 1 "register_operand" "d,wd,<VSa>")
 	 (parallel [(match_operand:QI 2 "vsx_scalar_64bit" "wD,wD,wD")])))]
   "VECTOR_MEM_VSX_P (<MODE>mode)"
   "@
@@ -1666,7 +1699,7 @@
 (define_insn_and_split "vsx_extract_v4sf"
   [(set (match_operand:SF 0 "vsx_register_operand" "=f,f")
 	(vec_select:SF
-	 (match_operand:V4SF 1 "vsx_register_operand" "wa,wa")
+	 (match_operand:V4SF 1 "vsx_register_operand" "<VSa>,<VSa>")
 	 (parallel [(match_operand:QI 2 "u5bit_cint_operand" "O,i")])))
    (clobber (match_scratch:V4SF 3 "=X,0"))]
   "VECTOR_UNIT_VSX_P (V4SFmode)"
@@ -1849,9 +1882,9 @@
 
 ;; V2DF/V2DI splat
 (define_insn "vsx_splat_<mode>"
-  [(set (match_operand:VSX_D 0 "vsx_register_operand" "=wd,wd,wd,?wa,?wa,?wa")
+  [(set (match_operand:VSX_D 0 "vsx_register_operand" "=wd,wd,wd,?<VSa>,?<VSa>,?<VSa>")
 	(vec_duplicate:VSX_D
-	 (match_operand:<VS_scalar> 1 "splat_input_operand" "ws,f,Z,wa,wa,Z")))]
+	 (match_operand:<VS_scalar> 1 "splat_input_operand" "<VS_64reg>,f,Z,<VSa>,<VSa>,Z")))]
   "VECTOR_MEM_VSX_P (<MODE>mode)"
   "@
    xxpermdi %x0,%x1,%x1,0
@@ -1864,10 +1897,10 @@
 
 ;; V4SF/V4SI splat
 (define_insn "vsx_xxspltw_<mode>"
-  [(set (match_operand:VSX_W 0 "vsx_register_operand" "=wf,?wa")
+  [(set (match_operand:VSX_W 0 "vsx_register_operand" "=wf,?<VSa>")
 	(vec_duplicate:VSX_W
 	 (vec_select:<VS_scalar>
-	  (match_operand:VSX_W 1 "vsx_register_operand" "wf,wa")
+	  (match_operand:VSX_W 1 "vsx_register_operand" "wf,<VSa>")
 	  (parallel
 	   [(match_operand:QI 2 "u5bit_cint_operand" "i,i")]))))]
   "VECTOR_MEM_VSX_P (<MODE>mode)"
@@ -1880,8 +1913,8 @@
   [(set_attr "type" "vecperm")])
 
 (define_insn "vsx_xxspltw_<mode>_direct"
-  [(set (match_operand:VSX_W 0 "vsx_register_operand" "=wf,?wa")
-        (unspec:VSX_W [(match_operand:VSX_W 1 "vsx_register_operand" "wf,wa")
+  [(set (match_operand:VSX_W 0 "vsx_register_operand" "=wf,?<VSa>")
+        (unspec:VSX_W [(match_operand:VSX_W 1 "vsx_register_operand" "wf,<VSa>")
                        (match_operand:QI 2 "u5bit_cint_operand" "i,i")]
                       UNSPEC_VSX_XXSPLTW))]
   "VECTOR_MEM_VSX_P (<MODE>mode)"
@@ -1890,11 +1923,11 @@
 
 ;; V4SF/V4SI interleave
 (define_insn "vsx_xxmrghw_<mode>"
-  [(set (match_operand:VSX_W 0 "vsx_register_operand" "=wf,?wa")
+  [(set (match_operand:VSX_W 0 "vsx_register_operand" "=wf,?<VSa>")
         (vec_select:VSX_W
 	  (vec_concat:<VS_double>
-	    (match_operand:VSX_W 1 "vsx_register_operand" "wf,wa")
-	    (match_operand:VSX_W 2 "vsx_register_operand" "wf,wa"))
+	    (match_operand:VSX_W 1 "vsx_register_operand" "wf,<VSa>")
+	    (match_operand:VSX_W 2 "vsx_register_operand" "wf,<VSa>"))
 	  (parallel [(const_int 0) (const_int 4)
 		     (const_int 1) (const_int 5)])))]
   "VECTOR_MEM_VSX_P (<MODE>mode)"
@@ -1907,11 +1940,11 @@
   [(set_attr "type" "vecperm")])
 
 (define_insn "vsx_xxmrglw_<mode>"
-  [(set (match_operand:VSX_W 0 "vsx_register_operand" "=wf,?wa")
+  [(set (match_operand:VSX_W 0 "vsx_register_operand" "=wf,?<VSa>")
 	(vec_select:VSX_W
 	  (vec_concat:<VS_double>
-	    (match_operand:VSX_W 1 "vsx_register_operand" "wf,wa")
-	    (match_operand:VSX_W 2 "vsx_register_operand" "wf,?wa"))
+	    (match_operand:VSX_W 1 "vsx_register_operand" "wf,<VSa>")
+	    (match_operand:VSX_W 2 "vsx_register_operand" "wf,?<VSa>"))
 	  (parallel [(const_int 2) (const_int 6)
 		     (const_int 3) (const_int 7)])))]
   "VECTOR_MEM_VSX_P (<MODE>mode)"
@@ -1925,9 +1958,9 @@
 
 ;; Shift left double by word immediate
 (define_insn "vsx_xxsldwi_<mode>"
-  [(set (match_operand:VSX_L 0 "vsx_register_operand" "=wa")
-	(unspec:VSX_L [(match_operand:VSX_L 1 "vsx_register_operand" "wa")
-		       (match_operand:VSX_L 2 "vsx_register_operand" "wa")
+  [(set (match_operand:VSX_L 0 "vsx_register_operand" "=<VSa>")
+	(unspec:VSX_L [(match_operand:VSX_L 1 "vsx_register_operand" "<VSa>")
+		       (match_operand:VSX_L 2 "vsx_register_operand" "<VSa>")
 		       (match_operand:QI 3 "u5bit_cint_operand" "i")]
 		      UNSPEC_VSX_SLDWI))]
   "VECTOR_MEM_VSX_P (<MODE>mode)"
Index: gcc/config/rs6000/rs6000.h
===================================================================
--- a/src/gcc/config/rs6000/rs6000.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/rs6000/rs6000.h	(.../branches/gcc-4_9-branch)
@@ -930,35 +930,36 @@
 
    The 3 HTM registers aren't also included in DWARF_FRAME_REGISTERS.  */
 
-#define FIRST_PSEUDO_REGISTER 117
+#define FIRST_PSEUDO_REGISTER 149
 
 /* This must be included for pre gcc 3.0 glibc compatibility.  */
 #define PRE_GCC3_DWARF_FRAME_REGISTERS 77
 
-/* Add 32 dwarf columns for synthetic SPE registers.  */
-#define DWARF_FRAME_REGISTERS ((FIRST_PSEUDO_REGISTER - 4) + 32)
+/* True if register is an SPE High register.  */
+#define SPE_HIGH_REGNO_P(N) \
+  ((N) >= FIRST_SPE_HIGH_REGNO && (N) <= LAST_SPE_HIGH_REGNO)
 
+/* SPE high registers added as hard regs.
+   The sfp register and 3 HTM registers
+   aren't included in DWARF_FRAME_REGISTERS.  */
+#define DWARF_FRAME_REGISTERS (FIRST_PSEUDO_REGISTER - 4)
+
 /* The SPE has an additional 32 synthetic registers, with DWARF debug
    info numbering for these registers starting at 1200.  While eh_frame
    register numbering need not be the same as the debug info numbering,
-   we choose to number these regs for eh_frame at 1200 too.  This allows
-   future versions of the rs6000 backend to add hard registers and
-   continue to use the gcc hard register numbering for eh_frame.  If the
-   extra SPE registers in eh_frame were numbered starting from the
-   current value of FIRST_PSEUDO_REGISTER, then if FIRST_PSEUDO_REGISTER
-   changed we'd need to introduce a mapping in DWARF_FRAME_REGNUM to
-   avoid invalidating older SPE eh_frame info.
+   we choose to number these regs for eh_frame at 1200 too.
 
    We must map them here to avoid huge unwinder tables mostly consisting
    of unused space.  */
 #define DWARF_REG_TO_UNWIND_COLUMN(r) \
-  ((r) > 1200 ? ((r) - 1200 + (DWARF_FRAME_REGISTERS - 32)) : (r))
+  ((r) >= 1200 ? ((r) - 1200 + (DWARF_FRAME_REGISTERS - 32)) : (r))
 
 /* Use standard DWARF numbering for DWARF debugging information.  */
 #define DBX_REGISTER_NUMBER(REGNO) rs6000_dbx_register_number (REGNO)
 
 /* Use gcc hard register numbering for eh_frame.  */
-#define DWARF_FRAME_REGNUM(REGNO) (REGNO)
+#define DWARF_FRAME_REGNUM(REGNO) \
+  (SPE_HIGH_REGNO_P (REGNO) ? ((REGNO) - FIRST_SPE_HIGH_REGNO + 1200) : (REGNO))
 
 /* Map register numbers held in the call frame info that gcc has
    collected using DWARF_FRAME_REGNUM to those that should be output in
@@ -992,7 +993,10 @@
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    1, 1						   \
-   , 1, 1, 1, 1, 1, 1				   \
+   , 1, 1, 1, 1, 1, 1,				   \
+   /* SPE High registers.  */			   \
+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \
+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1  \
 }
 
 /* 1 for registers not available across function calls.
@@ -1012,7 +1016,10 @@
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    1, 1						   \
-   , 1, 1, 1, 1, 1, 1				   \
+   , 1, 1, 1, 1, 1, 1,				   \
+   /* SPE High registers.  */			   \
+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \
+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1  \
 }
 
 /* Like `CALL_USED_REGISTERS' except this macro doesn't require that
@@ -1031,7 +1038,10 @@
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0, 0						   \
-   , 0, 0, 0, 0, 0, 0				   \
+   , 0, 0, 0, 0, 0, 0,				   \
+   /* SPE High registers.  */			   \
+   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
+   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  \
 }
 
 #define TOTAL_ALTIVEC_REGS	(LAST_ALTIVEC_REGNO - FIRST_ALTIVEC_REGNO + 1)
@@ -1114,7 +1124,10 @@
    96, 95, 94, 93, 92, 91,					\
    108, 107, 106, 105, 104, 103, 102, 101, 100, 99, 98, 97,	\
    109, 110,							\
-   111, 112, 113, 114, 115, 116					\
+   111, 112, 113, 114, 115, 116,				\
+   117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128,  \
+   129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140,  \
+   141, 142, 143, 144, 145, 146, 147, 148			\
 }
 
 /* True if register is floating-point.  */
@@ -1349,6 +1362,7 @@
   CR_REGS,
   NON_FLOAT_REGS,
   CA_REGS,
+  SPE_HIGH_REGS,
   ALL_REGS,
   LIM_REG_CLASSES
 };
@@ -1380,6 +1394,7 @@
   "CR_REGS",								\
   "NON_FLOAT_REGS",							\
   "CA_REGS",								\
+  "SPE_HIGH_REGS",							\
   "ALL_REGS"								\
 }
 
@@ -1387,30 +1402,54 @@
    This is an initializer for a vector of HARD_REG_SET
    of length N_REG_CLASSES.  */
 
-#define REG_CLASS_CONTENTS						     \
-{									     \
-  { 0x00000000, 0x00000000, 0x00000000, 0x00000000 }, /* NO_REGS */	     \
-  { 0xfffffffe, 0x00000000, 0x00000008, 0x00020000 }, /* BASE_REGS */	     \
-  { 0xffffffff, 0x00000000, 0x00000008, 0x00020000 }, /* GENERAL_REGS */     \
-  { 0x00000000, 0xffffffff, 0x00000000, 0x00000000 }, /* FLOAT_REGS */       \
-  { 0x00000000, 0x00000000, 0xffffe000, 0x00001fff }, /* ALTIVEC_REGS */     \
-  { 0x00000000, 0xffffffff, 0xffffe000, 0x00001fff }, /* VSX_REGS */	     \
-  { 0x00000000, 0x00000000, 0x00000000, 0x00002000 }, /* VRSAVE_REGS */	     \
-  { 0x00000000, 0x00000000, 0x00000000, 0x00004000 }, /* VSCR_REGS */	     \
-  { 0x00000000, 0x00000000, 0x00000000, 0x00008000 }, /* SPE_ACC_REGS */     \
-  { 0x00000000, 0x00000000, 0x00000000, 0x00010000 }, /* SPEFSCR_REGS */     \
-  { 0x00000000, 0x00000000, 0x00000000, 0x00040000 }, /* SPR_REGS */     \
-  { 0xffffffff, 0xffffffff, 0x00000008, 0x00020000 }, /* NON_SPECIAL_REGS */ \
-  { 0x00000000, 0x00000000, 0x00000002, 0x00000000 }, /* LINK_REGS */	     \
-  { 0x00000000, 0x00000000, 0x00000004, 0x00000000 }, /* CTR_REGS */	     \
-  { 0x00000000, 0x00000000, 0x00000006, 0x00000000 }, /* LINK_OR_CTR_REGS */ \
-  { 0x00000000, 0x00000000, 0x00000006, 0x00002000 }, /* SPECIAL_REGS */     \
-  { 0xffffffff, 0x00000000, 0x0000000e, 0x00022000 }, /* SPEC_OR_GEN_REGS */ \
-  { 0x00000000, 0x00000000, 0x00000010, 0x00000000 }, /* CR0_REGS */	     \
-  { 0x00000000, 0x00000000, 0x00000ff0, 0x00000000 }, /* CR_REGS */	     \
-  { 0xffffffff, 0x00000000, 0x00000ffe, 0x00020000 }, /* NON_FLOAT_REGS */   \
-  { 0x00000000, 0x00000000, 0x00001000, 0x00000000 }, /* CA_REGS */	     \
-  { 0xffffffff, 0xffffffff, 0xfffffffe, 0x0007ffff }  /* ALL_REGS */	     \
+#define REG_CLASS_CONTENTS						\
+{									\
+  /* NO_REGS.  */							\
+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },	\
+  /* BASE_REGS.  */							\
+  { 0xfffffffe, 0x00000000, 0x00000008, 0x00020000, 0x00000000 },	\
+  /* GENERAL_REGS.  */							\
+  { 0xffffffff, 0x00000000, 0x00000008, 0x00020000, 0x00000000 },	\
+  /* FLOAT_REGS.  */							\
+  { 0x00000000, 0xffffffff, 0x00000000, 0x00000000, 0x00000000 },	\
+  /* ALTIVEC_REGS.  */							\
+  { 0x00000000, 0x00000000, 0xffffe000, 0x00001fff, 0x00000000 },	\
+  /* VSX_REGS.  */							\
+  { 0x00000000, 0xffffffff, 0xffffe000, 0x00001fff, 0x00000000 },	\
+  /* VRSAVE_REGS.  */							\
+  { 0x00000000, 0x00000000, 0x00000000, 0x00002000, 0x00000000 },	\
+  /* VSCR_REGS.  */							\
+  { 0x00000000, 0x00000000, 0x00000000, 0x00004000, 0x00000000 },	\
+  /* SPE_ACC_REGS.  */							\
+  { 0x00000000, 0x00000000, 0x00000000, 0x00008000, 0x00000000 },	\
+  /* SPEFSCR_REGS.  */							\
+  { 0x00000000, 0x00000000, 0x00000000, 0x00010000, 0x00000000 },	\
+  /* SPR_REGS.  */							\
+  { 0x00000000, 0x00000000, 0x00000000, 0x00040000, 0x00000000 },	\
+  /* NON_SPECIAL_REGS.  */						\
+  { 0xffffffff, 0xffffffff, 0x00000008, 0x00020000, 0x00000000 },	\
+  /* LINK_REGS.  */							\
+  { 0x00000000, 0x00000000, 0x00000002, 0x00000000, 0x00000000 },	\
+  /* CTR_REGS.  */							\
+  { 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0x00000000 },	\
+  /* LINK_OR_CTR_REGS.  */						\
+  { 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000 },	\
+  /* SPECIAL_REGS.  */							\
+  { 0x00000000, 0x00000000, 0x00000006, 0x00002000, 0x00000000 },	\
+  /* SPEC_OR_GEN_REGS.  */						\
+  { 0xffffffff, 0x00000000, 0x0000000e, 0x00022000, 0x00000000 },	\
+  /* CR0_REGS.  */							\
+  { 0x00000000, 0x00000000, 0x00000010, 0x00000000, 0x00000000 },	\
+  /* CR_REGS.  */							\
+  { 0x00000000, 0x00000000, 0x00000ff0, 0x00000000, 0x00000000 },	\
+  /* NON_FLOAT_REGS.  */						\
+  { 0xffffffff, 0x00000000, 0x00000ffe, 0x00020000, 0x00000000 },	\
+  /* CA_REGS.  */							\
+  { 0x00000000, 0x00000000, 0x00001000, 0x00000000, 0x00000000 },	\
+  /* SPE_HIGH_REGS.  */							\
+  { 0x00000000, 0x00000000, 0x00000000, 0xffe00000, 0x001fffff },	\
+  /* ALL_REGS.  */							\
+  { 0xffffffff, 0xffffffff, 0xfffffffe, 0xffe7ffff, 0x001fffff }	\
 }
 
 /* The same information, inverted:
@@ -1439,6 +1478,10 @@
   RS6000_CONSTRAINT_wd,		/* VSX register for V2DF */
   RS6000_CONSTRAINT_wf,		/* VSX register for V4SF */
   RS6000_CONSTRAINT_wg,		/* FPR register for -mmfpgpr */
+  RS6000_CONSTRAINT_wh,		/* FPR register for direct moves.  */
+  RS6000_CONSTRAINT_wi,		/* FPR/VSX register to hold DImode */
+  RS6000_CONSTRAINT_wj,		/* FPR/VSX register for DImode direct moves. */
+  RS6000_CONSTRAINT_wk,		/* FPR/VSX register for DFmode direct moves. */
   RS6000_CONSTRAINT_wl,		/* FPR register for LFIWAX */
   RS6000_CONSTRAINT_wm,		/* VSX register for direct move */
   RS6000_CONSTRAINT_wr,		/* GPR register if 64-bit  */
@@ -1463,6 +1506,9 @@
 #define VSX_REG_CLASS_P(CLASS)			\
   ((CLASS) == VSX_REGS || (CLASS) == FLOAT_REGS || (CLASS) == ALTIVEC_REGS)
 
+/* Return whether a given register class targets general purpose registers.  */
+#define GPR_REG_CLASS_P(CLASS) ((CLASS) == GENERAL_REGS || (CLASS) == BASE_REGS)
+
 /* Given an rtx X being reloaded into a reg required to be
    in class CLASS, return the class of reg to actually use.
    In general this is just CLASS; but on some machines
@@ -2349,6 +2395,39 @@
   &rs6000_reg_names[114][0],	/* tfhar  */				\
   &rs6000_reg_names[115][0],	/* tfiar  */				\
   &rs6000_reg_names[116][0],	/* texasr  */				\
+									\
+  &rs6000_reg_names[117][0],	/* SPE rh0.  */				\
+  &rs6000_reg_names[118][0],	/* SPE rh1.  */				\
+  &rs6000_reg_names[119][0],	/* SPE rh2.  */				\
+  &rs6000_reg_names[120][0],	/* SPE rh3.  */				\
+  &rs6000_reg_names[121][0],	/* SPE rh4.  */				\
+  &rs6000_reg_names[122][0],	/* SPE rh5.  */				\
+  &rs6000_reg_names[123][0],	/* SPE rh6.  */				\
+  &rs6000_reg_names[124][0],	/* SPE rh7.  */				\
+  &rs6000_reg_names[125][0],	/* SPE rh8.  */				\
+  &rs6000_reg_names[126][0],	/* SPE rh9.  */				\
+  &rs6000_reg_names[127][0],	/* SPE rh10.  */			\
+  &rs6000_reg_names[128][0],	/* SPE rh11.  */			\
+  &rs6000_reg_names[129][0],	/* SPE rh12.  */			\
+  &rs6000_reg_names[130][0],	/* SPE rh13.  */			\
+  &rs6000_reg_names[131][0],	/* SPE rh14.  */			\
+  &rs6000_reg_names[132][0],	/* SPE rh15.  */			\
+  &rs6000_reg_names[133][0],	/* SPE rh16.  */			\
+  &rs6000_reg_names[134][0],	/* SPE rh17.  */			\
+  &rs6000_reg_names[135][0],	/* SPE rh18.  */			\
+  &rs6000_reg_names[136][0],	/* SPE rh19.  */			\
+  &rs6000_reg_names[137][0],	/* SPE rh20.  */			\
+  &rs6000_reg_names[138][0],	/* SPE rh21.  */			\
+  &rs6000_reg_names[139][0],	/* SPE rh22.  */			\
+  &rs6000_reg_names[140][0],	/* SPE rh22.  */			\
+  &rs6000_reg_names[141][0],	/* SPE rh24.  */			\
+  &rs6000_reg_names[142][0],	/* SPE rh25.  */			\
+  &rs6000_reg_names[143][0],	/* SPE rh26.  */			\
+  &rs6000_reg_names[144][0],	/* SPE rh27.  */			\
+  &rs6000_reg_names[145][0],	/* SPE rh28.  */			\
+  &rs6000_reg_names[146][0],	/* SPE rh29.  */			\
+  &rs6000_reg_names[147][0],	/* SPE rh30.  */			\
+  &rs6000_reg_names[148][0],	/* SPE rh31.  */			\
 }
 
 /* Table of additional register names to use in user input.  */
@@ -2404,7 +2483,17 @@
   {"vs56", 101},{"vs57", 102},{"vs58", 103},{"vs59", 104},      \
   {"vs60", 105},{"vs61", 106},{"vs62", 107},{"vs63", 108},	\
   /* Transactional Memory Facility (HTM) Registers.  */		\
-  {"tfhar",  114}, {"tfiar",  115}, {"texasr",  116} }
+  {"tfhar",  114}, {"tfiar",  115}, {"texasr",  116},		\
+  /* SPE high registers.  */					\
+  {"rh0",  117}, {"rh1",  118}, {"rh2",  119}, {"rh3",  120},	\
+  {"rh4",  121}, {"rh5",  122}, {"rh6",  123}, {"rh7",  124},	\
+  {"rh8",  125}, {"rh9",  126}, {"rh10", 127}, {"rh11", 128},	\
+  {"rh12", 129}, {"rh13", 130}, {"rh14", 131}, {"rh15", 132},	\
+  {"rh16", 133}, {"rh17", 134}, {"rh18", 135}, {"rh19", 136},	\
+  {"rh20", 137}, {"rh21", 138}, {"rh22", 139}, {"rh23", 140},	\
+  {"rh24", 141}, {"rh25", 142}, {"rh26", 143}, {"rh27", 144},	\
+  {"rh28", 145}, {"rh29", 146}, {"rh30", 147}, {"rh31", 148},	\
+}
 
 /* This is how to output an element of a case-vector that is relative.  */
 
Index: gcc/config/rs6000/rs6000.md
===================================================================
--- a/src/gcc/config/rs6000/rs6000.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/rs6000/rs6000.md	(.../branches/gcc-4_9-branch)
@@ -56,6 +56,8 @@
    (TFHAR_REGNO			114)
    (TFIAR_REGNO			115)
    (TEXASR_REGNO		116)
+   (FIRST_SPE_HIGH_REGNO	117)
+   (LAST_SPE_HIGH_REGNO		148)
   ])
 
 ;;
@@ -326,7 +328,7 @@
 (define_mode_attr f32_sv [(SF "stxsspx %x1,%y0")  (SD "stxsiwzx %x1,%y0")])
 
 ; Definitions for 32-bit fpr direct move
-(define_mode_attr f32_dm [(SF "wn") (SD "wm")])
+(define_mode_attr f32_dm [(SF "wn") (SD "wh")])
 
 ; These modes do not fit in integer registers in 32-bit mode.
 ; but on e500v2, the gpr are 64 bit registers
@@ -575,7 +577,7 @@
   "")
 
 (define_insn "*zero_extendsidi2_lfiwzx"
-  [(set (match_operand:DI 0 "gpc_reg_operand" "=r,r,??wm,!wz,!wu")
+  [(set (match_operand:DI 0 "gpc_reg_operand" "=r,r,??wj,!wz,!wu")
 	(zero_extend:DI (match_operand:SI 1 "reg_or_mem_operand" "m,r,r,Z,Z")))]
   "TARGET_POWERPC64 && TARGET_LFIWZX"
   "@
@@ -745,7 +747,7 @@
   "")
 
 (define_insn "*extendsidi2_lfiwax"
-  [(set (match_operand:DI 0 "gpc_reg_operand" "=r,r,??wm,!wl,!wu")
+  [(set (match_operand:DI 0 "gpc_reg_operand" "=r,r,??wj,!wl,!wu")
 	(sign_extend:DI (match_operand:SI 1 "lwa_operand" "Y,r,r,Z,Z")))]
   "TARGET_POWERPC64 && TARGET_LFIWAX"
   "@
@@ -5623,7 +5625,7 @@
 ; We don't define lfiwax/lfiwzx with the normal definition, because we
 ; don't want to support putting SImode in FPR registers.
 (define_insn "lfiwax"
-  [(set (match_operand:DI 0 "gpc_reg_operand" "=d,wm,!wm")
+  [(set (match_operand:DI 0 "gpc_reg_operand" "=d,wj,!wj")
 	(unspec:DI [(match_operand:SI 1 "reg_or_indexed_operand" "Z,Z,r")]
 		   UNSPEC_LFIWAX))]
   "TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWAX"
@@ -5703,7 +5705,7 @@
    (set_attr "type" "fpload")])
 
 (define_insn "lfiwzx"
-  [(set (match_operand:DI 0 "gpc_reg_operand" "=d,wm,!wm")
+  [(set (match_operand:DI 0 "gpc_reg_operand" "=d,wj,!wj")
 	(unspec:DI [(match_operand:SI 1 "reg_or_indexed_operand" "Z,Z,r")]
 		   UNSPEC_LFIWZX))]
   "TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWZX"
@@ -9457,8 +9459,8 @@
 ; ld/std require word-aligned displacements -> 'Y' constraint.
 ; List Y->r and r->Y before r->r for reload.
 (define_insn "*mov<mode>_hardfloat64"
-  [(set (match_operand:FMOVE64 0 "nonimmediate_operand" "=m,d,d,wv,Z,wa,wa,Y,r,!r,*c*l,!r,*h,!r,!r,!r,r,wg,r,wm")
-	(match_operand:FMOVE64 1 "input_operand" "d,m,d,Z,wv,wa,j,r,Y,r,r,h,0,G,H,F,wg,r,wm,r"))]
+  [(set (match_operand:FMOVE64 0 "nonimmediate_operand" "=m,d,d,wv,Z,wa,wa,Y,r,!r,*c*l,!r,*h,!r,!r,!r,r,wg,r,wk")
+	(match_operand:FMOVE64 1 "input_operand" "d,m,d,Z,wv,wa,j,r,Y,r,r,h,0,G,H,F,wg,r,wk,r"))]
   "TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT
    && (gpc_reg_operand (operands[0], <MODE>mode)
        || gpc_reg_operand (operands[1], <MODE>mode))"
@@ -10237,8 +10239,8 @@
 { rs6000_split_multireg_move (operands[0], operands[1]); DONE; })
 
 (define_insn "*movdi_internal64"
-  [(set (match_operand:DI 0 "nonimmediate_operand" "=Y,r,r,r,r,r,?m,?*d,?*d,r,*h,*h,r,?*wg,r,?*wm")
-	(match_operand:DI 1 "input_operand" "r,Y,r,I,L,nF,d,m,d,*h,r,0,*wg,r,*wm,r"))]
+  [(set (match_operand:DI 0 "nonimmediate_operand" "=Y,r,r,r,r,r,?m,?*d,?*d,r,*h,*h,r,?*wg,r,?*wj,?*wi")
+	(match_operand:DI 1 "input_operand" "r,Y,r,I,L,nF,d,m,d,*h,r,0,*wg,r,*wj,r,O"))]
   "TARGET_POWERPC64
    && (gpc_reg_operand (operands[0], DImode)
        || gpc_reg_operand (operands[1], DImode))"
@@ -10258,7 +10260,8 @@
    mftgpr %0,%1
    mffgpr %0,%1
    mfvsrd %0,%x1
-   mtvsrd %x0,%1"
+   mtvsrd %x0,%1
+   xxlxor %x0,%x0,%x0"
   [(set_attr_alternative "type"
       [(if_then_else
 	 (match_test "update_indexed_address_mem (operands[0], VOIDmode)")
@@ -10299,8 +10302,9 @@
        (const_string "mftgpr")
        (const_string "mffgpr")
        (const_string "mftgpr")
-       (const_string "mffgpr")])
-   (set_attr "length" "4,4,4,4,4,20,4,4,4,4,4,4,4,4,4,4")])
+       (const_string "mffgpr")
+       (const_string "vecsimple")])
+   (set_attr "length" "4,4,4,4,4,20,4,4,4,4,4,4,4,4,4,4,4")])
 
 ;; Generate all one-bits and clear left or right.
 ;; Use (and:DI (rotate:DI ...)) to avoid anddi3 unnecessary clobber.
Index: gcc/config/rs6000/sysv4.h
===================================================================
--- a/src/gcc/config/rs6000/sysv4.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/rs6000/sysv4.h	(.../branches/gcc-4_9-branch)
@@ -292,7 +292,7 @@
 /* An expression for the alignment of a structure field FIELD if the
    alignment computed in the usual way is COMPUTED.  */
 #define ADJUST_FIELD_ALIGN(FIELD, COMPUTED)				      \
-	((TARGET_ALTIVEC && TREE_CODE (TREE_TYPE (FIELD)) == VECTOR_TYPE)     \
+	(rs6000_special_adjust_field_align_p ((FIELD), (COMPUTED))	      \
 	 ? 128 : COMPUTED)
 
 #undef  BIGGEST_FIELD_ALIGNMENT
@@ -949,3 +949,19 @@
 #define TARGET_USES_SYSV4_OPT 1
 
 #undef DBX_REGISTER_NUMBER
+
+/* Link -lasan early on the command line.  For -static-libasan, don't link
+   it for -shared link, the executable should be compiled with -static-libasan
+   in that case, and for executable link link with --{,no-}whole-archive around
+   it to force everything into the executable.  And similarly for -ltsan.  */
+#if defined(HAVE_LD_STATIC_DYNAMIC)
+#undef LIBASAN_EARLY_SPEC
+#define LIBASAN_EARLY_SPEC "%{!shared:libasan_preinit%O%s} " \
+  "%{static-libasan:%{!shared:" \
+  LD_STATIC_OPTION " --whole-archive -lasan --no-whole-archive " \
+  LD_DYNAMIC_OPTION "}}%{!static-libasan:-lasan}"
+#undef LIBTSAN_EARLY_SPEC
+#define LIBTSAN_EARLY_SPEC "%{static-libtsan:%{!shared:" \
+  LD_STATIC_OPTION " --whole-archive -ltsan --no-whole-archive " \
+  LD_DYNAMIC_OPTION "}}%{!static-libtsan:-ltsan}"
+#endif
Index: gcc/config/arm/vfp.md
===================================================================
--- a/src/gcc/config/arm/vfp.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/arm/vfp.md	(.../branches/gcc-4_9-branch)
@@ -1254,17 +1254,15 @@
 )
 
 (define_insn "*combine_vcvtf2i"
-  [(set (match_operand:SI 0 "s_register_operand" "=r")
-	(fix:SI (fix:SF (mult:SF (match_operand:SF 1 "s_register_operand" "t")
+  [(set (match_operand:SI 0 "s_register_operand" "=t")
+	(fix:SI (fix:SF (mult:SF (match_operand:SF 1 "s_register_operand" "0")
 				 (match_operand 2
 				 "const_double_vcvt_power_of_two" "Dp")))))]
   "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP3 && !flag_rounding_math"
-  "vcvt%?.s32.f32\\t%1, %1, %v2\;vmov%?\\t%0, %1"
+  "vcvt%?.s32.f32\\t%0, %1, %v2"
   [(set_attr "predicable" "yes")
    (set_attr "predicable_short_it" "no")
-   (set_attr "ce_count" "2")
-   (set_attr "type" "f_cvtf2i")
-   (set_attr "length" "8")]
+   (set_attr "type" "f_cvtf2i")]
  )
 
 ;; Store multiple insn used in function prologue.
Index: gcc/config/arm/t-rtems-eabi
===================================================================
--- a/src/gcc/config/arm/t-rtems-eabi	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/arm/t-rtems-eabi	(.../branches/gcc-4_9-branch)
@@ -1,47 +1,167 @@
 # Custom RTEMS EABI multilibs
 
-MULTILIB_OPTIONS  = mthumb march=armv6-m/march=armv7-a/march=armv7-r/march=armv7-m mfpu=neon mfloat-abi=hard
-MULTILIB_DIRNAMES = thumb armv6-m armv7-a armv7-r armv7-m neon hard
+MULTILIB_OPTIONS  = mbig-endian mthumb march=armv6-m/march=armv7-a/march=armv7-r/march=armv7-m mfpu=neon/mfpu=vfpv3-d16/mfpu=fpv4-sp-d16 mfloat-abi=hard
+MULTILIB_DIRNAMES = eb thumb armv6-m armv7-a armv7-r armv7-m neon vfpv3-d16 fpv4-sp-d16 hard
 
 # Enumeration of multilibs
 
 MULTILIB_EXCEPTIONS =
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv6-m/mfpu=neon/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv6-m/mfpu=neon
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv6-m/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv6-m/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv6-m/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv6-m/mfpu=fpv4-sp-d16
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv6-m/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv6-m
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-a/mfpu=neon/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-a/mfpu=neon
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-a/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-a/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-a/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-a/mfpu=fpv4-sp-d16
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-a/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-a
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-r/mfpu=neon/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-r/mfpu=neon
+# MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-r/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-r/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-r/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-r/mfpu=fpv4-sp-d16
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-r/mfloat-abi=hard
+# MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-r
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-m/mfpu=neon/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-m/mfpu=neon
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-m/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-m/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-m/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-m/mfpu=fpv4-sp-d16
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-m/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-m
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/mfpu=neon/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/mfpu=neon
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/mfpu=fpv4-sp-d16
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv6-m/mfpu=neon/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv6-m/mfpu=neon
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv6-m/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv6-m/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv6-m/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv6-m/mfpu=fpv4-sp-d16
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv6-m/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv6-m
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-a/mfpu=neon/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-a/mfpu=neon
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-a/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-a/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-a/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-a/mfpu=fpv4-sp-d16
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-a/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-a
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-r/mfpu=neon/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-r/mfpu=neon
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-r/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-r/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-r/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-r/mfpu=fpv4-sp-d16
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-r/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-r
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-m/mfpu=neon/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-m/mfpu=neon
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-m/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-m/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-m/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-m/mfpu=fpv4-sp-d16
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-m/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-m
+MULTILIB_EXCEPTIONS += mbig-endian/mfpu=neon/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mfpu=neon
+MULTILIB_EXCEPTIONS += mbig-endian/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += mbig-endian/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mfpu=fpv4-sp-d16
+MULTILIB_EXCEPTIONS += mbig-endian/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian
 MULTILIB_EXCEPTIONS += mthumb/march=armv6-m/mfpu=neon/mfloat-abi=hard
 MULTILIB_EXCEPTIONS += mthumb/march=armv6-m/mfpu=neon
+MULTILIB_EXCEPTIONS += mthumb/march=armv6-m/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mthumb/march=armv6-m/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += mthumb/march=armv6-m/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mthumb/march=armv6-m/mfpu=fpv4-sp-d16
 MULTILIB_EXCEPTIONS += mthumb/march=armv6-m/mfloat-abi=hard
 # MULTILIB_EXCEPTIONS += mthumb/march=armv6-m
 # MULTILIB_EXCEPTIONS += mthumb/march=armv7-a/mfpu=neon/mfloat-abi=hard
 MULTILIB_EXCEPTIONS += mthumb/march=armv7-a/mfpu=neon
+MULTILIB_EXCEPTIONS += mthumb/march=armv7-a/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mthumb/march=armv7-a/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += mthumb/march=armv7-a/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mthumb/march=armv7-a/mfpu=fpv4-sp-d16
 MULTILIB_EXCEPTIONS += mthumb/march=armv7-a/mfloat-abi=hard
 # MULTILIB_EXCEPTIONS += mthumb/march=armv7-a
 MULTILIB_EXCEPTIONS += mthumb/march=armv7-r/mfpu=neon/mfloat-abi=hard
 MULTILIB_EXCEPTIONS += mthumb/march=armv7-r/mfpu=neon
+# MULTILIB_EXCEPTIONS += mthumb/march=armv7-r/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mthumb/march=armv7-r/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += mthumb/march=armv7-r/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mthumb/march=armv7-r/mfpu=fpv4-sp-d16
 MULTILIB_EXCEPTIONS += mthumb/march=armv7-r/mfloat-abi=hard
 # MULTILIB_EXCEPTIONS += mthumb/march=armv7-r
 MULTILIB_EXCEPTIONS += mthumb/march=armv7-m/mfpu=neon/mfloat-abi=hard
 MULTILIB_EXCEPTIONS += mthumb/march=armv7-m/mfpu=neon
+MULTILIB_EXCEPTIONS += mthumb/march=armv7-m/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mthumb/march=armv7-m/mfpu=vfpv3-d16
+# MULTILIB_EXCEPTIONS += mthumb/march=armv7-m/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mthumb/march=armv7-m/mfpu=fpv4-sp-d16
 MULTILIB_EXCEPTIONS += mthumb/march=armv7-m/mfloat-abi=hard
 # MULTILIB_EXCEPTIONS += mthumb/march=armv7-m
 MULTILIB_EXCEPTIONS += mthumb/mfpu=neon/mfloat-abi=hard
 MULTILIB_EXCEPTIONS += mthumb/mfpu=neon
+MULTILIB_EXCEPTIONS += mthumb/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mthumb/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += mthumb/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mthumb/mfpu=fpv4-sp-d16
 MULTILIB_EXCEPTIONS += mthumb/mfloat-abi=hard
 # MULTILIB_EXCEPTIONS += mthumb
 MULTILIB_EXCEPTIONS += march=armv6-m/mfpu=neon/mfloat-abi=hard
 MULTILIB_EXCEPTIONS += march=armv6-m/mfpu=neon
+MULTILIB_EXCEPTIONS += march=armv6-m/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += march=armv6-m/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += march=armv6-m/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += march=armv6-m/mfpu=fpv4-sp-d16
 MULTILIB_EXCEPTIONS += march=armv6-m/mfloat-abi=hard
 MULTILIB_EXCEPTIONS += march=armv6-m
 MULTILIB_EXCEPTIONS += march=armv7-a/mfpu=neon/mfloat-abi=hard
 MULTILIB_EXCEPTIONS += march=armv7-a/mfpu=neon
+MULTILIB_EXCEPTIONS += march=armv7-a/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += march=armv7-a/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += march=armv7-a/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += march=armv7-a/mfpu=fpv4-sp-d16
 MULTILIB_EXCEPTIONS += march=armv7-a/mfloat-abi=hard
 MULTILIB_EXCEPTIONS += march=armv7-a
 MULTILIB_EXCEPTIONS += march=armv7-r/mfpu=neon/mfloat-abi=hard
 MULTILIB_EXCEPTIONS += march=armv7-r/mfpu=neon
+MULTILIB_EXCEPTIONS += march=armv7-r/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += march=armv7-r/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += march=armv7-r/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += march=armv7-r/mfpu=fpv4-sp-d16
 MULTILIB_EXCEPTIONS += march=armv7-r/mfloat-abi=hard
 MULTILIB_EXCEPTIONS += march=armv7-r
 MULTILIB_EXCEPTIONS += march=armv7-m/mfpu=neon/mfloat-abi=hard
 MULTILIB_EXCEPTIONS += march=armv7-m/mfpu=neon
+MULTILIB_EXCEPTIONS += march=armv7-m/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += march=armv7-m/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += march=armv7-m/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += march=armv7-m/mfpu=fpv4-sp-d16
 MULTILIB_EXCEPTIONS += march=armv7-m/mfloat-abi=hard
 MULTILIB_EXCEPTIONS += march=armv7-m
 MULTILIB_EXCEPTIONS += mfpu=neon/mfloat-abi=hard
 MULTILIB_EXCEPTIONS += mfpu=neon
+MULTILIB_EXCEPTIONS += mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mfpu=fpv4-sp-d16
 MULTILIB_EXCEPTIONS += mfloat-abi=hard
Index: gcc/config/pa/pa.md
===================================================================
--- a/src/gcc/config/pa/pa.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/pa/pa.md	(.../branches/gcc-4_9-branch)
@@ -8508,36 +8508,6 @@
   [(set_attr "type" "move")
    (set_attr "length" "4")])
 
-;; These are just placeholders so we know where branch tables
-;; begin and end.
-(define_insn "begin_brtab"
-  [(const_int 1)]
-  ""
-  "*
-{
-  /* Only GAS actually supports this pseudo-op.  */
-  if (TARGET_GAS)
-    return \".begin_brtab\";
-  else
-    return \"\";
-}"
-  [(set_attr "type" "move")
-   (set_attr "length" "0")])
-
-(define_insn "end_brtab"
-  [(const_int 2)]
-  ""
-  "*
-{
-  /* Only GAS actually supports this pseudo-op.  */
-  if (TARGET_GAS)
-    return \".end_brtab\";
-  else
-    return \"\";
-}"
-  [(set_attr "type" "move")
-   (set_attr "length" "0")])
-
 ;;; EH does longjmp's from and within the data section.  Thus,
 ;;; an interspace branch is required for the longjmp implementation.
 ;;; Registers r1 and r2 are used as scratch registers for the jump
Index: gcc/config/pa/pa-protos.h
===================================================================
--- a/src/gcc/config/pa/pa-protos.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/pa/pa-protos.h	(.../branches/gcc-4_9-branch)
@@ -49,6 +49,8 @@
 extern const char *pa_output_div_insn (rtx *, int, rtx);
 extern const char *pa_output_mod_insn (int, rtx);
 extern const char *pa_singlemove_string (rtx *);
+extern void pa_output_addr_vec (rtx, rtx);
+extern void pa_output_addr_diff_vec (rtx, rtx);
 extern void pa_output_arg_descriptor (rtx);
 extern void pa_output_global_address (FILE *, rtx, int);
 extern void pa_print_operand (FILE *, rtx, int);
Index: gcc/config/pa/pa.c
===================================================================
--- a/src/gcc/config/pa/pa.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/pa/pa.c	(.../branches/gcc-4_9-branch)
@@ -4155,9 +4155,8 @@
 pa_output_function_epilogue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)
 {
   rtx insn = get_last_insn ();
+  bool extra_nop;
 
-  last_address = 0;
-
   /* pa_expand_epilogue does the dirty work now.  We just need
      to output the assembler directives which denote the end
      of a function.
@@ -4180,8 +4179,10 @@
   if (insn && CALL_P (insn))
     {
       fputs ("\tnop\n", file);
-      last_address += 4;
+      extra_nop = true;
     }
+  else
+    extra_nop = false;
 
   fputs ("\t.EXIT\n\t.PROCEND\n", file);
 
@@ -4194,12 +4195,13 @@
       cfun->machine->in_nsubspa = 2;
     }
 
-  /* Thunks do their own accounting.  */
+  /* Thunks do their own insn accounting.  */
   if (cfun->is_thunk)
     return;
 
   if (INSN_ADDRESSES_SET_P ())
     {
+      last_address = extra_nop ? 4 : 0;
       insn = get_last_nonnote_insn ();
       last_address += INSN_ADDRESSES (INSN_UID (insn));
       if (INSN_P (insn))
@@ -8293,12 +8295,16 @@
 		   || ((DECL_SECTION_NAME (thunk_fndecl)
 			== DECL_SECTION_NAME (function))
 		       && last_address < 262132)))
+	      /* In this case, we need to be able to reach the start of
+		 the stub table even though the function is likely closer
+		 and can be jumped to directly.  */
 	      || (targetm_common.have_named_sections
 		  && DECL_SECTION_NAME (thunk_fndecl) == NULL
 		  && DECL_SECTION_NAME (function) == NULL
-		  && last_address < 262132)
+		  && total_code_bytes < MAX_PCREL17F_OFFSET)
+	      /* Likewise.  */
 	      || (!targetm_common.have_named_sections
-		  && last_address < 262132))))
+		  && total_code_bytes < MAX_PCREL17F_OFFSET))))
     {
       if (!val_14)
 	output_asm_insn ("addil L'%2,%%r26", xoperands);
@@ -8944,40 +8950,15 @@
 }
 
 /* We use this hook to perform a PA specific optimization which is difficult
-   to do in earlier passes.
+   to do in earlier passes.  */
 
-   We surround the jump table itself with BEGIN_BRTAB and END_BRTAB
-   insns.  Those insns mark where we should emit .begin_brtab and
-   .end_brtab directives when using GAS.  This allows for better link
-   time optimizations.  */
-
 static void
 pa_reorg (void)
 {
-  rtx insn;
-
   remove_useless_addtr_insns (1);
 
   if (pa_cpu < PROCESSOR_8000)
     pa_combine_instructions ();
-
-    /* Still need brtab marker insns.  FIXME: the presence of these
-       markers disables output of the branch table to readonly memory,
-       and any alignment directives that might be needed.  Possibly,
-       the begin_brtab insn should be output before the label for the
-       table.  This doesn't matter at the moment since the tables are
-       always output in the text section.  */
-    for (insn = get_insns (); insn; insn = NEXT_INSN (insn))
-      {
-	/* Find an ADDR_VEC insn.  */
-	if (! JUMP_TABLE_DATA_P (insn))
-	  continue;
-
-	/* Now generate markers for the beginning and end of the
-	   branch table.  */
-	emit_insn_before (gen_begin_brtab (), insn);
-	emit_insn_after (gen_end_brtab (), insn);
-      }
 }
 
 /* The PA has a number of odd instructions which can perform multiple
@@ -10572,4 +10553,46 @@
   return NULL_RTX;
 }
 
+/* Output address vector.  */
+
+void
+pa_output_addr_vec (rtx lab, rtx body)
+{
+  int idx, vlen = XVECLEN (body, 0);
+
+  targetm.asm_out.internal_label (asm_out_file, "L", CODE_LABEL_NUMBER (lab));
+  if (TARGET_GAS)
+    fputs ("\t.begin_brtab\n", asm_out_file);
+  for (idx = 0; idx < vlen; idx++)
+    {
+      ASM_OUTPUT_ADDR_VEC_ELT
+	(asm_out_file, CODE_LABEL_NUMBER (XEXP (XVECEXP (body, 0, idx), 0)));
+    }
+  if (TARGET_GAS)
+    fputs ("\t.end_brtab\n", asm_out_file);
+}
+
+/* Output address difference vector.  */
+
+void
+pa_output_addr_diff_vec (rtx lab, rtx body)
+{
+  rtx base = XEXP (XEXP (body, 0), 0);
+  int idx, vlen = XVECLEN (body, 1);
+
+  targetm.asm_out.internal_label (asm_out_file, "L", CODE_LABEL_NUMBER (lab));
+  if (TARGET_GAS)
+    fputs ("\t.begin_brtab\n", asm_out_file);
+  for (idx = 0; idx < vlen; idx++)
+    {
+      ASM_OUTPUT_ADDR_DIFF_ELT
+	(asm_out_file,
+	 body,
+	 CODE_LABEL_NUMBER (XEXP (XVECEXP (body, 1, idx), 0)),
+	 CODE_LABEL_NUMBER (base));
+    }
+  if (TARGET_GAS)
+    fputs ("\t.end_brtab\n", asm_out_file);
+}
+
 #include "gt-pa.h"
Index: gcc/config/pa/pa.h
===================================================================
--- a/src/gcc/config/pa/pa.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/pa/pa.h	(.../branches/gcc-4_9-branch)
@@ -1193,6 +1193,16 @@
 #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \
   fprintf (FILE, "\t.word L$%04d-L$%04d\n", VALUE, REL)
 
+/* This is how to output an absolute case-vector.  */
+
+#define ASM_OUTPUT_ADDR_VEC(LAB,BODY)	\
+  pa_output_addr_vec ((LAB),(BODY))
+
+/* This is how to output a relative case-vector.  */
+
+#define ASM_OUTPUT_ADDR_DIFF_VEC(LAB,BODY)	\
+  pa_output_addr_diff_vec ((LAB),(BODY))
+
 /* This is how to output an assembler line that says to advance the
    location counter to a multiple of 2**LOG bytes.  */
 
Index: gcc/tree-ssanames.h
===================================================================
--- a/src/gcc/tree-ssanames.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/tree-ssanames.h	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,6 @@
 
 
 #define SSANAMES(fun) (fun)->gimple_df->ssa_names
-#define MODIFIED_NORETURN_CALLS(fun) (fun)->gimple_df->modified_noreturn_calls
 #define DEFAULT_DEFS(fun) (fun)->gimple_df->default_defs
 
 #define num_ssa_names (vec_safe_length (cfun->gimple_df->ssa_names))
Index: gcc/tree-ssa-operands.c
===================================================================
--- a/src/gcc/tree-ssa-operands.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/tree-ssa-operands.c	(.../branches/gcc-4_9-branch)
@@ -1091,12 +1091,6 @@
 
   timevar_push (TV_TREE_OPS);
 
-  /* If the stmt is a noreturn call queue it to be processed by
-     split_bbs_on_noreturn_calls during cfg cleanup.  */
-  if (is_gimple_call (stmt)
-      && gimple_call_noreturn_p (stmt))
-    vec_safe_push (MODIFIED_NORETURN_CALLS (fn), stmt);
-
   gcc_assert (gimple_modified_p (stmt));
   build_ssa_operands (fn, stmt);
   gimple_set_modified (stmt, false);
Index: libgo/runtime/mgc0.c
===================================================================
--- a/src/libgo/runtime/mgc0.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgo/runtime/mgc0.c	(.../branches/gcc-4_9-branch)
@@ -2000,6 +2000,7 @@
 		runtime_mcall(mgc);
 		// record a new start time in case we're going around again
 		a.start_time = runtime_nanotime();
+		m = runtime_m();
 	}
 
 	// all done
Index: libgo/runtime/go-caller.c
===================================================================
--- a/src/libgo/runtime/go-caller.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgo/runtime/go-caller.c	(.../branches/gcc-4_9-branch)
@@ -7,6 +7,9 @@
 /* Implement runtime.Caller.  */
 
 #include <stdint.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
 
 #include "backtrace.h"
 
@@ -99,6 +102,7 @@
   if (back_state == NULL)
     {
       const char *filename;
+      struct stat s;
 
       filename = (const char *) runtime_progname ();
 
@@ -108,6 +112,14 @@
       if (__builtin_strchr (filename, '/') == NULL)
 	filename = NULL;
 
+      /* If the file is small, then it's not the real executable.
+	 This is specifically to deal with Docker, which uses a bogus
+	 argv[0] (http://gcc.gnu.org/PR61895).  It would be nice to
+	 have a better check for whether this file is the real
+	 executable.  */
+      if (stat (filename, &s) < 0 || s.st_size < 1024)
+	filename = NULL;
+
       back_state = backtrace_create_state (filename, 1, error_callback, NULL);
     }
   runtime_unlock (&back_state_lock);
Index: libgo/runtime/malloc.goc
===================================================================
--- a/src/libgo/runtime/malloc.goc	(.../tags/gcc_4_9_1_release)
+++ b/src/libgo/runtime/malloc.goc	(.../branches/gcc-4_9-branch)
@@ -79,6 +79,7 @@
 	MSpan *s;
 	MLink *v;
 	bool incallback;
+	void *closure;
 
 	if(size == 0) {
 		// All 0-length allocations use this pointer.
@@ -90,6 +91,10 @@
 	m = runtime_m();
 	g = runtime_g();
 
+	// We should not be called in between __go_set_closure and the
+	// actual function call, but cope with it if we are.
+	closure = g->closure;
+
 	incallback = false;
 	if(m->mcache == nil && g->ncgo > 0) {
 		// For gccgo this case can occur when a cgo or SWIG function
@@ -206,6 +211,8 @@
 	if(incallback)
 		runtime_entersyscall();
 
+	g->closure = closure;
+
 	return v;
 }
 
Index: libobjc/encoding.c
===================================================================
--- a/src/libobjc/encoding.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libobjc/encoding.c	(.../branches/gcc-4_9-branch)
@@ -192,6 +192,8 @@
    ? MAX (MAX (COMPUTED, SPECIFIED), 64)				\
    : MAX (COMPUTED, SPECIFIED));})
 
+#define rs6000_special_adjust_field_align_p(FIELD, COMPUTED) \
+ (TARGET_ALTIVEC && TREE_CODE (TREE_TYPE (FIELD)) == VECTOR_TYPE)
 
 /* Skip a variable name, enclosed in quotes (").  */
 static inline
Index: libobjc/ChangeLog
===================================================================
--- a/src/libobjc/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/libobjc/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,16 @@
+2014-07-28  Ulrich Weigand  <uweigand@de.ibm.com>
+
+	PR libobjc/61920
+	* encoding.c (rs6000_special_adjust_field_align_p): Use definition
+	that matches the 4.9 branch ABI.
+
+2014-07-27  Alan Modra  <amodra@gmail.com>
+	    Matthias Klose  <doko@ubuntu.com>
+
+	PR libobjc/61920
+
+	* encoding.c: Define rs6000_special_adjust_field_align_p.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: libgfortran/m4/in_pack.m4
===================================================================
--- a/src/libgfortran/m4/in_pack.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/in_pack.m4	(.../branches/gcc-4_9-branch)
@@ -79,7 +79,7 @@
     return source->base_addr;
 
   /* Allocate storage for the destination.  */
-  destptr = ('rtype_name` *)xmalloc (ssize * sizeof ('rtype_name`));
+  destptr = xmallocarray (ssize, sizeof ('rtype_name`));
   dest = destptr;
   src = source->base_addr;
   stride0 = stride[0];
Index: libgfortran/m4/pack.m4
===================================================================
--- a/src/libgfortran/m4/pack.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/pack.m4	(.../branches/gcc-4_9-branch)
@@ -168,8 +168,8 @@
 
 	  ret->offset = 0;
 
-	  /* xmalloc allocates a single byte for zero size.  */
-	  ret->base_addr = xmalloc (sizeof ('rtype_name`) * total);
+	  /* xmallocarray allocates a single byte for zero size.  */
+	  ret->base_addr = xmallocarray (total, sizeof ('rtype_name`));
 
 	  if (total == 0)
 	    return;
Index: libgfortran/m4/spread.m4
===================================================================
--- a/src/libgfortran/m4/spread.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/spread.m4	(.../branches/gcc-4_9-branch)
@@ -102,8 +102,8 @@
 	}
       ret->offset = 0;
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (rs * sizeof('rtype_name`));
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (rs, sizeof('rtype_name`));
       if (rs <= 0)
         return;
     }
@@ -245,7 +245,7 @@
 
   if (ret->base_addr == NULL)
     {
-      ret->base_addr = xmalloc (ncopies * sizeof ('rtype_name`));
+      ret->base_addr = xmallocarray (ncopies, sizeof ('rtype_name`));
       ret->offset = 0;
       GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);
     }
Index: libgfortran/m4/transpose.m4
===================================================================
--- a/src/libgfortran/m4/transpose.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/transpose.m4	(.../branches/gcc-4_9-branch)
@@ -61,7 +61,8 @@
       GFC_DIMENSION_SET(ret->dim[1], 0, GFC_DESCRIPTOR_EXTENT(source,0) - 1,
 			GFC_DESCRIPTOR_EXTENT(source, 1));
 
-      ret->base_addr = xmalloc (sizeof ('rtype_name`) * size0 ((array_t *) ret));
+      ret->base_addr = xmallocarray (size0 ((array_t *) ret), 
+                                     sizeof ('rtype_name`));
       ret->offset = 0;
     } else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/m4/iforeach.m4
===================================================================
--- a/src/libgfortran/m4/iforeach.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/iforeach.m4	(.../branches/gcc-4_9-branch)
@@ -30,7 +30,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (rtype_name) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (rtype_name));
     }
   else
     {
@@ -133,7 +133,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (rtype_name) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (rtype_name));
     }
   else
     {
@@ -264,7 +264,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (rtype_name) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (rtype_name));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/m4/eoshift1.m4
===================================================================
--- a/src/libgfortran/m4/eoshift1.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/eoshift1.m4	(.../branches/gcc-4_9-branch)
@@ -106,8 +106,8 @@
 	  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);
 
         }
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (size * arraysize);
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (arraysize, size);
 
     }
   else if (unlikely (compile_options.bounds_check))
Index: libgfortran/m4/eoshift3.m4
===================================================================
--- a/src/libgfortran/m4/eoshift3.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/eoshift3.m4	(.../branches/gcc-4_9-branch)
@@ -90,7 +90,7 @@
     {
       int i;
 
-      ret->base_addr = xmalloc (size * arraysize);
+      ret->base_addr = xmallocarray (arraysize, size);
       ret->offset = 0;
       ret->dtype = array->dtype;
       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)
@@ -108,8 +108,8 @@
 	  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);
 
         }
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (size * arraysize);
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (arraysize, size);
 
     }
   else if (unlikely (compile_options.bounds_check))
Index: libgfortran/m4/shape.m4
===================================================================
--- a/src/libgfortran/m4/shape.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/shape.m4	(.../branches/gcc-4_9-branch)
@@ -50,7 +50,7 @@
     {
       GFC_DIMENSION_SET(ret->dim[0], 0, rank - 1, 1);
       ret->offset = 0;
-      ret->base_addr = xmalloc (sizeof ('rtype_name`) * rank);
+      ret->base_addr = xmallocarray (rank, sizeof ('rtype_name`));
     }
 
   stride = GFC_DESCRIPTOR_STRIDE(ret,0);
Index: libgfortran/m4/cshift1.m4
===================================================================
--- a/src/libgfortran/m4/cshift1.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/cshift1.m4	(.../branches/gcc-4_9-branch)
@@ -81,7 +81,7 @@
     {
       int i;
 
-      ret->base_addr = xmalloc (size * arraysize);
+      ret->base_addr = xmallocarray (arraysize, size);
       ret->offset = 0;
       ret->dtype = array->dtype;
       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)
Index: libgfortran/m4/matmull.m4
===================================================================
--- a/src/libgfortran/m4/matmull.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/matmull.m4	(.../branches/gcc-4_9-branch)
@@ -89,7 +89,7 @@
         }
           
       retarray->base_addr
-	= xmalloc (sizeof ('rtype_name`) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof ('rtype_name`));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/m4/bessel.m4
===================================================================
--- a/src/libgfortran/m4/bessel.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/bessel.m4	(.../branches/gcc-4_9-branch)
@@ -56,7 +56,7 @@
     {
       size_t size = n2 < n1 ? 0 : n2-n1+1; 
       GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);
-      ret->base_addr = xmalloc (sizeof ('rtype_name`) * size);
+      ret->base_addr = xmallocarray (size, sizeof ('rtype_name`));
       ret->offset = 0;
     }
 
@@ -123,7 +123,7 @@
     {
       size_t size = n2 < n1 ? 0 : n2-n1+1; 
       GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);
-      ret->base_addr = xmalloc (sizeof ('rtype_name`) * size);
+      ret->base_addr = xmallocarray (size, sizeof ('rtype_name`));
       ret->offset = 0;
     }
 
@@ -163,7 +163,7 @@
 
   x2rev = GFC_REAL_'rtype_kind`_LITERAL(2.)/x;
 
-  for (i = 2; i <= n1+n2; i++)
+  for (i = 2; i <= n2 - n1; i++)
     {
 #if defined('rtype_name`_INFINITY)
       if (unlikely (last2 == -'rtype_name`_INFINITY))
Index: libgfortran/m4/unpack.m4
===================================================================
--- a/src/libgfortran/m4/unpack.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/unpack.m4	(.../branches/gcc-4_9-branch)
@@ -100,7 +100,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof ('rtype_name`));
+      ret->base_addr = xmallocarray (rs, sizeof ('rtype_name`));
     }
   else
     {
@@ -245,7 +245,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof ('rtype_name`));
+      ret->base_addr = xmallocarray (rs, sizeof ('rtype_name`));
     }
   else
     {
Index: libgfortran/m4/reshape.m4
===================================================================
--- a/src/libgfortran/m4/reshape.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/reshape.m4	(.../branches/gcc-4_9-branch)
@@ -115,11 +115,11 @@
       ret->offset = 0;
 
       if (unlikely (rs < 1))
-        alloc_size = 1;
+        alloc_size = 0;
       else
-        alloc_size = rs * sizeof ('rtype_name`);
+        alloc_size = rs;
 
-      ret->base_addr = xmalloc (alloc_size);
+      ret->base_addr = xmallocarray (alloc_size, sizeof ('rtype_name`));
       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;
     }
 
Index: libgfortran/m4/ifunction_logical.m4
===================================================================
--- a/src/libgfortran/m4/ifunction_logical.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/ifunction_logical.m4	(.../branches/gcc-4_9-branch)
@@ -89,8 +89,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (rtype_name) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -99,7 +98,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (rtype_name));
     }
   else
     {
Index: libgfortran/m4/ifunction.m4
===================================================================
--- a/src/libgfortran/m4/ifunction.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/ifunction.m4	(.../branches/gcc-4_9-branch)
@@ -85,10 +85,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (rtype_name) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (rtype_name));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -260,8 +259,7 @@
 
 	}
 
-      alloc_size = sizeof (rtype_name) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -273,7 +271,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (rtype_name));
 
     }
   else
@@ -417,8 +415,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (rtype_name) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -427,7 +424,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (rtype_name));
     }
   else
     {
Index: libgfortran/m4/matmul.m4
===================================================================
--- a/src/libgfortran/m4/matmul.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/matmul.m4	(.../branches/gcc-4_9-branch)
@@ -125,7 +125,7 @@
         }
 
       retarray->base_addr
-	= xmalloc (sizeof ('rtype_name`) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof ('rtype_name`));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/runtime/in_pack_generic.c
===================================================================
--- a/src/libgfortran/runtime/in_pack_generic.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/runtime/in_pack_generic.c	(.../branches/gcc-4_9-branch)
@@ -180,7 +180,7 @@
     return source->base_addr;
 
    /* Allocate storage for the destination.  */
-  destptr = xmalloc (ssize * size);
+  destptr = xmallocarray (ssize, size);
   dest = (char *)destptr;
   src = source->base_addr;
   stride0 = stride[0] * size;
Index: libgfortran/runtime/memory.c
===================================================================
--- a/src/libgfortran/runtime/memory.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/runtime/memory.c	(.../branches/gcc-4_9-branch)
@@ -25,8 +25,13 @@
 
 #include "libgfortran.h"
 #include <stdlib.h>
+#include <errno.h>
 
+#ifndef SIZE_MAX
+#define SIZE_MAX ((size_t)-1)
+#endif
 
+
 void *
 xmalloc (size_t n)
 {
@@ -44,12 +49,34 @@
 }
 
 
+void *
+xmallocarray (size_t nmemb, size_t size)
+{
+  void *p;
+
+  if (!nmemb || !size)
+    size = nmemb = 1;
+  else if (nmemb > SIZE_MAX / size)
+    {
+      errno = ENOMEM;
+      os_error ("Integer overflow in xmallocarray");
+    }
+
+  p = malloc (nmemb * size);
+
+  if (!p)
+    os_error ("Memory allocation failed in xmallocarray");
+
+  return p;
+}
+
+
 /* calloc wrapper that aborts on error.  */
 
 void *
 xcalloc (size_t nmemb, size_t size)
 {
-  if (nmemb * size == 0)
+  if (!nmemb || !size)
     nmemb = size = 1;
 
   void *p = calloc (nmemb, size);
Index: libgfortran/runtime/convert_char.c
===================================================================
--- a/src/libgfortran/runtime/convert_char.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/runtime/convert_char.c	(.../branches/gcc-4_9-branch)
@@ -44,7 +44,7 @@
   gfc_charlen_type i, l;
 
   l = len > 0 ? len : 0;
-  *dst = xmalloc ((l + 1) * sizeof (gfc_char4_t));
+  *dst = xmallocarray ((l + 1), sizeof (gfc_char4_t));
 
   for (i = 0; i < l; i++)
     (*dst)[i] = src[i];
@@ -60,7 +60,7 @@
   gfc_charlen_type i, l;
 
   l = len > 0 ? len : 0;
-  *dst = xmalloc ((l + 1) * sizeof (unsigned char));
+  *dst = xmalloc (l + 1);
 
   for (i = 0; i < l; i++)
     (*dst)[i] = src[i];
Index: libgfortran/runtime/environ.c
===================================================================
--- a/src/libgfortran/runtime/environ.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/runtime/environ.c	(.../branches/gcc-4_9-branch)
@@ -837,7 +837,7 @@
     }
   else
     {
-      elist = xmalloc (unit_count * sizeof (exception_t));
+      elist = xmallocarray (unit_count, sizeof (exception_t));
       do_count = 0;
       p = val;
       do_parse ();
Index: libgfortran/intrinsics/string_intrinsics_inc.c
===================================================================
--- a/src/libgfortran/intrinsics/string_intrinsics_inc.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/intrinsics/string_intrinsics_inc.c	(.../branches/gcc-4_9-branch)
@@ -164,7 +164,7 @@
   else
     {
       /* Allocate space for result string.  */
-      *dest = xmalloc (*len * sizeof (CHARTYPE));
+      *dest = xmallocarray (*len, sizeof (CHARTYPE));
 
       /* Copy string if necessary.  */
       memcpy (*dest, src, *len * sizeof (CHARTYPE));
@@ -442,7 +442,7 @@
     *dest = &zero_length_string;
   else
     {
-      CHARTYPE *tmp = xmalloc (*rlen * sizeof (CHARTYPE));
+      CHARTYPE *tmp = xmallocarray (*rlen, sizeof (CHARTYPE));
       memcpy (tmp, res, reslen * sizeof (CHARTYPE));
       MEMSET (&tmp[reslen], ' ', *rlen - reslen);
       *dest = tmp;
Index: libgfortran/intrinsics/pack_generic.c
===================================================================
--- a/src/libgfortran/intrinsics/pack_generic.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/intrinsics/pack_generic.c	(.../branches/gcc-4_9-branch)
@@ -152,8 +152,8 @@
 	  GFC_DIMENSION_SET(ret->dim[0], 0, total-1, 1);
 
 	  ret->offset = 0;
-	  /* xmalloc allocates a single byte for zero size.  */
-	  ret->base_addr = xmalloc (size * total);
+	  /* xmallocarray allocates a single byte for zero size.  */
+	  ret->base_addr = xmallocarray (total, size);
 
 	  if (total == 0)
 	    return;      /* In this case, nothing remains to be done.  */
@@ -519,7 +519,7 @@
 
       ret->offset = 0;
 
-      ret->base_addr = xmalloc (size * total);
+      ret->base_addr = xmallocarray (total, size);
 
       if (total == 0)
 	return;
Index: libgfortran/intrinsics/transpose_generic.c
===================================================================
--- a/src/libgfortran/intrinsics/transpose_generic.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/intrinsics/transpose_generic.c	(.../branches/gcc-4_9-branch)
@@ -60,7 +60,7 @@
       GFC_DIMENSION_SET(ret->dim[1], 0, GFC_DESCRIPTOR_EXTENT(source,0) - 1,
 			GFC_DESCRIPTOR_EXTENT(source, 1));
 
-      ret->base_addr = xmalloc (size * size0 ((array_t*)ret));
+      ret->base_addr = xmallocarray (size0 ((array_t*)ret), size);
       ret->offset = 0;
     }
   else if (unlikely (compile_options.bounds_check))
Index: libgfortran/intrinsics/cshift0.c
===================================================================
--- a/src/libgfortran/intrinsics/cshift0.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/intrinsics/cshift0.c	(.../branches/gcc-4_9-branch)
@@ -79,8 +79,8 @@
 	  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);
         }
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (size * arraysize);
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (arraysize, size);
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/intrinsics/spread_generic.c
===================================================================
--- a/src/libgfortran/intrinsics/spread_generic.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/intrinsics/spread_generic.c	(.../branches/gcc-4_9-branch)
@@ -100,7 +100,7 @@
 	  GFC_DIMENSION_SET(ret->dim[n], 0, ub, stride);
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * size);
+      ret->base_addr = xmallocarray (rs, size);
 
       if (rs <= 0)
 	return;
@@ -245,7 +245,7 @@
 
   if (ret->base_addr == NULL)
     {
-      ret->base_addr = xmalloc (ncopies * size);
+      ret->base_addr = xmallocarray (ncopies, size);
       ret->offset = 0;
       GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);
     }
Index: libgfortran/intrinsics/unpack_generic.c
===================================================================
--- a/src/libgfortran/intrinsics/unpack_generic.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/intrinsics/unpack_generic.c	(.../branches/gcc-4_9-branch)
@@ -125,7 +125,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * size);
+      ret->base_addr = xmallocarray (rs, size);
     }
   else
     {
Index: libgfortran/intrinsics/eoshift0.c
===================================================================
--- a/src/libgfortran/intrinsics/eoshift0.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/intrinsics/eoshift0.c	(.../branches/gcc-4_9-branch)
@@ -86,8 +86,8 @@
 
         }
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (size * arraysize);
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (arraysize, size);
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/intrinsics/eoshift2.c
===================================================================
--- a/src/libgfortran/intrinsics/eoshift2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/intrinsics/eoshift2.c	(.../branches/gcc-4_9-branch)
@@ -78,8 +78,8 @@
       ret->offset = 0;
       ret->dtype = array->dtype;
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (size * arraysize);
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (arraysize, size);
 
       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)
         {
Index: libgfortran/intrinsics/reshape_generic.c
===================================================================
--- a/src/libgfortran/intrinsics/reshape_generic.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/intrinsics/reshape_generic.c	(.../branches/gcc-4_9-branch)
@@ -99,11 +99,11 @@
       ret->offset = 0;
 
       if (unlikely (rs < 1))
-	alloc_size = 1;
+	alloc_size = 0; /* xmalloc will allocate 1 byte.  */
       else
-	alloc_size = rs * size;
+	alloc_size = rs;
 
-      ret->base_addr = xmalloc (alloc_size);
+      ret->base_addr = xmallocarray (alloc_size, size);
 
       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;
     }
Index: libgfortran/ChangeLog
===================================================================
--- a/src/libgfortran/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,66 @@
+2014-08-20  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR libgfortran/62188
+	* m4/bessel.m4: Avoid indexing off the end of an array.
+	* generated/bessel_r10.c: Regenerated.
+	* generated/bessel_r16.c: Ditto.
+	* generated/bessel_r4.c: Ditto.
+	* generated/bessel_r8.c: Ditto.
+
+2014-07-31  Janne Blomqvist  <jb@gcc.gnu.org>
+
+	Backport from mainline
+	CVE-2014-5044
+        * libgfortran.h (xmallocarray): New prototype.
+        * runtime/memory.c (xmallocarray): New function.
+        (xcalloc): Check for nonzero separately instead of multiplying.
+        * generated/*.c: Regenerated.
+        * intrinsics/cshift0.c (cshift0): Call xmallocarray instead of
+        xmalloc.
+        * intrinsics/eoshift0.c (eoshift0): Likewise.
+        * intrinsics/eoshift2.c (eoshift2): Likewise.
+        * intrinsics/pack_generic.c (pack_internal): Likewise.
+        (pack_s_internal): Likewise.
+        * intrinsics/reshape_generic.c (reshape_internal): Likewise.
+        * intrinsics/spread_generic.c (spread_internal): Likewise.
+        (spread_internal_scalar): Likewise.
+        * intrinsics/string_intrinsics_inc.c (string_trim): Likewise.
+        (string_minmax): Likewise.
+        * intrinsics/transpose_generic.c (transpose_internal): Likewise.
+        * intrinsics/unpack_generic.c (unpack_internal): Likewise.
+        * io/list_read.c (nml_touch_nodes): Don't cast xmalloc return value.
+        * io/transfer.c (st_set_nml_var): Call xmallocarray instead of
+        xmalloc.
+        * io/unit.c (get_internal_unit): Likewise.
+        (filename_from_unit): Don't cast xmalloc return value.
+        * io/write.c (nml_write_obj): Likewise, formatting.
+        * m4/bessel.m4 (bessel_jn_r'rtype_kind`): Call xmallocarray
+        instead of xmalloc.
+        (besse_yn_r'rtype_kind`): Likewise.
+        * m4/cshift1.m4 (cshift1): Likewise.
+        * m4/eoshift1.m4 (eoshift1): Likewise.
+        * m4/eoshift3.m4 (eoshift3): Likewise.
+        * m4/iforeach.m4: Likewise.
+        * m4/ifunction.m4: Likewise.
+        * m4/ifunction_logical.m4 (name`'rtype_qual`_'atype_code):
+        Likewise.
+        * m4/in_pack.m4 (internal_pack_'rtype_ccode`): Likewise.
+        * m4/matmul.m4 (matmul_'rtype_code`): Likewise.
+        * m4/matmull.m4 (matmul_'rtype_code`): Likewise.
+        * m4/pack.m4 (pack_'rtype_code`): Likewise.
+        * m4/reshape.m4 (reshape_'rtype_ccode`): Likewise.
+        * m4/shape.m4 (shape_'rtype_kind`): Likewise.
+        * m4/spread.m4 (spread_'rtype_code`): Likewise.
+        (spread_scalar_'rtype_code`): Likewise.
+        * m4/transpose.m4 (transpose_'rtype_code`): Likewise.
+        * m4/unpack.m4 (unpack0_'rtype_code`): Likewise.
+        (unpack1_'rtype_code`): Likewise.
+        * runtime/convert_char.c (convert_char1_to_char4): Likewise.
+        (convert_char4_to_char1): Simplify.
+        * runtime/environ.c (init_unformatted): Call xmallocarray instead
+        of xmalloc.
+        * runtime/in_pack_generic.c (internal_pack): Likewise.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: libgfortran/generated/spread_r10.c
===================================================================
--- a/src/libgfortran/generated/spread_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/spread_r10.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,8 @@
 	}
       ret->offset = 0;
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (rs * sizeof(GFC_REAL_10));
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (rs, sizeof(GFC_REAL_10));
       if (rs <= 0)
         return;
     }
@@ -244,7 +244,7 @@
 
   if (ret->base_addr == NULL)
     {
-      ret->base_addr = xmalloc (ncopies * sizeof (GFC_REAL_10));
+      ret->base_addr = xmallocarray (ncopies, sizeof (GFC_REAL_10));
       ret->offset = 0;
       GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);
     }
Index: libgfortran/generated/maxloc1_4_r8.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_4_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_4_r8.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/norm2_r4.c
===================================================================
--- a/src/libgfortran/generated/norm2_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/norm2_r4.c	(.../branches/gcc-4_9-branch)
@@ -101,10 +101,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
Index: libgfortran/generated/parity_l2.c
===================================================================
--- a/src/libgfortran/generated/parity_l2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/parity_l2.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_LOGICAL_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_LOGICAL_2));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
Index: libgfortran/generated/eoshift3_4.c
===================================================================
--- a/src/libgfortran/generated/eoshift3_4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/eoshift3_4.c	(.../branches/gcc-4_9-branch)
@@ -89,7 +89,7 @@
     {
       int i;
 
-      ret->base_addr = xmalloc (size * arraysize);
+      ret->base_addr = xmallocarray (arraysize, size);
       ret->offset = 0;
       ret->dtype = array->dtype;
       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)
@@ -107,8 +107,8 @@
 	  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);
 
         }
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (size * arraysize);
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (arraysize, size);
 
     }
   else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/transpose_c8.c
===================================================================
--- a/src/libgfortran/generated/transpose_c8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/transpose_c8.c	(.../branches/gcc-4_9-branch)
@@ -60,7 +60,8 @@
       GFC_DIMENSION_SET(ret->dim[1], 0, GFC_DESCRIPTOR_EXTENT(source,0) - 1,
 			GFC_DESCRIPTOR_EXTENT(source, 1));
 
-      ret->base_addr = xmalloc (sizeof (GFC_COMPLEX_8) * size0 ((array_t *) ret));
+      ret->base_addr = xmallocarray (size0 ((array_t *) ret), 
+                                     sizeof (GFC_COMPLEX_8));
       ret->offset = 0;
     } else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/eoshift1_8.c
===================================================================
--- a/src/libgfortran/generated/eoshift1_8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/eoshift1_8.c	(.../branches/gcc-4_9-branch)
@@ -105,8 +105,8 @@
 	  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);
 
         }
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (size * arraysize);
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (arraysize, size);
 
     }
   else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/reshape_r16.c
===================================================================
--- a/src/libgfortran/generated/reshape_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/reshape_r16.c	(.../branches/gcc-4_9-branch)
@@ -111,11 +111,11 @@
       ret->offset = 0;
 
       if (unlikely (rs < 1))
-        alloc_size = 1;
+        alloc_size = 0;
       else
-        alloc_size = rs * sizeof (GFC_REAL_16);
+        alloc_size = rs;
 
-      ret->base_addr = xmalloc (alloc_size);
+      ret->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_16));
       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;
     }
 
Index: libgfortran/generated/bessel_r4.c
===================================================================
--- a/src/libgfortran/generated/bessel_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/bessel_r4.c	(.../branches/gcc-4_9-branch)
@@ -55,7 +55,7 @@
     {
       size_t size = n2 < n1 ? 0 : n2-n1+1; 
       GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);
-      ret->base_addr = xmalloc (sizeof (GFC_REAL_4) * size);
+      ret->base_addr = xmallocarray (size, sizeof (GFC_REAL_4));
       ret->offset = 0;
     }
 
@@ -122,7 +122,7 @@
     {
       size_t size = n2 < n1 ? 0 : n2-n1+1; 
       GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);
-      ret->base_addr = xmalloc (sizeof (GFC_REAL_4) * size);
+      ret->base_addr = xmallocarray (size, sizeof (GFC_REAL_4));
       ret->offset = 0;
     }
 
@@ -162,7 +162,7 @@
 
   x2rev = GFC_REAL_4_LITERAL(2.)/x;
 
-  for (i = 2; i <= n1+n2; i++)
+  for (i = 2; i <= n2 - n1; i++)
     {
 #if defined(GFC_REAL_4_INFINITY)
       if (unlikely (last2 == -GFC_REAL_4_INFINITY))
Index: libgfortran/generated/any_l2.c
===================================================================
--- a/src/libgfortran/generated/any_l2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/any_l2.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_LOGICAL_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -111,7 +110,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_LOGICAL_2));
     }
   else
     {
Index: libgfortran/generated/product_r4.c
===================================================================
--- a/src/libgfortran/generated/product_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/product_r4.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_4));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_4));
     }
   else
     {
Index: libgfortran/generated/iany_i1.c
===================================================================
--- a/src/libgfortran/generated/iany_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/iany_i1.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
     }
   else
     {
Index: libgfortran/generated/parity_l16.c
===================================================================
--- a/src/libgfortran/generated/parity_l16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/parity_l16.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_LOGICAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_LOGICAL_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
Index: libgfortran/generated/in_pack_r4.c
===================================================================
--- a/src/libgfortran/generated/in_pack_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/in_pack_r4.c	(.../branches/gcc-4_9-branch)
@@ -76,7 +76,7 @@
     return source->base_addr;
 
   /* Allocate storage for the destination.  */
-  destptr = (GFC_REAL_4 *)xmalloc (ssize * sizeof (GFC_REAL_4));
+  destptr = xmallocarray (ssize, sizeof (GFC_REAL_4));
   dest = destptr;
   src = source->base_addr;
   stride0 = stride[0];
Index: libgfortran/generated/product_i2.c
===================================================================
--- a/src/libgfortran/generated/product_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/product_i2.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
     }
   else
     {
Index: libgfortran/generated/iparity_i4.c
===================================================================
--- a/src/libgfortran/generated/iparity_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/iparity_i4.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/minloc0_4_i1.c
===================================================================
--- a/src/libgfortran/generated/minloc0_4_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_4_i1.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/reshape_c4.c
===================================================================
--- a/src/libgfortran/generated/reshape_c4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/reshape_c4.c	(.../branches/gcc-4_9-branch)
@@ -111,11 +111,11 @@
       ret->offset = 0;
 
       if (unlikely (rs < 1))
-        alloc_size = 1;
+        alloc_size = 0;
       else
-        alloc_size = rs * sizeof (GFC_COMPLEX_4);
+        alloc_size = rs;
 
-      ret->base_addr = xmalloc (alloc_size);
+      ret->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_4));
       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;
     }
 
Index: libgfortran/generated/maxloc0_4_r16.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_4_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_4_r16.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/iall_i8.c
===================================================================
--- a/src/libgfortran/generated/iall_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/iall_i8.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/maxloc1_8_r16.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_8_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_8_r16.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/sum_r16.c
===================================================================
--- a/src/libgfortran/generated/sum_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/sum_r16.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_16));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_16));
     }
   else
     {
Index: libgfortran/generated/sum_i1.c
===================================================================
--- a/src/libgfortran/generated/sum_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/sum_i1.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
     }
   else
     {
Index: libgfortran/generated/in_pack_i2.c
===================================================================
--- a/src/libgfortran/generated/in_pack_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/in_pack_i2.c	(.../branches/gcc-4_9-branch)
@@ -76,7 +76,7 @@
     return source->base_addr;
 
   /* Allocate storage for the destination.  */
-  destptr = (GFC_INTEGER_2 *)xmalloc (ssize * sizeof (GFC_INTEGER_2));
+  destptr = xmallocarray (ssize, sizeof (GFC_INTEGER_2));
   dest = destptr;
   src = source->base_addr;
   stride0 = stride[0];
Index: libgfortran/generated/transpose_r10.c
===================================================================
--- a/src/libgfortran/generated/transpose_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/transpose_r10.c	(.../branches/gcc-4_9-branch)
@@ -60,7 +60,8 @@
       GFC_DIMENSION_SET(ret->dim[1], 0, GFC_DESCRIPTOR_EXTENT(source,0) - 1,
 			GFC_DESCRIPTOR_EXTENT(source, 1));
 
-      ret->base_addr = xmalloc (sizeof (GFC_REAL_10) * size0 ((array_t *) ret));
+      ret->base_addr = xmallocarray (size0 ((array_t *) ret), 
+                                     sizeof (GFC_REAL_10));
       ret->offset = 0;
     } else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/maxloc1_16_r16.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_16_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_16_r16.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/maxloc1_16_i4.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_16_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_16_i4.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/spread_i1.c
===================================================================
--- a/src/libgfortran/generated/spread_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/spread_i1.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,8 @@
 	}
       ret->offset = 0;
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (rs * sizeof(GFC_INTEGER_1));
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (rs, sizeof(GFC_INTEGER_1));
       if (rs <= 0)
         return;
     }
@@ -244,7 +244,7 @@
 
   if (ret->base_addr == NULL)
     {
-      ret->base_addr = xmalloc (ncopies * sizeof (GFC_INTEGER_1));
+      ret->base_addr = xmallocarray (ncopies, sizeof (GFC_INTEGER_1));
       ret->offset = 0;
       GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);
     }
Index: libgfortran/generated/maxloc0_16_i8.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_16_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_16_i8.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/maxval_r16.c
===================================================================
--- a/src/libgfortran/generated/maxval_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxval_r16.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_16));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_16));
     }
   else
     {
Index: libgfortran/generated/product_c10.c
===================================================================
--- a/src/libgfortran/generated/product_c10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/product_c10.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_10));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_COMPLEX_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_10));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_10));
     }
   else
     {
Index: libgfortran/generated/minloc1_8_i4.c
===================================================================
--- a/src/libgfortran/generated/minloc1_8_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_8_i4.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/minloc0_16_i16.c
===================================================================
--- a/src/libgfortran/generated/minloc0_16_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_16_i16.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/matmul_r16.c
===================================================================
--- a/src/libgfortran/generated/matmul_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_r16.c	(.../branches/gcc-4_9-branch)
@@ -124,7 +124,7 @@
         }
 
       retarray->base_addr
-	= xmalloc (sizeof (GFC_REAL_16) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_REAL_16));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/minloc0_4_r4.c
===================================================================
--- a/src/libgfortran/generated/minloc0_4_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_4_r4.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/iany_i2.c
===================================================================
--- a/src/libgfortran/generated/iany_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/iany_i2.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
     }
   else
     {
Index: libgfortran/generated/sum_r4.c
===================================================================
--- a/src/libgfortran/generated/sum_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/sum_r4.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_4));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_4));
     }
   else
     {
Index: libgfortran/generated/unpack_c8.c
===================================================================
--- a/src/libgfortran/generated/unpack_c8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/unpack_c8.c	(.../branches/gcc-4_9-branch)
@@ -99,7 +99,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_COMPLEX_8));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_COMPLEX_8));
     }
   else
     {
@@ -244,7 +244,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_COMPLEX_8));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_COMPLEX_8));
     }
   else
     {
Index: libgfortran/generated/in_pack_c16.c
===================================================================
--- a/src/libgfortran/generated/in_pack_c16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/in_pack_c16.c	(.../branches/gcc-4_9-branch)
@@ -76,7 +76,7 @@
     return source->base_addr;
 
   /* Allocate storage for the destination.  */
-  destptr = (GFC_COMPLEX_16 *)xmalloc (ssize * sizeof (GFC_COMPLEX_16));
+  destptr = xmallocarray (ssize, sizeof (GFC_COMPLEX_16));
   dest = destptr;
   src = source->base_addr;
   stride0 = stride[0];
Index: libgfortran/generated/minloc0_4_i2.c
===================================================================
--- a/src/libgfortran/generated/minloc0_4_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_4_i2.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/spread_c10.c
===================================================================
--- a/src/libgfortran/generated/spread_c10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/spread_c10.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,8 @@
 	}
       ret->offset = 0;
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (rs * sizeof(GFC_COMPLEX_10));
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (rs, sizeof(GFC_COMPLEX_10));
       if (rs <= 0)
         return;
     }
@@ -244,7 +244,7 @@
 
   if (ret->base_addr == NULL)
     {
-      ret->base_addr = xmalloc (ncopies * sizeof (GFC_COMPLEX_10));
+      ret->base_addr = xmallocarray (ncopies, sizeof (GFC_COMPLEX_10));
       ret->offset = 0;
       GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);
     }
Index: libgfortran/generated/maxloc0_8_i1.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_8_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_8_i1.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/spread_r4.c
===================================================================
--- a/src/libgfortran/generated/spread_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/spread_r4.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,8 @@
 	}
       ret->offset = 0;
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (rs * sizeof(GFC_REAL_4));
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (rs, sizeof(GFC_REAL_4));
       if (rs <= 0)
         return;
     }
@@ -244,7 +244,7 @@
 
   if (ret->base_addr == NULL)
     {
-      ret->base_addr = xmalloc (ncopies * sizeof (GFC_REAL_4));
+      ret->base_addr = xmallocarray (ncopies, sizeof (GFC_REAL_4));
       ret->offset = 0;
       GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);
     }
Index: libgfortran/generated/minloc0_8_i8.c
===================================================================
--- a/src/libgfortran/generated/minloc0_8_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_8_i8.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/matmul_c8.c
===================================================================
--- a/src/libgfortran/generated/matmul_c8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_c8.c	(.../branches/gcc-4_9-branch)
@@ -124,7 +124,7 @@
         }
 
       retarray->base_addr
-	= xmalloc (sizeof (GFC_COMPLEX_8) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_8));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/minloc1_16_r10.c
===================================================================
--- a/src/libgfortran/generated/minloc1_16_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_16_r10.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/sum_i2.c
===================================================================
--- a/src/libgfortran/generated/sum_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/sum_i2.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
     }
   else
     {
Index: libgfortran/generated/iparity_i16.c
===================================================================
--- a/src/libgfortran/generated/iparity_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/iparity_i16.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/minloc0_16_i1.c
===================================================================
--- a/src/libgfortran/generated/minloc0_16_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_16_i1.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/reshape_c16.c
===================================================================
--- a/src/libgfortran/generated/reshape_c16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/reshape_c16.c	(.../branches/gcc-4_9-branch)
@@ -111,11 +111,11 @@
       ret->offset = 0;
 
       if (unlikely (rs < 1))
-        alloc_size = 1;
+        alloc_size = 0;
       else
-        alloc_size = rs * sizeof (GFC_COMPLEX_16);
+        alloc_size = rs;
 
-      ret->base_addr = xmalloc (alloc_size);
+      ret->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_16));
       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;
     }
 
Index: libgfortran/generated/pack_c4.c
===================================================================
--- a/src/libgfortran/generated/pack_c4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/pack_c4.c	(.../branches/gcc-4_9-branch)
@@ -167,8 +167,8 @@
 
 	  ret->offset = 0;
 
-	  /* xmalloc allocates a single byte for zero size.  */
-	  ret->base_addr = xmalloc (sizeof (GFC_COMPLEX_4) * total);
+	  /* xmallocarray allocates a single byte for zero size.  */
+	  ret->base_addr = xmallocarray (total, sizeof (GFC_COMPLEX_4));
 
 	  if (total == 0)
 	    return;
Index: libgfortran/generated/parity_l4.c
===================================================================
--- a/src/libgfortran/generated/parity_l4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/parity_l4.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_LOGICAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_LOGICAL_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
Index: libgfortran/generated/spread_i2.c
===================================================================
--- a/src/libgfortran/generated/spread_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/spread_i2.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,8 @@
 	}
       ret->offset = 0;
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (rs * sizeof(GFC_INTEGER_2));
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (rs, sizeof(GFC_INTEGER_2));
       if (rs <= 0)
         return;
     }
@@ -244,7 +244,7 @@
 
   if (ret->base_addr == NULL)
     {
-      ret->base_addr = xmalloc (ncopies * sizeof (GFC_INTEGER_2));
+      ret->base_addr = xmallocarray (ncopies, sizeof (GFC_INTEGER_2));
       ret->offset = 0;
       GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);
     }
Index: libgfortran/generated/any_l4.c
===================================================================
--- a/src/libgfortran/generated/any_l4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/any_l4.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_LOGICAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -111,7 +110,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_LOGICAL_4));
     }
   else
     {
Index: libgfortran/generated/maxloc1_4_i8.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_4_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_4_i8.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/maxloc0_8_r4.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_8_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_8_r4.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/maxloc1_4_i16.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_4_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_4_i16.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/minloc0_4_r10.c
===================================================================
--- a/src/libgfortran/generated/minloc0_4_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_4_r10.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/minloc0_8_i16.c
===================================================================
--- a/src/libgfortran/generated/minloc0_8_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_8_i16.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/minloc1_8_r10.c
===================================================================
--- a/src/libgfortran/generated/minloc1_8_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_8_r10.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/minloc0_16_r4.c
===================================================================
--- a/src/libgfortran/generated/minloc0_16_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_16_r4.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/product_i4.c
===================================================================
--- a/src/libgfortran/generated/product_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/product_i4.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/sum_c16.c
===================================================================
--- a/src/libgfortran/generated/sum_c16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/sum_c16.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_COMPLEX_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_16));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_16));
     }
   else
     {
Index: libgfortran/generated/transpose_c10.c
===================================================================
--- a/src/libgfortran/generated/transpose_c10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/transpose_c10.c	(.../branches/gcc-4_9-branch)
@@ -60,7 +60,8 @@
       GFC_DIMENSION_SET(ret->dim[1], 0, GFC_DESCRIPTOR_EXTENT(source,0) - 1,
 			GFC_DESCRIPTOR_EXTENT(source, 1));
 
-      ret->base_addr = xmalloc (sizeof (GFC_COMPLEX_10) * size0 ((array_t *) ret));
+      ret->base_addr = xmallocarray (size0 ((array_t *) ret), 
+                                     sizeof (GFC_COMPLEX_10));
       ret->offset = 0;
     } else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/maxloc1_16_r8.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_16_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_16_r8.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/transpose_r4.c
===================================================================
--- a/src/libgfortran/generated/transpose_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/transpose_r4.c	(.../branches/gcc-4_9-branch)
@@ -60,7 +60,8 @@
       GFC_DIMENSION_SET(ret->dim[1], 0, GFC_DESCRIPTOR_EXTENT(source,0) - 1,
 			GFC_DESCRIPTOR_EXTENT(source, 1));
 
-      ret->base_addr = xmalloc (sizeof (GFC_REAL_4) * size0 ((array_t *) ret));
+      ret->base_addr = xmallocarray (size0 ((array_t *) ret), 
+                                     sizeof (GFC_REAL_4));
       ret->offset = 0;
     } else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/cshift1_4.c
===================================================================
--- a/src/libgfortran/generated/cshift1_4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/cshift1_4.c	(.../branches/gcc-4_9-branch)
@@ -80,7 +80,7 @@
     {
       int i;
 
-      ret->base_addr = xmalloc (size * arraysize);
+      ret->base_addr = xmallocarray (arraysize, size);
       ret->offset = 0;
       ret->dtype = array->dtype;
       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)
Index: libgfortran/generated/maxloc0_8_i2.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_8_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_8_i2.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/count_8_l.c
===================================================================
--- a/src/libgfortran/generated/count_8_l.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/count_8_l.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -111,7 +110,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/in_pack_i4.c
===================================================================
--- a/src/libgfortran/generated/in_pack_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/in_pack_i4.c	(.../branches/gcc-4_9-branch)
@@ -76,7 +76,7 @@
     return source->base_addr;
 
   /* Allocate storage for the destination.  */
-  destptr = (GFC_INTEGER_4 *)xmalloc (ssize * sizeof (GFC_INTEGER_4));
+  destptr = xmallocarray (ssize, sizeof (GFC_INTEGER_4));
   dest = destptr;
   src = source->base_addr;
   stride0 = stride[0];
Index: libgfortran/generated/minloc0_16_i2.c
===================================================================
--- a/src/libgfortran/generated/minloc0_16_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_16_i2.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/minloc1_8_r8.c
===================================================================
--- a/src/libgfortran/generated/minloc1_8_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_8_r8.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/matmul_c16.c
===================================================================
--- a/src/libgfortran/generated/matmul_c16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_c16.c	(.../branches/gcc-4_9-branch)
@@ -124,7 +124,7 @@
         }
 
       retarray->base_addr
-	= xmalloc (sizeof (GFC_COMPLEX_16) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_16));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/minval_i1.c
===================================================================
--- a/src/libgfortran/generated/minval_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minval_i1.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
     }
   else
     {
Index: libgfortran/generated/shape_i16.c
===================================================================
--- a/src/libgfortran/generated/shape_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/shape_i16.c	(.../branches/gcc-4_9-branch)
@@ -49,7 +49,7 @@
     {
       GFC_DIMENSION_SET(ret->dim[0], 0, rank - 1, 1);
       ret->offset = 0;
-      ret->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      ret->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
 
   stride = GFC_DESCRIPTOR_STRIDE(ret,0);
Index: libgfortran/generated/iany_i4.c
===================================================================
--- a/src/libgfortran/generated/iany_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/iany_i4.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/minloc0_16_r16.c
===================================================================
--- a/src/libgfortran/generated/minloc0_16_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_16_r16.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/product_i16.c
===================================================================
--- a/src/libgfortran/generated/product_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/product_i16.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/unpack_i1.c
===================================================================
--- a/src/libgfortran/generated/unpack_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/unpack_i1.c	(.../branches/gcc-4_9-branch)
@@ -99,7 +99,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_INTEGER_1));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_INTEGER_1));
     }
   else
     {
@@ -244,7 +244,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_INTEGER_1));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_INTEGER_1));
     }
   else
     {
Index: libgfortran/generated/minloc0_4_i4.c
===================================================================
--- a/src/libgfortran/generated/minloc0_4_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_4_i4.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/matmul_i1.c
===================================================================
--- a/src/libgfortran/generated/matmul_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_i1.c	(.../branches/gcc-4_9-branch)
@@ -124,7 +124,7 @@
         }
 
       retarray->base_addr
-	= xmalloc (sizeof (GFC_INTEGER_1) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_1));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/minval_r4.c
===================================================================
--- a/src/libgfortran/generated/minval_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minval_r4.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_4));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_4));
     }
   else
     {
Index: libgfortran/generated/spread_i16.c
===================================================================
--- a/src/libgfortran/generated/spread_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/spread_i16.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,8 @@
 	}
       ret->offset = 0;
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (rs * sizeof(GFC_INTEGER_16));
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (rs, sizeof(GFC_INTEGER_16));
       if (rs <= 0)
         return;
     }
@@ -244,7 +244,7 @@
 
   if (ret->base_addr == NULL)
     {
-      ret->base_addr = xmalloc (ncopies * sizeof (GFC_INTEGER_16));
+      ret->base_addr = xmallocarray (ncopies, sizeof (GFC_INTEGER_16));
       ret->offset = 0;
       GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);
     }
Index: libgfortran/generated/sum_i4.c
===================================================================
--- a/src/libgfortran/generated/sum_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/sum_i4.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/unpack_r10.c
===================================================================
--- a/src/libgfortran/generated/unpack_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/unpack_r10.c	(.../branches/gcc-4_9-branch)
@@ -99,7 +99,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_REAL_10));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_REAL_10));
     }
   else
     {
@@ -244,7 +244,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_REAL_10));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_REAL_10));
     }
   else
     {
Index: libgfortran/generated/bessel_r16.c
===================================================================
--- a/src/libgfortran/generated/bessel_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/bessel_r16.c	(.../branches/gcc-4_9-branch)
@@ -59,7 +59,7 @@
     {
       size_t size = n2 < n1 ? 0 : n2-n1+1; 
       GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);
-      ret->base_addr = xmalloc (sizeof (GFC_REAL_16) * size);
+      ret->base_addr = xmallocarray (size, sizeof (GFC_REAL_16));
       ret->offset = 0;
     }
 
@@ -126,7 +126,7 @@
     {
       size_t size = n2 < n1 ? 0 : n2-n1+1; 
       GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);
-      ret->base_addr = xmalloc (sizeof (GFC_REAL_16) * size);
+      ret->base_addr = xmallocarray (size, sizeof (GFC_REAL_16));
       ret->offset = 0;
     }
 
@@ -166,7 +166,7 @@
 
   x2rev = GFC_REAL_16_LITERAL(2.)/x;
 
-  for (i = 2; i <= n1+n2; i++)
+  for (i = 2; i <= n2 - n1; i++)
     {
 #if defined(GFC_REAL_16_INFINITY)
       if (unlikely (last2 == -GFC_REAL_16_INFINITY))
Index: libgfortran/generated/norm2_r8.c
===================================================================
--- a/src/libgfortran/generated/norm2_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/norm2_r8.c	(.../branches/gcc-4_9-branch)
@@ -101,10 +101,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
Index: libgfortran/generated/spread_i4.c
===================================================================
--- a/src/libgfortran/generated/spread_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/spread_i4.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,8 @@
 	}
       ret->offset = 0;
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (rs * sizeof(GFC_INTEGER_4));
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (rs, sizeof(GFC_INTEGER_4));
       if (rs <= 0)
         return;
     }
@@ -244,7 +244,7 @@
 
   if (ret->base_addr == NULL)
     {
-      ret->base_addr = xmalloc (ncopies * sizeof (GFC_INTEGER_4));
+      ret->base_addr = xmallocarray (ncopies, sizeof (GFC_INTEGER_4));
       ret->offset = 0;
       GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);
     }
Index: libgfortran/generated/eoshift3_8.c
===================================================================
--- a/src/libgfortran/generated/eoshift3_8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/eoshift3_8.c	(.../branches/gcc-4_9-branch)
@@ -89,7 +89,7 @@
     {
       int i;
 
-      ret->base_addr = xmalloc (size * arraysize);
+      ret->base_addr = xmallocarray (arraysize, size);
       ret->offset = 0;
       ret->dtype = array->dtype;
       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)
@@ -107,8 +107,8 @@
 	  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);
 
         }
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (size * arraysize);
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (arraysize, size);
 
     }
   else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/minloc1_4_i1.c
===================================================================
--- a/src/libgfortran/generated/minloc1_4_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_4_i1.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/minval_i2.c
===================================================================
--- a/src/libgfortran/generated/minval_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minval_i2.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
     }
   else
     {
Index: libgfortran/generated/bessel_r8.c
===================================================================
--- a/src/libgfortran/generated/bessel_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/bessel_r8.c	(.../branches/gcc-4_9-branch)
@@ -55,7 +55,7 @@
     {
       size_t size = n2 < n1 ? 0 : n2-n1+1; 
       GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);
-      ret->base_addr = xmalloc (sizeof (GFC_REAL_8) * size);
+      ret->base_addr = xmallocarray (size, sizeof (GFC_REAL_8));
       ret->offset = 0;
     }
 
@@ -122,7 +122,7 @@
     {
       size_t size = n2 < n1 ? 0 : n2-n1+1; 
       GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);
-      ret->base_addr = xmalloc (sizeof (GFC_REAL_8) * size);
+      ret->base_addr = xmallocarray (size, sizeof (GFC_REAL_8));
       ret->offset = 0;
     }
 
@@ -162,7 +162,7 @@
 
   x2rev = GFC_REAL_8_LITERAL(2.)/x;
 
-  for (i = 2; i <= n1+n2; i++)
+  for (i = 2; i <= n2 - n1; i++)
     {
 #if defined(GFC_REAL_8_INFINITY)
       if (unlikely (last2 == -GFC_REAL_8_INFINITY))
Index: libgfortran/generated/unpack_r4.c
===================================================================
--- a/src/libgfortran/generated/unpack_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/unpack_r4.c	(.../branches/gcc-4_9-branch)
@@ -99,7 +99,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_REAL_4));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_REAL_4));
     }
   else
     {
@@ -244,7 +244,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_REAL_4));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_REAL_4));
     }
   else
     {
Index: libgfortran/generated/product_r8.c
===================================================================
--- a/src/libgfortran/generated/product_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/product_r8.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_8));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_8));
     }
   else
     {
Index: libgfortran/generated/matmul_r4.c
===================================================================
--- a/src/libgfortran/generated/matmul_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_r4.c	(.../branches/gcc-4_9-branch)
@@ -124,7 +124,7 @@
         }
 
       retarray->base_addr
-	= xmalloc (sizeof (GFC_REAL_4) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_REAL_4));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/unpack_i2.c
===================================================================
--- a/src/libgfortran/generated/unpack_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/unpack_i2.c	(.../branches/gcc-4_9-branch)
@@ -99,7 +99,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_INTEGER_2));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_INTEGER_2));
     }
   else
     {
@@ -244,7 +244,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_INTEGER_2));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_INTEGER_2));
     }
   else
     {
Index: libgfortran/generated/in_pack_r8.c
===================================================================
--- a/src/libgfortran/generated/in_pack_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/in_pack_r8.c	(.../branches/gcc-4_9-branch)
@@ -76,7 +76,7 @@
     return source->base_addr;
 
   /* Allocate storage for the destination.  */
-  destptr = (GFC_REAL_8 *)xmalloc (ssize * sizeof (GFC_REAL_8));
+  destptr = xmallocarray (ssize, sizeof (GFC_REAL_8));
   dest = destptr;
   src = source->base_addr;
   stride0 = stride[0];
Index: libgfortran/generated/maxloc1_4_r16.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_4_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_4_r16.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/minloc0_8_r16.c
===================================================================
--- a/src/libgfortran/generated/minloc0_8_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_8_r16.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/reshape_c8.c
===================================================================
--- a/src/libgfortran/generated/reshape_c8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/reshape_c8.c	(.../branches/gcc-4_9-branch)
@@ -111,11 +111,11 @@
       ret->offset = 0;
 
       if (unlikely (rs < 1))
-        alloc_size = 1;
+        alloc_size = 0;
       else
-        alloc_size = rs * sizeof (GFC_COMPLEX_8);
+        alloc_size = rs;
 
-      ret->base_addr = xmalloc (alloc_size);
+      ret->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_8));
       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;
     }
 
Index: libgfortran/generated/iparity_i8.c
===================================================================
--- a/src/libgfortran/generated/iparity_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/iparity_i8.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/count_1_l.c
===================================================================
--- a/src/libgfortran/generated/count_1_l.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/count_1_l.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -111,7 +110,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
     }
   else
     {
Index: libgfortran/generated/maxloc0_8_i4.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_8_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_8_i4.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/matmul_i2.c
===================================================================
--- a/src/libgfortran/generated/matmul_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_i2.c	(.../branches/gcc-4_9-branch)
@@ -124,7 +124,7 @@
         }
 
       retarray->base_addr
-	= xmalloc (sizeof (GFC_INTEGER_2) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_2));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/minloc1_4_r4.c
===================================================================
--- a/src/libgfortran/generated/minloc1_4_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_4_r4.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/transpose_i16.c
===================================================================
--- a/src/libgfortran/generated/transpose_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/transpose_i16.c	(.../branches/gcc-4_9-branch)
@@ -60,7 +60,8 @@
       GFC_DIMENSION_SET(ret->dim[1], 0, GFC_DESCRIPTOR_EXTENT(source,0) - 1,
 			GFC_DESCRIPTOR_EXTENT(source, 1));
 
-      ret->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * size0 ((array_t *) ret));
+      ret->base_addr = xmallocarray (size0 ((array_t *) ret), 
+                                     sizeof (GFC_INTEGER_16));
       ret->offset = 0;
     } else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/minloc0_16_i4.c
===================================================================
--- a/src/libgfortran/generated/minloc0_16_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_16_i4.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/transpose_i4.c
===================================================================
--- a/src/libgfortran/generated/transpose_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/transpose_i4.c	(.../branches/gcc-4_9-branch)
@@ -60,7 +60,8 @@
       GFC_DIMENSION_SET(ret->dim[1], 0, GFC_DESCRIPTOR_EXTENT(source,0) - 1,
 			GFC_DESCRIPTOR_EXTENT(source, 1));
 
-      ret->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * size0 ((array_t *) ret));
+      ret->base_addr = xmallocarray (size0 ((array_t *) ret), 
+                                     sizeof (GFC_INTEGER_4));
       ret->offset = 0;
     } else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/maxloc1_16_i8.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_16_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_16_i8.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/minloc1_4_i2.c
===================================================================
--- a/src/libgfortran/generated/minloc1_4_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_4_i2.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/matmul_l16.c
===================================================================
--- a/src/libgfortran/generated/matmul_l16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_l16.c	(.../branches/gcc-4_9-branch)
@@ -88,7 +88,7 @@
         }
           
       retarray->base_addr
-	= xmalloc (sizeof (GFC_LOGICAL_16) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_LOGICAL_16));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/maxloc1_8_i1.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_8_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_8_i1.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/minloc1_8_i8.c
===================================================================
--- a/src/libgfortran/generated/minloc1_8_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_8_i8.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/minloc0_4_r8.c
===================================================================
--- a/src/libgfortran/generated/minloc0_4_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_4_r8.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/product_r16.c
===================================================================
--- a/src/libgfortran/generated/product_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/product_r16.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_16));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_16));
     }
   else
     {
Index: libgfortran/generated/sum_r8.c
===================================================================
--- a/src/libgfortran/generated/sum_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/sum_r8.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_8));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_8));
     }
   else
     {
Index: libgfortran/generated/norm2_r10.c
===================================================================
--- a/src/libgfortran/generated/norm2_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/norm2_r10.c	(.../branches/gcc-4_9-branch)
@@ -101,10 +101,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_10));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
Index: libgfortran/generated/unpack_c10.c
===================================================================
--- a/src/libgfortran/generated/unpack_c10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/unpack_c10.c	(.../branches/gcc-4_9-branch)
@@ -99,7 +99,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_COMPLEX_10));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_COMPLEX_10));
     }
   else
     {
@@ -244,7 +244,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_COMPLEX_10));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_COMPLEX_10));
     }
   else
     {
Index: libgfortran/generated/spread_r8.c
===================================================================
--- a/src/libgfortran/generated/spread_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/spread_r8.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,8 @@
 	}
       ret->offset = 0;
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (rs * sizeof(GFC_REAL_8));
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (rs, sizeof(GFC_REAL_8));
       if (rs <= 0)
         return;
     }
@@ -244,7 +244,7 @@
 
   if (ret->base_addr == NULL)
     {
-      ret->base_addr = xmalloc (ncopies * sizeof (GFC_REAL_8));
+      ret->base_addr = xmallocarray (ncopies, sizeof (GFC_REAL_8));
       ret->offset = 0;
       GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);
     }
Index: libgfortran/generated/minloc1_16_i16.c
===================================================================
--- a/src/libgfortran/generated/minloc1_16_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_16_i16.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/maxloc1_8_r4.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_8_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_8_r4.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/minloc1_16_i1.c
===================================================================
--- a/src/libgfortran/generated/minloc1_16_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_16_i1.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/spread_r16.c
===================================================================
--- a/src/libgfortran/generated/spread_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/spread_r16.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,8 @@
 	}
       ret->offset = 0;
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (rs * sizeof(GFC_REAL_16));
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (rs, sizeof(GFC_REAL_16));
       if (rs <= 0)
         return;
     }
@@ -244,7 +244,7 @@
 
   if (ret->base_addr == NULL)
     {
-      ret->base_addr = xmalloc (ncopies * sizeof (GFC_REAL_16));
+      ret->base_addr = xmallocarray (ncopies, sizeof (GFC_REAL_16));
       ret->offset = 0;
       GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);
     }
Index: libgfortran/generated/pack_c8.c
===================================================================
--- a/src/libgfortran/generated/pack_c8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/pack_c8.c	(.../branches/gcc-4_9-branch)
@@ -167,8 +167,8 @@
 
 	  ret->offset = 0;
 
-	  /* xmalloc allocates a single byte for zero size.  */
-	  ret->base_addr = xmalloc (sizeof (GFC_COMPLEX_8) * total);
+	  /* xmallocarray allocates a single byte for zero size.  */
+	  ret->base_addr = xmallocarray (total, sizeof (GFC_COMPLEX_8));
 
 	  if (total == 0)
 	    return;
Index: libgfortran/generated/minval_r10.c
===================================================================
--- a/src/libgfortran/generated/minval_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minval_r10.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_10));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_10));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_10));
     }
   else
     {
Index: libgfortran/generated/parity_l8.c
===================================================================
--- a/src/libgfortran/generated/parity_l8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/parity_l8.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_LOGICAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_LOGICAL_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
Index: libgfortran/generated/minval_i4.c
===================================================================
--- a/src/libgfortran/generated/minval_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minval_i4.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/maxloc1_8_i2.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_8_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_8_i2.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/any_l8.c
===================================================================
--- a/src/libgfortran/generated/any_l8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/any_l8.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_LOGICAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -111,7 +110,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_LOGICAL_8));
     }
   else
     {
Index: libgfortran/generated/maxloc0_16_r10.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_16_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_16_r10.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/minloc0_4_i16.c
===================================================================
--- a/src/libgfortran/generated/minloc0_4_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_4_i16.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/maxloc0_8_r8.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_8_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_8_r8.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/minloc1_4_r10.c
===================================================================
--- a/src/libgfortran/generated/minloc1_4_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_4_r10.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/minloc1_8_i16.c
===================================================================
--- a/src/libgfortran/generated/minloc1_8_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_8_i16.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/maxloc0_8_r10.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_8_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_8_r10.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/unpack_i4.c
===================================================================
--- a/src/libgfortran/generated/unpack_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/unpack_i4.c	(.../branches/gcc-4_9-branch)
@@ -99,7 +99,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_INTEGER_4));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -244,7 +244,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_INTEGER_4));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/minloc1_16_r4.c
===================================================================
--- a/src/libgfortran/generated/minloc1_16_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_16_r4.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/product_i8.c
===================================================================
--- a/src/libgfortran/generated/product_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/product_i8.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/minloc0_16_r8.c
===================================================================
--- a/src/libgfortran/generated/minloc0_16_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_16_r8.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/count_2_l.c
===================================================================
--- a/src/libgfortran/generated/count_2_l.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/count_2_l.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -111,7 +110,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
     }
   else
     {
Index: libgfortran/generated/transpose_r8.c
===================================================================
--- a/src/libgfortran/generated/transpose_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/transpose_r8.c	(.../branches/gcc-4_9-branch)
@@ -60,7 +60,8 @@
       GFC_DIMENSION_SET(ret->dim[1], 0, GFC_DESCRIPTOR_EXTENT(source,0) - 1,
 			GFC_DESCRIPTOR_EXTENT(source, 1));
 
-      ret->base_addr = xmalloc (sizeof (GFC_REAL_8) * size0 ((array_t *) ret));
+      ret->base_addr = xmallocarray (size0 ((array_t *) ret), 
+                                     sizeof (GFC_REAL_8));
       ret->offset = 0;
     } else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/cshift1_8.c
===================================================================
--- a/src/libgfortran/generated/cshift1_8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/cshift1_8.c	(.../branches/gcc-4_9-branch)
@@ -80,7 +80,7 @@
     {
       int i;
 
-      ret->base_addr = xmalloc (size * arraysize);
+      ret->base_addr = xmallocarray (arraysize, size);
       ret->offset = 0;
       ret->dtype = array->dtype;
       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)
Index: libgfortran/generated/matmul_i4.c
===================================================================
--- a/src/libgfortran/generated/matmul_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_i4.c	(.../branches/gcc-4_9-branch)
@@ -124,7 +124,7 @@
         }
 
       retarray->base_addr
-	= xmalloc (sizeof (GFC_INTEGER_4) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_4));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/pack_r10.c
===================================================================
--- a/src/libgfortran/generated/pack_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/pack_r10.c	(.../branches/gcc-4_9-branch)
@@ -167,8 +167,8 @@
 
 	  ret->offset = 0;
 
-	  /* xmalloc allocates a single byte for zero size.  */
-	  ret->base_addr = xmalloc (sizeof (GFC_REAL_10) * total);
+	  /* xmallocarray allocates a single byte for zero size.  */
+	  ret->base_addr = xmallocarray (total, sizeof (GFC_REAL_10));
 
 	  if (total == 0)
 	    return;
Index: libgfortran/generated/minloc1_16_i2.c
===================================================================
--- a/src/libgfortran/generated/minloc1_16_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_16_i2.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/in_pack_i8.c
===================================================================
--- a/src/libgfortran/generated/in_pack_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/in_pack_i8.c	(.../branches/gcc-4_9-branch)
@@ -76,7 +76,7 @@
     return source->base_addr;
 
   /* Allocate storage for the destination.  */
-  destptr = (GFC_INTEGER_8 *)xmalloc (ssize * sizeof (GFC_INTEGER_8));
+  destptr = xmallocarray (ssize, sizeof (GFC_INTEGER_8));
   dest = destptr;
   src = source->base_addr;
   stride0 = stride[0];
Index: libgfortran/generated/transpose_r16.c
===================================================================
--- a/src/libgfortran/generated/transpose_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/transpose_r16.c	(.../branches/gcc-4_9-branch)
@@ -60,7 +60,8 @@
       GFC_DIMENSION_SET(ret->dim[1], 0, GFC_DESCRIPTOR_EXTENT(source,0) - 1,
 			GFC_DESCRIPTOR_EXTENT(source, 1));
 
-      ret->base_addr = xmalloc (sizeof (GFC_REAL_16) * size0 ((array_t *) ret));
+      ret->base_addr = xmallocarray (size0 ((array_t *) ret), 
+                                     sizeof (GFC_REAL_16));
       ret->offset = 0;
     } else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/minloc1_4_i4.c
===================================================================
--- a/src/libgfortran/generated/minloc1_4_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_4_i4.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/maxval_i1.c
===================================================================
--- a/src/libgfortran/generated/maxval_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxval_i1.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
     }
   else
     {
Index: libgfortran/generated/product_c16.c
===================================================================
--- a/src/libgfortran/generated/product_c16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/product_c16.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_COMPLEX_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_16));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_16));
     }
   else
     {
Index: libgfortran/generated/reshape_r4.c
===================================================================
--- a/src/libgfortran/generated/reshape_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/reshape_r4.c	(.../branches/gcc-4_9-branch)
@@ -111,11 +111,11 @@
       ret->offset = 0;
 
       if (unlikely (rs < 1))
-        alloc_size = 1;
+        alloc_size = 0;
       else
-        alloc_size = rs * sizeof (GFC_REAL_4);
+        alloc_size = rs;
 
-      ret->base_addr = xmalloc (alloc_size);
+      ret->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_4));
       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;
     }
 
Index: libgfortran/generated/iany_i8.c
===================================================================
--- a/src/libgfortran/generated/iany_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/iany_i8.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/cshift1_16.c
===================================================================
--- a/src/libgfortran/generated/cshift1_16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/cshift1_16.c	(.../branches/gcc-4_9-branch)
@@ -80,7 +80,7 @@
     {
       int i;
 
-      ret->base_addr = xmalloc (size * arraysize);
+      ret->base_addr = xmallocarray (arraysize, size);
       ret->offset = 0;
       ret->dtype = array->dtype;
       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)
Index: libgfortran/generated/maxloc0_4_i1.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_4_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_4_i1.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/minloc0_4_i8.c
===================================================================
--- a/src/libgfortran/generated/minloc0_4_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_4_i8.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/spread_c16.c
===================================================================
--- a/src/libgfortran/generated/spread_c16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/spread_c16.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,8 @@
 	}
       ret->offset = 0;
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (rs * sizeof(GFC_COMPLEX_16));
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (rs, sizeof(GFC_COMPLEX_16));
       if (rs <= 0)
         return;
     }
@@ -244,7 +244,7 @@
 
   if (ret->base_addr == NULL)
     {
-      ret->base_addr = xmalloc (ncopies * sizeof (GFC_COMPLEX_16));
+      ret->base_addr = xmallocarray (ncopies, sizeof (GFC_COMPLEX_16));
       ret->offset = 0;
       GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);
     }
Index: libgfortran/generated/maxval_r4.c
===================================================================
--- a/src/libgfortran/generated/maxval_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxval_r4.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_4));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_4));
     }
   else
     {
Index: libgfortran/generated/minval_r8.c
===================================================================
--- a/src/libgfortran/generated/minval_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minval_r8.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_8));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_8));
     }
   else
     {
Index: libgfortran/generated/minloc1_16_r16.c
===================================================================
--- a/src/libgfortran/generated/minloc1_16_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_16_r16.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/unpack_i16.c
===================================================================
--- a/src/libgfortran/generated/unpack_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/unpack_i16.c	(.../branches/gcc-4_9-branch)
@@ -99,7 +99,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_INTEGER_16));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -244,7 +244,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_INTEGER_16));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/sum_i8.c
===================================================================
--- a/src/libgfortran/generated/sum_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/sum_i8.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/pack_i1.c
===================================================================
--- a/src/libgfortran/generated/pack_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/pack_i1.c	(.../branches/gcc-4_9-branch)
@@ -167,8 +167,8 @@
 
 	  ret->offset = 0;
 
-	  /* xmalloc allocates a single byte for zero size.  */
-	  ret->base_addr = xmalloc (sizeof (GFC_INTEGER_1) * total);
+	  /* xmallocarray allocates a single byte for zero size.  */
+	  ret->base_addr = xmallocarray (total, sizeof (GFC_INTEGER_1));
 
 	  if (total == 0)
 	    return;
Index: libgfortran/generated/any_l16.c
===================================================================
--- a/src/libgfortran/generated/any_l16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/any_l16.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_LOGICAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -111,7 +110,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_LOGICAL_16));
     }
   else
     {
Index: libgfortran/generated/spread_i8.c
===================================================================
--- a/src/libgfortran/generated/spread_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/spread_i8.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,8 @@
 	}
       ret->offset = 0;
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (rs * sizeof(GFC_INTEGER_8));
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (rs, sizeof(GFC_INTEGER_8));
       if (rs <= 0)
         return;
     }
@@ -244,7 +244,7 @@
 
   if (ret->base_addr == NULL)
     {
-      ret->base_addr = xmalloc (ncopies * sizeof (GFC_INTEGER_8));
+      ret->base_addr = xmallocarray (ncopies, sizeof (GFC_INTEGER_8));
       ret->offset = 0;
       GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);
     }
Index: libgfortran/generated/maxval_i2.c
===================================================================
--- a/src/libgfortran/generated/maxval_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxval_i2.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
     }
   else
     {
Index: libgfortran/generated/maxloc1_8_i4.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_8_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_8_i4.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/unpack_r8.c
===================================================================
--- a/src/libgfortran/generated/unpack_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/unpack_r8.c	(.../branches/gcc-4_9-branch)
@@ -99,7 +99,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_REAL_8));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_REAL_8));
     }
   else
     {
@@ -244,7 +244,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_REAL_8));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_REAL_8));
     }
   else
     {
Index: libgfortran/generated/maxloc0_4_r4.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_4_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_4_r4.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/all_l1.c
===================================================================
--- a/src/libgfortran/generated/all_l1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/all_l1.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_LOGICAL_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -111,7 +110,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_LOGICAL_1));
     }
   else
     {
Index: libgfortran/generated/matmul_r8.c
===================================================================
--- a/src/libgfortran/generated/matmul_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_r8.c	(.../branches/gcc-4_9-branch)
@@ -124,7 +124,7 @@
         }
 
       retarray->base_addr
-	= xmalloc (sizeof (GFC_REAL_8) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_REAL_8));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/minloc0_4_r16.c
===================================================================
--- a/src/libgfortran/generated/minloc0_4_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_4_r16.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/maxloc0_4_i2.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_4_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_4_i2.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/minloc1_8_r16.c
===================================================================
--- a/src/libgfortran/generated/minloc1_8_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_8_r16.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/pack_c10.c
===================================================================
--- a/src/libgfortran/generated/pack_c10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/pack_c10.c	(.../branches/gcc-4_9-branch)
@@ -167,8 +167,8 @@
 
 	  ret->offset = 0;
 
-	  /* xmalloc allocates a single byte for zero size.  */
-	  ret->base_addr = xmalloc (sizeof (GFC_COMPLEX_10) * total);
+	  /* xmallocarray allocates a single byte for zero size.  */
+	  ret->base_addr = xmallocarray (total, sizeof (GFC_COMPLEX_10));
 
 	  if (total == 0)
 	    return;
Index: libgfortran/generated/pack_r4.c
===================================================================
--- a/src/libgfortran/generated/pack_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/pack_r4.c	(.../branches/gcc-4_9-branch)
@@ -167,8 +167,8 @@
 
 	  ret->offset = 0;
 
-	  /* xmalloc allocates a single byte for zero size.  */
-	  ret->base_addr = xmalloc (sizeof (GFC_REAL_4) * total);
+	  /* xmallocarray allocates a single byte for zero size.  */
+	  ret->base_addr = xmallocarray (total, sizeof (GFC_REAL_4));
 
 	  if (total == 0)
 	    return;
Index: libgfortran/generated/transpose_c16.c
===================================================================
--- a/src/libgfortran/generated/transpose_c16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/transpose_c16.c	(.../branches/gcc-4_9-branch)
@@ -60,7 +60,8 @@
       GFC_DIMENSION_SET(ret->dim[1], 0, GFC_DESCRIPTOR_EXTENT(source,0) - 1,
 			GFC_DESCRIPTOR_EXTENT(source, 1));
 
-      ret->base_addr = xmalloc (sizeof (GFC_COMPLEX_16) * size0 ((array_t *) ret));
+      ret->base_addr = xmallocarray (size0 ((array_t *) ret), 
+                                     sizeof (GFC_COMPLEX_16));
       ret->offset = 0;
     } else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/maxloc0_8_i8.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_8_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_8_i8.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/minloc1_4_r8.c
===================================================================
--- a/src/libgfortran/generated/minloc1_4_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_4_r8.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/minloc1_16_i4.c
===================================================================
--- a/src/libgfortran/generated/minloc1_16_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_16_i4.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/minloc0_16_i8.c
===================================================================
--- a/src/libgfortran/generated/minloc0_16_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_16_i8.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/pack_i2.c
===================================================================
--- a/src/libgfortran/generated/pack_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/pack_i2.c	(.../branches/gcc-4_9-branch)
@@ -167,8 +167,8 @@
 
 	  ret->offset = 0;
 
-	  /* xmalloc allocates a single byte for zero size.  */
-	  ret->base_addr = xmalloc (sizeof (GFC_INTEGER_2) * total);
+	  /* xmallocarray allocates a single byte for zero size.  */
+	  ret->base_addr = xmallocarray (total, sizeof (GFC_INTEGER_2));
 
 	  if (total == 0)
 	    return;
Index: libgfortran/generated/transpose_i8.c
===================================================================
--- a/src/libgfortran/generated/transpose_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/transpose_i8.c	(.../branches/gcc-4_9-branch)
@@ -60,7 +60,8 @@
       GFC_DIMENSION_SET(ret->dim[1], 0, GFC_DESCRIPTOR_EXTENT(source,0) - 1,
 			GFC_DESCRIPTOR_EXTENT(source, 1));
 
-      ret->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * size0 ((array_t *) ret));
+      ret->base_addr = xmallocarray (size0 ((array_t *) ret), 
+                                     sizeof (GFC_INTEGER_8));
       ret->offset = 0;
     } else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/eoshift1_16.c
===================================================================
--- a/src/libgfortran/generated/eoshift1_16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/eoshift1_16.c	(.../branches/gcc-4_9-branch)
@@ -105,8 +105,8 @@
 	  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);
 
         }
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (size * arraysize);
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (arraysize, size);
 
     }
   else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/all_l2.c
===================================================================
--- a/src/libgfortran/generated/all_l2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/all_l2.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_LOGICAL_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -111,7 +110,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_LOGICAL_2));
     }
   else
     {
Index: libgfortran/generated/product_c4.c
===================================================================
--- a/src/libgfortran/generated/product_c4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/product_c4.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_COMPLEX_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_4));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_4));
     }
   else
     {
Index: libgfortran/generated/iall_i1.c
===================================================================
--- a/src/libgfortran/generated/iall_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/iall_i1.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
     }
   else
     {
Index: libgfortran/generated/reshape_i4.c
===================================================================
--- a/src/libgfortran/generated/reshape_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/reshape_i4.c	(.../branches/gcc-4_9-branch)
@@ -111,11 +111,11 @@
       ret->offset = 0;
 
       if (unlikely (rs < 1))
-        alloc_size = 1;
+        alloc_size = 0;
       else
-        alloc_size = rs * sizeof (GFC_INTEGER_4);
+        alloc_size = rs;
 
-      ret->base_addr = xmalloc (alloc_size);
+      ret->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;
     }
 
Index: libgfortran/generated/in_pack_r10.c
===================================================================
--- a/src/libgfortran/generated/in_pack_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/in_pack_r10.c	(.../branches/gcc-4_9-branch)
@@ -76,7 +76,7 @@
     return source->base_addr;
 
   /* Allocate storage for the destination.  */
-  destptr = (GFC_REAL_10 *)xmalloc (ssize * sizeof (GFC_REAL_10));
+  destptr = xmallocarray (ssize, sizeof (GFC_REAL_10));
   dest = destptr;
   src = source->base_addr;
   stride0 = stride[0];
Index: libgfortran/generated/in_pack_c4.c
===================================================================
--- a/src/libgfortran/generated/in_pack_c4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/in_pack_c4.c	(.../branches/gcc-4_9-branch)
@@ -76,7 +76,7 @@
     return source->base_addr;
 
   /* Allocate storage for the destination.  */
-  destptr = (GFC_COMPLEX_4 *)xmalloc (ssize * sizeof (GFC_COMPLEX_4));
+  destptr = xmallocarray (ssize, sizeof (GFC_COMPLEX_4));
   dest = destptr;
   src = source->base_addr;
   stride0 = stride[0];
Index: libgfortran/generated/all_l16.c
===================================================================
--- a/src/libgfortran/generated/all_l16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/all_l16.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_LOGICAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -111,7 +110,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_LOGICAL_16));
     }
   else
     {
Index: libgfortran/generated/maxloc0_16_i1.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_16_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_16_i1.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/maxloc1_8_r8.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_8_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_8_r8.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/minval_i16.c
===================================================================
--- a/src/libgfortran/generated/minval_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minval_i16.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/reshape_r10.c
===================================================================
--- a/src/libgfortran/generated/reshape_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/reshape_r10.c	(.../branches/gcc-4_9-branch)
@@ -111,11 +111,11 @@
       ret->offset = 0;
 
       if (unlikely (rs < 1))
-        alloc_size = 1;
+        alloc_size = 0;
       else
-        alloc_size = rs * sizeof (GFC_REAL_10);
+        alloc_size = rs;
 
-      ret->base_addr = xmalloc (alloc_size);
+      ret->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_10));
       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;
     }
 
Index: libgfortran/generated/unpack_r16.c
===================================================================
--- a/src/libgfortran/generated/unpack_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/unpack_r16.c	(.../branches/gcc-4_9-branch)
@@ -99,7 +99,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_REAL_16));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_REAL_16));
     }
   else
     {
@@ -244,7 +244,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_REAL_16));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_REAL_16));
     }
   else
     {
Index: libgfortran/generated/maxval_i4.c
===================================================================
--- a/src/libgfortran/generated/maxval_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxval_i4.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/minval_i8.c
===================================================================
--- a/src/libgfortran/generated/minval_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minval_i8.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/maxloc0_16_i16.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_16_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_16_i16.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/shape_i4.c
===================================================================
--- a/src/libgfortran/generated/shape_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/shape_i4.c	(.../branches/gcc-4_9-branch)
@@ -49,7 +49,7 @@
     {
       GFC_DIMENSION_SET(ret->dim[0], 0, rank - 1, 1);
       ret->offset = 0;
-      ret->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      ret->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
 
   stride = GFC_DESCRIPTOR_STRIDE(ret,0);
Index: libgfortran/generated/minloc1_4_i16.c
===================================================================
--- a/src/libgfortran/generated/minloc1_4_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_4_i16.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/maxloc0_4_r10.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_4_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_4_r10.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/maxloc0_8_i16.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_8_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_8_i16.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/iall_i2.c
===================================================================
--- a/src/libgfortran/generated/iall_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/iall_i2.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
     }
   else
     {
Index: libgfortran/generated/maxloc1_8_r10.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_8_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_8_r10.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/maxloc0_16_r4.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_16_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_16_r4.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/minloc0_8_i1.c
===================================================================
--- a/src/libgfortran/generated/minloc0_8_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_8_i1.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/minloc1_16_r8.c
===================================================================
--- a/src/libgfortran/generated/minloc1_16_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_16_r8.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/unpack_i8.c
===================================================================
--- a/src/libgfortran/generated/unpack_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/unpack_i8.c	(.../branches/gcc-4_9-branch)
@@ -99,7 +99,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_INTEGER_8));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -244,7 +244,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_INTEGER_8));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/maxloc0_4_i4.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_4_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_4_i4.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/count_4_l.c
===================================================================
--- a/src/libgfortran/generated/count_4_l.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/count_4_l.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -111,7 +110,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/sum_r10.c
===================================================================
--- a/src/libgfortran/generated/sum_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/sum_r10.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_10));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_10));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_10));
     }
   else
     {
Index: libgfortran/generated/sum_c4.c
===================================================================
--- a/src/libgfortran/generated/sum_c4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/sum_c4.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_COMPLEX_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_4));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_4));
     }
   else
     {
Index: libgfortran/generated/maxloc1_16_r10.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_16_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_16_r10.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/pack_i16.c
===================================================================
--- a/src/libgfortran/generated/pack_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/pack_i16.c	(.../branches/gcc-4_9-branch)
@@ -167,8 +167,8 @@
 
 	  ret->offset = 0;
 
-	  /* xmalloc allocates a single byte for zero size.  */
-	  ret->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * total);
+	  /* xmallocarray allocates a single byte for zero size.  */
+	  ret->base_addr = xmallocarray (total, sizeof (GFC_INTEGER_16));
 
 	  if (total == 0)
 	    return;
Index: libgfortran/generated/matmul_i8.c
===================================================================
--- a/src/libgfortran/generated/matmul_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_i8.c	(.../branches/gcc-4_9-branch)
@@ -124,7 +124,7 @@
         }
 
       retarray->base_addr
-	= xmalloc (sizeof (GFC_INTEGER_8) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_8));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/maxloc0_16_i2.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_16_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_16_i2.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/spread_c4.c
===================================================================
--- a/src/libgfortran/generated/spread_c4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/spread_c4.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,8 @@
 	}
       ret->offset = 0;
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (rs * sizeof(GFC_COMPLEX_4));
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (rs, sizeof(GFC_COMPLEX_4));
       if (rs <= 0)
         return;
     }
@@ -244,7 +244,7 @@
 
   if (ret->base_addr == NULL)
     {
-      ret->base_addr = xmalloc (ncopies * sizeof (GFC_COMPLEX_4));
+      ret->base_addr = xmallocarray (ncopies, sizeof (GFC_COMPLEX_4));
       ret->offset = 0;
       GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);
     }
Index: libgfortran/generated/maxval_r10.c
===================================================================
--- a/src/libgfortran/generated/maxval_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxval_r10.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_10));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_10));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_10));
     }
   else
     {
Index: libgfortran/generated/pack_i4.c
===================================================================
--- a/src/libgfortran/generated/pack_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/pack_i4.c	(.../branches/gcc-4_9-branch)
@@ -167,8 +167,8 @@
 
 	  ret->offset = 0;
 
-	  /* xmalloc allocates a single byte for zero size.  */
-	  ret->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * total);
+	  /* xmallocarray allocates a single byte for zero size.  */
+	  ret->base_addr = xmallocarray (total, sizeof (GFC_INTEGER_4));
 
 	  if (total == 0)
 	    return;
Index: libgfortran/generated/maxloc1_4_i1.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_4_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_4_i1.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/matmul_r10.c
===================================================================
--- a/src/libgfortran/generated/matmul_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_r10.c	(.../branches/gcc-4_9-branch)
@@ -124,7 +124,7 @@
         }
 
       retarray->base_addr
-	= xmalloc (sizeof (GFC_REAL_10) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_REAL_10));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/minloc1_4_i8.c
===================================================================
--- a/src/libgfortran/generated/minloc1_4_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_4_i8.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/minloc0_8_r4.c
===================================================================
--- a/src/libgfortran/generated/minloc0_8_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_8_r4.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/matmul_l4.c
===================================================================
--- a/src/libgfortran/generated/matmul_l4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_l4.c	(.../branches/gcc-4_9-branch)
@@ -88,7 +88,7 @@
         }
           
       retarray->base_addr
-	= xmalloc (sizeof (GFC_LOGICAL_4) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_LOGICAL_4));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/reshape_r8.c
===================================================================
--- a/src/libgfortran/generated/reshape_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/reshape_r8.c	(.../branches/gcc-4_9-branch)
@@ -111,11 +111,11 @@
       ret->offset = 0;
 
       if (unlikely (rs < 1))
-        alloc_size = 1;
+        alloc_size = 0;
       else
-        alloc_size = rs * sizeof (GFC_REAL_8);
+        alloc_size = rs;
 
-      ret->base_addr = xmalloc (alloc_size);
+      ret->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_8));
       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;
     }
 
Index: libgfortran/generated/in_pack_c10.c
===================================================================
--- a/src/libgfortran/generated/in_pack_c10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/in_pack_c10.c	(.../branches/gcc-4_9-branch)
@@ -76,7 +76,7 @@
     return source->base_addr;
 
   /* Allocate storage for the destination.  */
-  destptr = (GFC_COMPLEX_10 *)xmalloc (ssize * sizeof (GFC_COMPLEX_10));
+  destptr = xmallocarray (ssize, sizeof (GFC_COMPLEX_10));
   dest = destptr;
   src = source->base_addr;
   stride0 = stride[0];
Index: libgfortran/generated/all_l4.c
===================================================================
--- a/src/libgfortran/generated/all_l4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/all_l4.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_LOGICAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -111,7 +110,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_LOGICAL_4));
     }
   else
     {
Index: libgfortran/generated/minloc0_8_i2.c
===================================================================
--- a/src/libgfortran/generated/minloc0_8_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_8_i2.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/norm2_r16.c
===================================================================
--- a/src/libgfortran/generated/norm2_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/norm2_r16.c	(.../branches/gcc-4_9-branch)
@@ -105,10 +105,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
Index: libgfortran/generated/reshape_c10.c
===================================================================
--- a/src/libgfortran/generated/reshape_c10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/reshape_c10.c	(.../branches/gcc-4_9-branch)
@@ -111,11 +111,11 @@
       ret->offset = 0;
 
       if (unlikely (rs < 1))
-        alloc_size = 1;
+        alloc_size = 0;
       else
-        alloc_size = rs * sizeof (GFC_COMPLEX_10);
+        alloc_size = rs;
 
-      ret->base_addr = xmalloc (alloc_size);
+      ret->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_10));
       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;
     }
 
Index: libgfortran/generated/unpack_c16.c
===================================================================
--- a/src/libgfortran/generated/unpack_c16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/unpack_c16.c	(.../branches/gcc-4_9-branch)
@@ -99,7 +99,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_COMPLEX_16));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_COMPLEX_16));
     }
   else
     {
@@ -244,7 +244,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_COMPLEX_16));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_COMPLEX_16));
     }
   else
     {
Index: libgfortran/generated/maxloc1_4_r4.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_4_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_4_r4.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/maxval_r8.c
===================================================================
--- a/src/libgfortran/generated/maxval_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxval_r8.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_8));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_8));
     }
   else
     {
Index: libgfortran/generated/transpose_c4.c
===================================================================
--- a/src/libgfortran/generated/transpose_c4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/transpose_c4.c	(.../branches/gcc-4_9-branch)
@@ -60,7 +60,8 @@
       GFC_DIMENSION_SET(ret->dim[1], 0, GFC_DESCRIPTOR_EXTENT(source,0) - 1,
 			GFC_DESCRIPTOR_EXTENT(source, 1));
 
-      ret->base_addr = xmalloc (sizeof (GFC_COMPLEX_4) * size0 ((array_t *) ret));
+      ret->base_addr = xmallocarray (size0 ((array_t *) ret), 
+                                     sizeof (GFC_COMPLEX_4));
       ret->offset = 0;
     } else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/eoshift1_4.c
===================================================================
--- a/src/libgfortran/generated/eoshift1_4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/eoshift1_4.c	(.../branches/gcc-4_9-branch)
@@ -105,8 +105,8 @@
 	  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);
 
         }
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (size * arraysize);
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (arraysize, size);
 
     }
   else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/minval_r16.c
===================================================================
--- a/src/libgfortran/generated/minval_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minval_r16.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_16));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_16));
     }
   else
     {
Index: libgfortran/generated/iany_i16.c
===================================================================
--- a/src/libgfortran/generated/iany_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/iany_i16.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/maxloc1_4_i2.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_4_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_4_i2.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/maxloc1_8_i8.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_8_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_8_i8.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/maxloc0_4_r8.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_4_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_4_r8.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/maxloc0_16_r16.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_16_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_16_r16.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/sum_c10.c
===================================================================
--- a/src/libgfortran/generated/sum_c10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/sum_c10.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_10));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_COMPLEX_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_10));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_10));
     }
   else
     {
Index: libgfortran/generated/iall_i4.c
===================================================================
--- a/src/libgfortran/generated/iall_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/iall_i4.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/minloc1_4_r16.c
===================================================================
--- a/src/libgfortran/generated/minloc1_4_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_4_r16.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/maxloc0_8_r16.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_8_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_8_r16.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/pack_r8.c
===================================================================
--- a/src/libgfortran/generated/pack_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/pack_r8.c	(.../branches/gcc-4_9-branch)
@@ -167,8 +167,8 @@
 
 	  ret->offset = 0;
 
-	  /* xmalloc allocates a single byte for zero size.  */
-	  ret->base_addr = xmalloc (sizeof (GFC_REAL_8) * total);
+	  /* xmallocarray allocates a single byte for zero size.  */
+	  ret->base_addr = xmallocarray (total, sizeof (GFC_REAL_8));
 
 	  if (total == 0)
 	    return;
Index: libgfortran/generated/matmul_c10.c
===================================================================
--- a/src/libgfortran/generated/matmul_c10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_c10.c	(.../branches/gcc-4_9-branch)
@@ -124,7 +124,7 @@
         }
 
       retarray->base_addr
-	= xmalloc (sizeof (GFC_COMPLEX_10) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_10));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/maxloc0_16_i4.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_16_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_16_i4.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/pack_r16.c
===================================================================
--- a/src/libgfortran/generated/pack_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/pack_r16.c	(.../branches/gcc-4_9-branch)
@@ -167,8 +167,8 @@
 
 	  ret->offset = 0;
 
-	  /* xmalloc allocates a single byte for zero size.  */
-	  ret->base_addr = xmalloc (sizeof (GFC_REAL_16) * total);
+	  /* xmallocarray allocates a single byte for zero size.  */
+	  ret->base_addr = xmallocarray (total, sizeof (GFC_REAL_16));
 
 	  if (total == 0)
 	    return;
Index: libgfortran/generated/minloc1_16_i8.c
===================================================================
--- a/src/libgfortran/generated/minloc1_16_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_16_i8.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/minloc0_16_r10.c
===================================================================
--- a/src/libgfortran/generated/minloc0_16_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_16_r10.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/unpack_c4.c
===================================================================
--- a/src/libgfortran/generated/unpack_c4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/unpack_c4.c	(.../branches/gcc-4_9-branch)
@@ -99,7 +99,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_COMPLEX_4));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_COMPLEX_4));
     }
   else
     {
@@ -244,7 +244,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_COMPLEX_4));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_COMPLEX_4));
     }
   else
     {
Index: libgfortran/generated/iparity_i1.c
===================================================================
--- a/src/libgfortran/generated/iparity_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/iparity_i1.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
     }
   else
     {
Index: libgfortran/generated/product_c8.c
===================================================================
--- a/src/libgfortran/generated/product_c8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/product_c8.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_COMPLEX_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_8));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_8));
     }
   else
     {
Index: libgfortran/generated/in_pack_i16.c
===================================================================
--- a/src/libgfortran/generated/in_pack_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/in_pack_i16.c	(.../branches/gcc-4_9-branch)
@@ -76,7 +76,7 @@
     return source->base_addr;
 
   /* Allocate storage for the destination.  */
-  destptr = (GFC_INTEGER_16 *)xmalloc (ssize * sizeof (GFC_INTEGER_16));
+  destptr = xmallocarray (ssize, sizeof (GFC_INTEGER_16));
   dest = destptr;
   src = source->base_addr;
   stride0 = stride[0];
Index: libgfortran/generated/minloc0_8_i4.c
===================================================================
--- a/src/libgfortran/generated/minloc0_8_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_8_i4.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/matmul_c4.c
===================================================================
--- a/src/libgfortran/generated/matmul_c4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_c4.c	(.../branches/gcc-4_9-branch)
@@ -124,7 +124,7 @@
         }
 
       retarray->base_addr
-	= xmalloc (sizeof (GFC_COMPLEX_4) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_4));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/reshape_i8.c
===================================================================
--- a/src/libgfortran/generated/reshape_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/reshape_i8.c	(.../branches/gcc-4_9-branch)
@@ -111,11 +111,11 @@
       ret->offset = 0;
 
       if (unlikely (rs < 1))
-        alloc_size = 1;
+        alloc_size = 0;
       else
-        alloc_size = rs * sizeof (GFC_INTEGER_8);
+        alloc_size = rs;
 
-      ret->base_addr = xmalloc (alloc_size);
+      ret->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;
     }
 
Index: libgfortran/generated/in_pack_c8.c
===================================================================
--- a/src/libgfortran/generated/in_pack_c8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/in_pack_c8.c	(.../branches/gcc-4_9-branch)
@@ -76,7 +76,7 @@
     return source->base_addr;
 
   /* Allocate storage for the destination.  */
-  destptr = (GFC_COMPLEX_8 *)xmalloc (ssize * sizeof (GFC_COMPLEX_8));
+  destptr = xmallocarray (ssize, sizeof (GFC_COMPLEX_8));
   dest = destptr;
   src = source->base_addr;
   stride0 = stride[0];
Index: libgfortran/generated/bessel_r10.c
===================================================================
--- a/src/libgfortran/generated/bessel_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/bessel_r10.c	(.../branches/gcc-4_9-branch)
@@ -55,7 +55,7 @@
     {
       size_t size = n2 < n1 ? 0 : n2-n1+1; 
       GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);
-      ret->base_addr = xmalloc (sizeof (GFC_REAL_10) * size);
+      ret->base_addr = xmallocarray (size, sizeof (GFC_REAL_10));
       ret->offset = 0;
     }
 
@@ -122,7 +122,7 @@
     {
       size_t size = n2 < n1 ? 0 : n2-n1+1; 
       GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);
-      ret->base_addr = xmalloc (sizeof (GFC_REAL_10) * size);
+      ret->base_addr = xmallocarray (size, sizeof (GFC_REAL_10));
       ret->offset = 0;
     }
 
@@ -162,7 +162,7 @@
 
   x2rev = GFC_REAL_10_LITERAL(2.)/x;
 
-  for (i = 2; i <= n1+n2; i++)
+  for (i = 2; i <= n2 - n1; i++)
     {
 #if defined(GFC_REAL_10_INFINITY)
       if (unlikely (last2 == -GFC_REAL_10_INFINITY))
Index: libgfortran/generated/iall_i16.c
===================================================================
--- a/src/libgfortran/generated/iall_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/iall_i16.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/maxloc1_16_i1.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_16_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_16_i1.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/reshape_i16.c
===================================================================
--- a/src/libgfortran/generated/reshape_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/reshape_i16.c	(.../branches/gcc-4_9-branch)
@@ -111,11 +111,11 @@
       ret->offset = 0;
 
       if (unlikely (rs < 1))
-        alloc_size = 1;
+        alloc_size = 0;
       else
-        alloc_size = rs * sizeof (GFC_INTEGER_16);
+        alloc_size = rs;
 
-      ret->base_addr = xmalloc (alloc_size);
+      ret->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;
     }
 
Index: libgfortran/generated/count_16_l.c
===================================================================
--- a/src/libgfortran/generated/count_16_l.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/count_16_l.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -111,7 +110,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/minloc1_8_i1.c
===================================================================
--- a/src/libgfortran/generated/minloc1_8_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_8_i1.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/maxloc1_4_i4.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_4_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_4_i4.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/maxval_i8.c
===================================================================
--- a/src/libgfortran/generated/maxval_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxval_i8.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/eoshift3_16.c
===================================================================
--- a/src/libgfortran/generated/eoshift3_16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/eoshift3_16.c	(.../branches/gcc-4_9-branch)
@@ -89,7 +89,7 @@
     {
       int i;
 
-      ret->base_addr = xmalloc (size * arraysize);
+      ret->base_addr = xmallocarray (arraysize, size);
       ret->offset = 0;
       ret->dtype = array->dtype;
       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)
@@ -107,8 +107,8 @@
 	  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);
 
         }
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (size * arraysize);
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (arraysize, size);
 
     }
   else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/shape_i8.c
===================================================================
--- a/src/libgfortran/generated/shape_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/shape_i8.c	(.../branches/gcc-4_9-branch)
@@ -49,7 +49,7 @@
     {
       GFC_DIMENSION_SET(ret->dim[0], 0, rank - 1, 1);
       ret->offset = 0;
-      ret->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      ret->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
 
   stride = GFC_DESCRIPTOR_STRIDE(ret,0);
Index: libgfortran/generated/maxloc0_4_i16.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_4_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_4_i16.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/maxloc1_4_r10.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_4_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_4_r10.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/maxloc1_8_i16.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_8_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_8_i16.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/minloc0_8_r10.c
===================================================================
--- a/src/libgfortran/generated/minloc0_8_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_8_r10.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/iparity_i2.c
===================================================================
--- a/src/libgfortran/generated/iparity_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/iparity_i2.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
     }
   else
     {
Index: libgfortran/generated/maxloc1_16_r4.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_16_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_16_r4.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/maxloc0_16_r8.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_16_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_16_r8.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/sum_i16.c
===================================================================
--- a/src/libgfortran/generated/sum_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/sum_i16.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/maxloc0_4_i8.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_4_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_4_i8.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/pack_c16.c
===================================================================
--- a/src/libgfortran/generated/pack_c16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/pack_c16.c	(.../branches/gcc-4_9-branch)
@@ -167,8 +167,8 @@
 
 	  ret->offset = 0;
 
-	  /* xmalloc allocates a single byte for zero size.  */
-	  ret->base_addr = xmalloc (sizeof (GFC_COMPLEX_16) * total);
+	  /* xmallocarray allocates a single byte for zero size.  */
+	  ret->base_addr = xmallocarray (total, sizeof (GFC_COMPLEX_16));
 
 	  if (total == 0)
 	    return;
Index: libgfortran/generated/maxloc1_16_i16.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_16_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_16_i16.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/minloc1_8_r4.c
===================================================================
--- a/src/libgfortran/generated/minloc1_8_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_8_r4.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/sum_c8.c
===================================================================
--- a/src/libgfortran/generated/sum_c8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/sum_c8.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_COMPLEX_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_8));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_8));
     }
   else
     {
Index: libgfortran/generated/maxloc1_16_i2.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_16_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_16_i2.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/parity_l1.c
===================================================================
--- a/src/libgfortran/generated/parity_l1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/parity_l1.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_LOGICAL_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_LOGICAL_1));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
Index: libgfortran/generated/maxval_i16.c
===================================================================
--- a/src/libgfortran/generated/maxval_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxval_i16.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/spread_c8.c
===================================================================
--- a/src/libgfortran/generated/spread_c8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/spread_c8.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,8 @@
 	}
       ret->offset = 0;
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (rs * sizeof(GFC_COMPLEX_8));
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (rs, sizeof(GFC_COMPLEX_8));
       if (rs <= 0)
         return;
     }
@@ -244,7 +244,7 @@
 
   if (ret->base_addr == NULL)
     {
-      ret->base_addr = xmalloc (ncopies * sizeof (GFC_COMPLEX_8));
+      ret->base_addr = xmallocarray (ncopies, sizeof (GFC_COMPLEX_8));
       ret->offset = 0;
       GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);
     }
Index: libgfortran/generated/matmul_i16.c
===================================================================
--- a/src/libgfortran/generated/matmul_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_i16.c	(.../branches/gcc-4_9-branch)
@@ -124,7 +124,7 @@
         }
 
       retarray->base_addr
-	= xmalloc (sizeof (GFC_INTEGER_16) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_16));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/pack_i8.c
===================================================================
--- a/src/libgfortran/generated/pack_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/pack_i8.c	(.../branches/gcc-4_9-branch)
@@ -167,8 +167,8 @@
 
 	  ret->offset = 0;
 
-	  /* xmalloc allocates a single byte for zero size.  */
-	  ret->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * total);
+	  /* xmallocarray allocates a single byte for zero size.  */
+	  ret->base_addr = xmallocarray (total, sizeof (GFC_INTEGER_8));
 
 	  if (total == 0)
 	    return;
Index: libgfortran/generated/any_l1.c
===================================================================
--- a/src/libgfortran/generated/any_l1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/any_l1.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_LOGICAL_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -111,7 +110,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_LOGICAL_1));
     }
   else
     {
Index: libgfortran/generated/minloc1_8_i2.c
===================================================================
--- a/src/libgfortran/generated/minloc1_8_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_8_i2.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/minloc0_8_r8.c
===================================================================
--- a/src/libgfortran/generated/minloc0_8_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_8_r8.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/matmul_l8.c
===================================================================
--- a/src/libgfortran/generated/matmul_l8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_l8.c	(.../branches/gcc-4_9-branch)
@@ -88,7 +88,7 @@
         }
           
       retarray->base_addr
-	= xmalloc (sizeof (GFC_LOGICAL_8) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_LOGICAL_8));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/product_r10.c
===================================================================
--- a/src/libgfortran/generated/product_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/product_r10.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_10));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_10));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_10));
     }
   else
     {
Index: libgfortran/generated/product_i1.c
===================================================================
--- a/src/libgfortran/generated/product_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/product_i1.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
     }
   else
     {
Index: libgfortran/generated/all_l8.c
===================================================================
--- a/src/libgfortran/generated/all_l8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/all_l8.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_LOGICAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -111,7 +110,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_LOGICAL_8));
     }
   else
     {
Index: libgfortran/generated/in_pack_r16.c
===================================================================
--- a/src/libgfortran/generated/in_pack_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/in_pack_r16.c	(.../branches/gcc-4_9-branch)
@@ -76,7 +76,7 @@
     return source->base_addr;
 
   /* Allocate storage for the destination.  */
-  destptr = (GFC_REAL_16 *)xmalloc (ssize * sizeof (GFC_REAL_16));
+  destptr = xmallocarray (ssize, sizeof (GFC_REAL_16));
   dest = destptr;
   src = source->base_addr;
   stride0 = stride[0];
Index: libgfortran/generated/in_pack_i1.c
===================================================================
--- a/src/libgfortran/generated/in_pack_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/in_pack_i1.c	(.../branches/gcc-4_9-branch)
@@ -76,7 +76,7 @@
     return source->base_addr;
 
   /* Allocate storage for the destination.  */
-  destptr = (GFC_INTEGER_1 *)xmalloc (ssize * sizeof (GFC_INTEGER_1));
+  destptr = xmallocarray (ssize, sizeof (GFC_INTEGER_1));
   dest = destptr;
   src = source->base_addr;
   stride0 = stride[0];
Index: libgfortran/libgfortran.h
===================================================================
--- a/src/libgfortran/libgfortran.h	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/libgfortran.h	(.../branches/gcc-4_9-branch)
@@ -768,6 +768,9 @@
 extern void *xmalloc (size_t) __attribute__ ((malloc));
 internal_proto(xmalloc);
 
+extern void *xmallocarray (size_t, size_t) __attribute__ ((malloc));
+internal_proto(xmallocarray);
+
 extern void *xcalloc (size_t, size_t) __attribute__ ((malloc));
 internal_proto(xcalloc);
 
Index: libgfortran/io/list_read.c
===================================================================
--- a/src/libgfortran/io/list_read.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/io/list_read.c	(.../branches/gcc-4_9-branch)
@@ -2407,7 +2407,7 @@
 {
   index_type len = strlen (nl->var_name) + 1;
   int dim;
-  char * ext_name = (char*)xmalloc (len + 1);
+  char * ext_name = xmalloc (len + 1);
   memcpy (ext_name, nl->var_name, len-1);
   memcpy (ext_name + len - 1, "%", 2);
   for (nl = nl->next; nl; nl = nl->next)
Index: libgfortran/io/unit.c
===================================================================
--- a/src/libgfortran/io/unit.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/io/unit.c	(.../branches/gcc-4_9-branch)
@@ -454,7 +454,7 @@
     {
       iunit->rank = GFC_DESCRIPTOR_RANK (dtp->internal_unit_desc);
       iunit->ls = (array_loop_spec *)
-	xmalloc (iunit->rank * sizeof (array_loop_spec));
+	xmallocarray (iunit->rank, sizeof (array_loop_spec));
       dtp->internal_unit_len *=
 	init_loop_spec (dtp->internal_unit_desc, iunit->ls, &start_record);
 
Index: libgfortran/io/transfer.c
===================================================================
--- a/src/libgfortran/io/transfer.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/io/transfer.c	(.../branches/gcc-4_9-branch)
@@ -3786,9 +3786,9 @@
   if (nml->var_rank > 0)
     {
       nml->dim = (descriptor_dimension*)
-		   xmalloc (nml->var_rank * sizeof (descriptor_dimension));
+	xmallocarray (nml->var_rank, sizeof (descriptor_dimension));
       nml->ls = (array_loop_spec*)
-		  xmalloc (nml->var_rank * sizeof (array_loop_spec));
+	xmallocarray (nml->var_rank, sizeof (array_loop_spec));
     }
   else
     {
Index: libgfortran/io/write.c
===================================================================
--- a/src/libgfortran/io/write.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/io/write.c	(.../branches/gcc-4_9-branch)
@@ -1864,7 +1864,7 @@
 	      base_var_name_len = base ? strlen (base->var_name) : 0;
 	      ext_name_len = base_name_len + base_var_name_len 
 		+ strlen (obj->var_name) + obj->var_rank * NML_DIGITS + 1;
-	      ext_name = (char*)xmalloc (ext_name_len);
+	      ext_name = xmalloc (ext_name_len);
 
 	      memcpy (ext_name, base_name, base_name_len);
 	      clen = strlen (obj->var_name + base_var_name_len);
@@ -1893,7 +1893,7 @@
 	      /* Now obj_name.  */
 
 	      obj_name_len = strlen (obj->var_name) + 1;
-	      obj_name = xmalloc (obj_name_len+1);
+	      obj_name = xmalloc (obj_name_len + 1);
 	      memcpy (obj_name, obj->var_name, obj_name_len-1);
 	      memcpy (obj_name + obj_name_len-1, "%", 2);
 
Index: libada/Makefile.in
===================================================================
--- a/src/libada/Makefile.in	(.../tags/gcc_4_9_1_release)
+++ b/src/libada/Makefile.in	(.../branches/gcc-4_9-branch)
@@ -60,7 +60,7 @@
 PICFLAG = @PICFLAG@
 GNATLIBFLAGS= -W -Wall -gnatpg -nostdinc
 GNATLIBCFLAGS= -g -O2
-GNATLIBCFLAGS_FOR_C = -W -Wall $(GNATLIBCFLAGS) \
+GNATLIBCFLAGS_FOR_C = -W -Wall $(GNATLIBCFLAGS) $(CFLAGS_FOR_TARGET) \
 	-fexceptions -DIN_RTS @have_getipinfo@
 
 host_subdir = @host_subdir@
Index: libada/ChangeLog
===================================================================
--- a/src/libada/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/libada/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,7 @@
+2014-08-12  Joel Sherrill <joel.sherrill@oarcorp.com>
+
+	* Makefile.in: Add CFLAGS_FOR_TARGET to GNATLIBCFLAGS_FOR_C.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: .
===================================================================
--- a/src/.	(.../tags/gcc_4_9_1_release)
+++ b/src/.	(.../branches/gcc-4_9-branch)

Property changes on: .
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /trunk:r210615
